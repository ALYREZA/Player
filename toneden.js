webpackJsonp([1],[
/* 0 */,
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2);

	var analytics = __webpack_require__(11);
	var player = __webpack_require__(13);

	ToneDen.ready = true;

	// Record initial load event.
	analytics('ToneDenTracker.send', {
	    hitType: 'event',
	    eventCategory: 'sdk',
	    eventAction: 'loaded',
	    eventLabel: window.location.href
	});

	module.exports = {
	    player: player
	};


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	__webpack_require__(7);
	__webpack_require__(9);


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(4);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./fonts.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./fonts.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports


	// module
	exports.push([module.id, "@font-face {\n\tfont-family: 'td-player';\n\tsrc:url('//sd.toneden.io/resources/fonts/td-player.eot');\n\tsrc:url('//sd.toneden.io/resources/fonts/td-player.eot') format('embedded-opentype'),\n\t\turl('//sd.toneden.io/resources/fonts/td-player.woff') format('woff'),\n\t\turl('//sd.toneden.io/resources/fonts/td-player.ttf') format('truetype'),\n\t\turl('//sd.toneden.io/resources/fonts/td-player.svg') format('svg');\n\tfont-weight: normal;\n\tfont-style: normal;\n}\n\n[class^=\"tdicon-\"], [class*=\"tdicon-\"] {\n\tfont-family: 'td-player';\n\tspeak: none;\n\tfont-style: normal;\n\tfont-weight: normal;\n\tfont-variant: normal;\n\ttext-transform: none;\n\tline-height: 1;\n\tdisplay: inline-block;\n\ttext-rendering: auto;\n\t/* Better Font Rendering =========== */\n\t-webkit-font-smoothing: antialiased;\n\t-moz-osx-font-smoothing: grayscale;\n}\n\n\n.tdicon-share:before {\n\tcontent: \"\\\\e60a\";\n}\n\n.tdicon-td_logo:before {\n\tcontent: \"\\\\e60b\";\n}\n\n.tdicon-heart:before {\n\tcontent: \"\\\\f004\";\n}\n\n.tdicon-angle-double-left:before {\n\tcontent: \"\\\\f100\";\n}\n\n.tdicon-angle-double-right:before {\n\tcontent: \"\\\\f101\";\n}\n\n.tdicon-circle-o-notch:before {\n\tcontent: \"\\\\f1ce\";\n}\n\n.tdicon-pause-circle-fill:before {\n\tcontent: \"\\\\e600\";\n}\n\n.tdicon-pause-circle-outline:before {\n\tcontent: \"\\\\e601\";\n}\n\n.tdicon-play-circle-fill:before {\n\tcontent: \"\\\\e602\";\n}\n\n.tdicon-play-circle-outline:before {\n\tcontent: \"\\\\e603\";\n}\n\n.tdicon-skip-next:before {\n\tcontent: \"\\\\e604\";\n}\n\n.tdicon-skip-previous:before {\n\tcontent: \"\\\\e605\";\n}\n\n.tdicon-volume-down:before {\n\tcontent: \"\\\\e606\";\n}\n\n.tdicon-volume-off:before {\n\tcontent: \"\\\\e607\";\n}\n\n.tdicon-volume-up:before {\n\tcontent: \"\\\\e608\";\n}\n\n.tdicon-repeat:before {\n\tcontent: \"\\\\e609\";\n}\n\n.tdicon-soundcloud:before {\n\tcontent: \"\\\\e60c\";\n}\n\n.tdicon-file-download:before {\n\tcontent: \"\\\\e60e\";\n}\n\n.tdicon-warning:before {\n\tcontent: \"\\\\e60d\";\n}\n", ""]);

	// exports


/***/ },
/* 5 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}

	function createLinkElement() {
		var linkElement = document.createElement("link");
		var head = getHeadElement();
		linkElement.rel = "stylesheet";
		head.appendChild(linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement();
			update = updateLink.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(8);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./player.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./player.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports


	// module
	exports.push([module.id, ".td.player {\n  font-family: \"HelveticaNeue-Light\", \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif;\n  position: relative;\n  transition: all 0.5s;\n  -webkit-transition: all 0.5s;\n    -moz-transition: all 0.5s;\n  min-width: 250px;  \n  border: 1px solid;\n  box-sizing: border-box;\n    -webkit-animation: fadeIn 0.5s; /* Safari and Chrome */\n     -moz-animation: fadeIn 0.5s; /* Firefox */\n      -ms-animation: fadeIn 0.5s; /* Internet Explorer */\n       -o-animation: fadeIn 0.5s; /* Opera */\n          animation: fadeIn 0.5s;\n}\n\n.td.player div,.td.player ul {\n  -moz-box-sizing: border-box;\n   -webkit-box-sizing: border-box; \n  box-sizing: border-box;\n  line-height: normal;\n}\n\n.td.player .controls, .td.player .buttons{\n  width: 100%;\n}\n\n.td.player .controls div {\ndisplay: inline-block;\ntext-align: center;\n}\n\n.td.player .controls i {\n  cursor: pointer;\n}\n\n.td.player .tdempty{\nmargin: 50px auto;\ntext-align: center;\nfont-size: 14px;\nopacity: 0.4;\n}\n\n.td.player .tdicon-td_logo-link {\n  position: absolute;\n  top: 0;\n  right: 0;\n  height: 16px;\n  width: 16px;\n  margin: 10px;\n  display: block;\n  z-index: 999;\n  opacity: 0.2;\n  -webkit-transition: opacity 300ms ease-out;\n  -moz-transition: opacity 300ms ease-out;\n  transition: opacity 300ms ease-out;\n  color: #222;\n}\n\n.td.player .tdicon-td_logo-link:hover {\n  opacity: 1;\n}\n\n.td.player .tdicon-td_logo {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  right: 0;\n  top:0;\n  font-size: 12px;\n  color: #222;\n}\n\n.td.player .header {\n  height: 100%;\n  text-align: center;\n  position: relative;\n}\n\n.td.player .cover {\n  height: 100%;\n  display: table;\n  z-index: 1;\n}\n\n.td.player .cover .cover-img {\n  display: table-cell;\n  vertical-align: middle;\n  -webkit-animation: fadeIn 1s; /* Safari and Chrome */\n     -moz-animation: fadeIn 1s; /* Firefox */\n      -ms-animation: fadeIn 1s; /* Internet Explorer */\n       -o-animation: fadeIn 1s; /* Opera */\n          animation: fadeIn 1s;\n}\n\n.td.player .cover .cover-img img {\n  max-height: 125px;\n  border-radius: 100%;\n  margin: 20px 0px;\n  -webkit-animation: fadeIn 1s; /* Safari and Chrome */\n     -moz-animation: fadeIn 1s; /* Firefox */\n      -ms-animation: fadeIn 1s; /* Internet Explorer */\n       -o-animation: fadeIn 1s; /* Opera */\n          animation: fadeIn 1s;\n}\n\n.td.player .waveform {\n  position: absolute;\n  left:0;\n  right:0;\n}\n\n.td.player .info {\n  border-bottom: 1px solid;\n  font-weight: bold;\n  padding: 5px 45px;\n  font-size: 14px;\n}\n\n.td.player .info a {\n  text-decoration: none;\n}\n\n.td.player .song-name {\n  margin: 10px 0px 0px;\n  text-align: center;\n  font-size:14px;\n  font-weight: normal;\n  -webkit-animation: fadeInRight 1s; /* Safari and Chrome */\n     -moz-animation: fadeInRight 1s; /* Firefox */\n      -ms-animation: fadeInRight 1s; /* Internet Explorer */\n       -o-animation: fadeInRight 1s; /* Opera */\n          animation: fadeInRight 1s;\n}\n\n.td.player .artist-name {\n  margin: 10px 0px;\n  text-align: center;\n  -webkit-animation: fadeInRight 1s; /* Safari and Chrome */\n     -moz-animation: fadeInRight 1s; /* Firefox */\n      -ms-animation: fadeInRight 1s; /* Internet Explorer */\n       -o-animation: fadeInRight 1s; /* Opera */\n          animation: fadeInRight 1s;\n}\n\n.td.player .soundcloud-icon {\n  height: 14px;\n  width: 16px;\n  background-size: 16px;\n  vertical-align: top;\n  margin-right: 5px;\n  -webkit-animation: fadeIn 0.5s; /* Safari and Chrome */\n     -moz-animation: fadeIn 0.5s; /* Firefox */\n      -ms-animation: fadeIn 0.5s; /* Internet Explorer */\n       -o-animation: fadeIn 0.5s; /* Opera */\n          animation: fadeIn 0.5s;\n}\n\n.td.player .follow-link {\n  border-right: 1px solid;\n}\n\n.td.player .buy-link {\n  border-left: 1px solid;\n}\n\n.td.player .follow-link img {\n  height: 16px;\n  margin-right: 10px;\n  vertical-align: middle;\n}\n\n.td.player .follow-link,.td.player .buy-link {\n  letter-spacing: 2px;\n  font-weight: 400;\n  font-size: 12px;\n  background: none;\n}\n\n.td.player .current-song-info {\n  font-weight: 300;\n  font-size: 12px;\n  text-align: center;\n  padding-top: 1rem;\n  padding-bottom: 1.0625rem;\n}\n\n.td.player .current-song-social-icon {\n  font-size: 12px;\n}\n\n.td.player .controls {\n  padding: 10px;\n  border-top: 1px solid;\n  border-bottom: 1px solid;\n}\n\n.td.player .player-prev {\n  font-size: 36px;\n  line-height: 50px !important;\n  vertical-align: top;\n  opacity: 0.8;\n  transition: all 0.2s;\n  -webkit-transition: all 0.2s;\n    -moz-transition: all 0.2s;  \n}\n\n.td.player .player-prev:hover {\n  opacity: 1; \n  -webkit-transform: translateX(-5px);\n    transform: translateX(-5px);\n}\n\n.td.player .player-play {\n  width: 50%;\n  line-height:50px !important;\n}\n\n.td.player .tdicon-play-circle-outline {\n  font-size: 42px;\n  opacity: 0.8;\n  transition: all 0.2s;\n  -webkit-transition: all 0.2s;\n    -moz-transition: all 0.2s;\n}\n\n.td.player .tdicon-play-circle-outline:hover {\n  opacity: 1;\n  font-size: 48px;\n}\n\n.td.player .tdicon-pause-circle-outline {\n  font-size: 42px;\n  opacity: 0.8;\n  transition: all 0.2s;\n  -webkit-transition: all 0.2s;\n    -moz-transition: all 0.2s;\n}\n\n.td.player .tdicon-pause-circle-outline:hover {\n    opacity: 1;\n    font-size: 48px;\n}\n\n.td.player .player-next {\n  font-size: 36px;\n  line-height: 50px !important;\n  vertical-align: top;\n  opacity: 0.8;\n  transition: all 0.2s;\n  -webkit-transition: all 0.2s;\n    -moz-transition: all 0.2s;  \n}\n\n.td.player .player-next:hover {\n  opacity: 1;\n  -webkit-transform: translateX(5px);\n    transform: translateX(5px);\n}\n\n.td.player .repeat-init {\n  line-height: 50px;\n  font-size: 18px;\n  opacity: 0.4;\n}\n\n.td.player .repeat-init.repeat-on {\n  opacity: 1 !important;\n}\n\n.td.player .volume-controls {\n  text-align: center;\n}\n\n.td.player .volume-init {\n  line-height: 50px;\n  font-size: 16px;\n  opacity: 0.4;\n}\n\n.td.player .volume-init:hover {\n  opacity: 1;\n}\n\n.td.player .volume-select i{\n  line-height: 50px;\n  margin: 0px 10px;\n  font-size: 16px;\n  opacity: 0.4;\n  transition: all 0.2s;\n  -webkit-transition: all 0.2s;\n    -moz-transition: all 0.2s;  \n}\n\n.td.player .volume-select i:hover {\n  opacity: 1;\n}\n\n.td.player .volume-select i.volume-active {\n  opacity: 1;\n}\n\n.td.player .scrubber {\n  line-height: 50px;\n  text-align: center;\n  padding: 0px 10px;\n  border-bottom: 1px solid;\n  -webkit-animation: fadeIn 1s; /* Safari and Chrome */\n     -moz-animation: fadeIn 1s; /* Firefox */\n      -ms-animation: fadeIn 1s; /* Internet Explorer */\n       -o-animation: fadeIn 1s; /* Opera */\n          animation: fadeIn 1s;\n}\n\n.td.player .scrubber-box {\n  display: inline-block;\n  line-height: 50px;\n}\n\n.td.player .scrub-bar-box {\n  display: table;\n  padding: 24px 0px;\n}\n\n.td.player .track-error-box {\n  display: table;\n  padding: 18px 0;\n  text-align: center;\n  font-size: 12px;\n  border-bottom: 1px solid;\n}\n\n.td.player .track-error-box-span {\n  opacity: 0.4;\n}\n\n.td.player .scrub-bar {\n  display: table-cell;\n  vertical-align: middle;\n  line-height: 50px;\n  height: 5px;\n  border-radius: 20px;\n  width: 100%;\n  margin-bottom: 3px;\n  border: 1px solid;\n}\n\n.td.player .start-time,.td.player .stop-time {\n  font-size: 12px;\n  text-align: center;\n  line-height: 50px;\n}\n\n.td.player .playlist-social-icon {\n  font-size: 14px;\n}\n\n.td.player .title {\n  border-left: 1px solid;\n  margin-left: 40px;\n  height: 40px;\n}\n\n.td.player .track-info-social {\n  font-weight: 300;\n}\n\n.td.player .track-user, .track-title {\n  font-size: 12px;\n  display: inline-block;\n  margin: 14px 10px;\n}\n\n.td.player .track-title {\n  font-weight: bold;\n}\n\n.td.player .playlist {\n  font-size: 12px;\n  max-height: 150px;\n  overflow-y: scroll;\n  overflow-x: hidden;\n}\n\n.td.player .playlist-table {\n  width: 100%;\n}\n\n.td.player .playlist-table tr {\n  cursor: pointer;\n  opacity: 0.5;\n}\n\n.td.player .playlist-table tbody tr:hover {\n  cursor: pointer;\n  opacity: 1;\n  border-bottom: 1px solid;\n}\n\n.td.player .current-play-icon {\n  font-size: 14px;\n}\n\n.td.player .playlist-table {\n  border-spacing: 0px;\n  border:0;\n}\n\n.td.player .playlist-table tbody tr.playing {\n  opacity: 1;\n}\n\n.td.player .playlist-table tbody tr td {\n  border-right:0px;\n  border-left:0px;\n  border-top:0px;\n  border-bottom: 1px solid;\n  font-size: 12px;\n}\n\n/*Slider*/\n.td.player .slider {\n  width: 100%;\n  display:table-cell;\n  vertical-align: middle;\n  line-height: 50px;\n}\n\n.td.player .slider > .dragger {\n  -webkit-border-radius: 10px;\n  -moz-border-radius: 10px;\n  border-radius: 10px;\n  width: 10px;\n  height: 10px;\n}\n\n.td.player .slider > .track, .td.player .slider > .highlight-track {\n  -webkit-border-radius: 8px;\n  -moz-border-radius: 8px;\n  border-radius: 8px;\n  height: 6px;\n  border: 1px solid;\n}\n\n/*Equalizer*/\n.td.player svg {\n  font: 10px sans-serif;\n}\n\n.td.player .axis path,\n.td.player .axis line {\n  fill: none;\n  shape-rendering: crispEdges;\n}\n\n/*General*/\n\n.tdrow {\n  width: 100%;\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 0;\n  margin-bottom: 0;\n  max-width: 62.5em;\n  *zoom: 1; }\n  .tdrow:before, .tdrow:after {\n    content: \" \";\n    display: table; }\n  .tdrow:after {\n    clear: both; }\n  .tdrow.collapse > .tdcolumn,\n  .tdrow.collapse > .tdcolumns {\n    padding-left: 0;\n    padding-right: 0; }\n  .tdrow.collapse .tdrow {\n    margin-left: 0;\n    margin-right: 0; }\n  .tdrow .tdrow {\n    width: auto;\n    margin-top: 0;\n    margin-bottom: 0;\n    max-width: none;\n    *zoom: 1; }\n    .tdrow .tdrow:before, .tdrow .tdrow:after {\n      content: \" \";\n      display: table; }\n    .tdrow .tdrow:after {\n      clear: both; }\n    .tdrow .tdrow.collapse {\n      width: auto;\n      margin: 0;\n      max-width: none;\n      *zoom: 1; }\n      .tdrow .tdrow.collapse:before, .tdrow .tdrow.collapse:after {\n        content: \" \";\n        display: table; }\n      .tdrow .tdrow.collapse:after {\n        clear: both; }\n\n.tdcolumn,\n.tdcolumns {\n  width: 100%;\n  float: left; }\n\n .left {\n  float: left !important; }\n\n.right {\n  float: right !important; }\n\n/*Single Player*/\n.td.player.solo {\n  min-width: 185px;\n}\n\n.td.player.solo .tdicon-td_logo-link {\n  left:0;\n  right: inherit;\n}\n\n.td.player.solo .soundcloud-icon {\n  height: 10px;\n  width: 12px;\n  background-size: 12px;\n}\n\n.td.player.solo .cover {\n  position: relative;\n  z-index: inherit;\n  height: 118px;\n  display: block;\n}\n\n.td.player.solo .controls {\n  border-top: 0px;\n  border-bottom: 0px;\n  position: absolute;\n  left: 0;\n  width: 100%;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  margin: auto;\n  padding: 0px;\n  z-index: 100;\n}\n\n.td.player.solo .solo-cover{\n  -webkit-animation: fadeIn 1s; /* Safari and Chrome */\n     -moz-animation: fadeIn 1s; /* Firefox */\n      -ms-animation: fadeIn 1s; /* Internet Explorer */\n       -o-animation: fadeIn 1s; /* Opera */\n          animation: fadeIn 1s;\n}\n\n.td.player.solo .solo-cover img {\n  max-height: 95px;\n  border-radius: 100%;\n  vertical-align: initial;\n  margin: 10px 0px;\n  -webkit-animation: fadeIn 1s; /* Safari and Chrome */\n     -moz-animation: fadeIn 1s; /* Firefox */\n      -ms-animation: fadeIn 1s; /* Internet Explorer */\n       -o-animation: fadeIn 1s; /* Opera */\n          animation: fadeIn 1s;\n}\n\n.td.player.solo .info-solo {\n  border-left:1px solid;\n  position: relative;\n}\n\n.td.player.solo .scrubber {\n  border-left: 1px solid;\n  padding: 0px;\n  line-height: 55px;\n}\n\n.td.player.solo .scrubber-box {\n  border-top: 1px solid;\n}\n\n.td.player.solo .scrub-bar-box {\n  height: 55px;\n}\n\n.td.player.solo .solo-buttons {\n  border-top: 1px solid;\n}\n\n.td.player.solo .info{\n  border-bottom: 0px;\n  position: relative;\n  padding: 6px 10px;\n}\n\n.td.player.solo .buttons {\n  margin: 35px 0px;\n  height: inherit;\n  padding: 0px;\n  width: inherit;\n  display: table;\n}\n\n.td.player.solo .buttons i {\n  display: table-cell;\n  vertical-align: middle;\n}\n\n.td.player.solo .tdicon-play-circle-outline {\n  font-size: 55px;\n  color: white;\n  text-shadow: 0px 0px 5px #4E4E4E;\n}\n\n.td.player.solo .tdicon-pause-circle-outline {\n  font-size: 55px;\n  color: white;\n  text-shadow: 0px 0px 5px #4E4E4E;\n}\n\n.td.player.solo .buy-link, \n.td.player.solo .follow-link {\n  font-size: 10px;\n  border: 0px;\n}\n\n.td.player.solo .song-name, \n.td.player.solo .artist-name, \n.td.player.solo .current-song-info {\n  font-size: 12px;\n}\n\n.td.player.solo .artist-name {\n  margin: 5px 0px;\n}\n\n.td.player.solo .song-name {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.td.player.solo .current-song-info {\n  font-size: 10px;\n}\n\n.td.player.solo .current-song-social-icon {\n  font-size: 10px;\n}\n\n.td.player.solo .repeat-column {\n  text-align: center;\n}\n\n.td.player.solo .repeat-init {\n  margin: 5px 5px;\n  font-size: 14px;\n  opacity: 0.4;\n  cursor: pointer;\n}\n\n.td.player.solo .volume-controls {\n  text-align: center;\n  position: relative;\n}\n\n.td.player.solo .volume-init {\n  margin: 5px;\n  font-size: 14px;\n  cursor: pointer;\n  opacity: 0.4;\n}\n\n.td.player.solo .volume-init:hover {\n  opacity: 1;\n}\n\n.td.player.solo .volume-select {\n  position: absolute;\n}\n\n.td.player.solo .volume-select i{\n  cursor: pointer;\n  display: inline-block;\n  margin: 5px;\n  font-size: 14px;\n  opacity: 0.4;\n  transition: all 0.2s;\n  -webkit-transition: all 0.2s;\n    -moz-transition: all 0.2s;  \n}\n\n.td.player.solo .volume-select i:hover {\n  opacity: 1;\n}\n\n.td.player.solo .volume-select i.volume-active {\n  opacity: 1;\n}\n\n.td.player.solo .start-time, \n.td.player.solo .stop-time {\n  height: 55px;\n  line-height: 55px;\n}\n\n.td.player.solo .stop-time {\n  display: table;\n}\n\n.td.player.solo .stop-time i{\n  display: table-cell;\n  vertical-align: middle;\n}\n\n.td.player.solo .track-error-box {\n  display: table;\n  padding: 20px 0;\n  text-align: center;\n  font-size: 12px;\n  border-bottom: 1px solid;\n  border-top: 1px solid;\n  border-left: 1px solid;\n}\n\n.td.player.solo .track-error-box-span {\n  opacity: 0.4;\n}\n\n/*Mini*/\n.td.player.mini {\n  position: absolute;\n  width: 100%;\n  height:60px;\n}\n\n.td.player.mini.tdrow {\n  max-width: 100%;\n}\n\n.td.player.mini div {\n  display: inline-block;\n}\n\n.td.player.mini .cover {\n  max-height: 32px;\n  vertical-align: middle;\n  z-index: 1;\n  border-radius: 50px;\n}\n\n.td.player.mini .controls, .td.player.mini .buttons{\n  width: initial;\n}\n\n.td.player.mini .mini-controls {\n  line-height: 60px;\n  text-align: center;\n  padding:0px;\n  border-top: 0px;\n  border-bottom: 0px;\n}\n\n.td.player.mini .mini-buttons {\n  padding: 0px;\n}\n\n.td.player.mini .player-prev {\n  font-size: 21px;\n  margin: 0px 10px;\n  line-height: 60px !important;\n}\n\n.td.player.mini .player-play {\n  font-size: 32px;\n  width:initial;\n  line-height: 60px !important;\n}\n\n.td.player.mini .player-play:hover {\n  font-size: 38px;\n}\n\n.td.player.mini .tdicon-pause-circle-outline {\n  font-size: 22px;\n}\n\n.td.player.mini .tdicon-pause-circle-outline:hover {\n  font-size: 28px;\n}\n\n.td.player.mini .player-next {\n  font-size: 21px;\n  margin: 0px 10px;\n  line-height: 60px !important;\n}\n\n.td.player.mini .mini-info {\n  font-size: 12px;\n  display: table;\n  height: 100%;\n  box-sizing: border-box;\n  border-left: 1px solid;\n}\n\n.td.player.mini .song-name {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  margin-top: 0px;\n  font-size: 12px;\n}\n\n.td.player.mini .artist-name {\n  margin: 0px;\n  font-weight: bold;\n}\n\n.td.player.mini .mini-social {\n  list-style: none;\n  list-style-type: none;\n  font-size:12px;\n  text-align: center;\n  box-sizing: border-box;\n  border-left: 1px solid;\n}\n\n.td.player.mini .mini-scrubber {\n  padding: 0px 24px;\n  height: 100%;\n  border-left: 1px solid;\n  box-sizing: border-box;\n}\n\n.td.player.mini .scrubber-box {\n  padding:0px;  \n}\n\n.td.player.mini .scrub-bar-box {\n  padding:25px 0px;  \n}\n\n.td.player.mini .mini-song-info {\n  display: inline-block;\n  display: table-cell;\n  vertical-align: middle;\n  float: none;\n  text-align: center;\n}\n\n.td.player.mini .start-time, \n.td.player.mini .stop-time {\n  line-height: 60px;\n}\n\n.td.player.mini .slider {\n  padding-top: 10px;\n}\n\n.td.player.mini ul {\n  padding: 0px;\n  margin: 0px;\n  height: 100%;\n  display: table;\n}\n\n.td.player.mini li {\n  margin: 0px 10px;\n  display: table-cell;\n  vertical-align: middle;\n  height: 100%;\n}\n\n.td.player.mini .slider {\n  vertical-align: top;\n}\n\n.td.player.mini .mini-connect {\n  padding: 0px;\n}\n\n.td.player.mini .follow-link, .td.player.mini .buy-link {\n  line-height: 58px;\n  padding-top: 0px;\n  padding-bottom: 0px;\n  border:0px;\n  border-left:1px solid;\n  border-right: 0px;\n  box-sizing: border-box;\n  font-size: 10px;\n  letter-spacing: 1px;\n  margin-bottom: 0px;\n}\n\n.td.player.mini .soundcloud-icon {\n  vertical-align: inherit;\n}\n\n.td.player.mini .tdspinner {\n  margin: 15px auto;\n  position: absolute;\n  left: 0;\n  right: 0;\n}\n\n.td.player.mini .track-error-box {\n  display: table;\n  padding: 22px 0;\n  text-align: center;\n  font-size: 12px;\n  border-bottom: 0px;\n  border-top: 0px;\n  border-left: 1px solid;\n}\n\n.td.player.mini .track-error-box-span {\n  opacity: 0.4;\n}\n\n/*Feed*/\n.td.player.feed .header {\n  left: 0;\n  height: auto;\n}\n\n.td.player.feed .song-name {\n  font-size: 14px;\n  margin-top: 0px;\n}\n\n.td.player.feed .artist-name {\n  font-size: 12px;\n  font-weight: normal;\n}\n\n.td.player.feed .cover {\n  position: relative;\n  z-index: inherit;\n  height: inherit;\n  display: block;\n}\n\n.td.player.feed .controls {\n  border-top: 0px;\n  border-bottom: 0px;\n  position: absolute;\n  left: 0;\n  width: 100%;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  margin: auto;\n  padding: 0px;\n  z-index: 100;\n}\n\n.td.player.info-feed {\n  margin-bottom: 5px;\n}\n\n.td.player.feed .feed-cover{\n  -webkit-animation: fadeIn 1s; /* Safari and Chrome */\n     -moz-animation: fadeIn 1s; /* Firefox */\n      -ms-animation: fadeIn 1s; /* Internet Explorer */\n       -o-animation: fadeIn 1s; /* Opera */\n          animation: fadeIn 1s;\n}\n\n.td.player.feed .feed-cover img {\n  max-height: 80px;\n  vertical-align: initial;\n  border-radius: 3px;\n  -webkit-animation: fadeIn 1s; /* Safari and Chrome */\n     -moz-animation: fadeIn 1s; /* Firefox */\n      -ms-animation: fadeIn 1s; /* Internet Explorer */\n       -o-animation: fadeIn 1s; /* Opera */\n          animation: fadeIn 1s;\n}\n\n.td.player.feed .buttons {\n  display: table-cell;\n  vertical-align: middle;\n  padding:0px;\n}\n\n.td.player.feed .tdicon-play-circle-outline {\n  font-size: 55px;\n  color: white;\n  text-shadow: 0px 0px 5px #4E4E4E;\n}\n\n.td.player.feed .tdicon-pause-circle-outline {\n  font-size: 55px;\n  color: white;\n  text-shadow: 0px 0px 5px #4E4E4E;\n}\n\n.td.player.feed .current-song-info {\n  padding: 0;\n  text-align: left;\n}\n\n.td.player.feed .buy-link, .td.player.feed .follow-link {\n  text-align: right;\n  padding: 0;\n}\n\n.td.player.feed .player-play {\n  width: 100%;\n  line-height: 80px !important;\n}\n\n.td.player.feed .tdicon-play-circle-outline {\n  font-size: 42px;\n}\n\n.td.player.feed .tdicon-pause-circle-outline {\n  font-size: 42px;\n}\n\n.td.player.feed .info {\n  border-bottom: 0px;\n  text-align: left;\n  padding: 0px;\n}\n\n.td.player.feed .tdbutton {\n  border: 0;\n  opacity: 0.3;\n  -webkit-animation: fadeIn 1s; /* Safari and Chrome */\n     -moz-animation: fadeIn 1s; /* Firefox */\n      -ms-animation: fadeIn 1s; /* Internet Explorer */\n       -o-animation: fadeIn 1s; /* Opera */\n          animation: fadeIn 1s;\n}\n\n.td.player.feed .tdbutton:hover {\n  opacity: 1;\n}\n\n.td.player.feed .song-name, .td.player.feed .artist-name {\n  text-align: left;\n}\n\n.td.player.feed .scrubber {\n  border-bottom:0px;\n}\n\n.td.player.feed .feed-container {\n  border-left: 0px;\n}\n\n.td.player.feed .tdspinner{\n  max-height: 80px;\n  margin: 30px auto;\n}\n\n.td.player.feed .start-time, .td.player.feed .stop-time {\n  line-height: 40px;\n}\n\n.td.player.feed .scrub-bar-box {\n  padding: 20px 0px;\n}\n\n.td.player.feed .track-error-box {\n  display: table;\n  padding: 15px 0;\n  text-align: center;\n  font-size: 12px;\n  border: 0 none;\n}\n\n.td.player.feed .track-error-box-span {\n  opacity: 0.4;\n}\n\n.td.player.feed .playlist-social-icon {\n  font-size: 14px;\n}\n\n/*Container Responsiveness*/\n.td.player .follow-small, \n.td.player .buy-small {\n  width: 100%;\n}\n\n.td.player .follow-small .follow-link { \n  border-right: 0px !important;\n  border-top: 1px solid;\n}\n\n.td.player .buy-small .buy-link {\n  border-left: 0px !important;\n  border-top: 1px solid;\n}\n\n.td.player.solo .solo-container-small {\n  border-bottom: 1px solid;\n}\n\n.td.player.shrink .cover .cover-img img {\n  max-height: 80px;\n  margin: 10px 0px;\n}\n\n.td.player.shrink .info {\n  font-size: 12px;\n  padding: 0px 45px;\n}\n\n.td.player.shrink .song-name {\n  font-size: 12px;\n}\n\n.td.player.shrink .artist-name {\n  margin: 5px 0;\n}\n\n.td.player.shrink .tdbutton {\n  padding-top: 10px;\n  padding-bottom: 10px;\n}\n\n.td.player.shrink .buy-link, .td.player.shrink .follow-link {\n  font-size: 10px;\n}\n\n.td.player.shrink .soundcloud-icon {\n  height: 12px;\n  width: 14px;\n  background-size: 14px;\n}\n\n.td.player.shrink .current-song-info {\n  font-size: 10px;\n  padding-top: 10px;\n  padding-bottom: 10px;\n}\n\n.td.player.shrink .controls {\n  padding:0px;\n}\n\n.td.player .player-prev,\n.td.player .player-next{\n  font-size: 24px;\n}\n\n.td.player.shrink .tdicon-play-circle-outline{\n  font-size: 32px;\n}\n\n.td.player.shrink .tdicon-pause-circle-outline {\n  font-size: 32px;\n}\n\n.td.player.shrink .tdicon-play-circle-outline:hover{\n  font-size: 38px;\n}\n\n.td.player.shrink .tdicon-pause-circle-outline {\n  font-size: 38px;\n}\n\n.td.player.shrink .scrubber {\n  line-height: 40px;\n  padding:0px 10px;\n}\n\n.td.player.shrink .stop-time, .td.player.shrink .start-time {\n  font-size: 10px;\n}\n\n.td.player.shrink .scrub-bar-box {\n  padding: 25px 0px;\n}\n\n.td.player.shrink .playlist {\n  font-size: 12px;\n  max-height: 75px;\n}\n\n.td.player.shrink .playlist-table tbody tr td {\n  font-size: 10px;\n  padding: 5px 10px;\n}\n\n.td.player.shrink .current-play-icon {\n  font-size: 12px;\n}\n\n.td.player.shrink .playlist-social-icon {\n  font-size: 10px;\n}\n\n.td.player.shrink .track-error-box {\n  display: table;\n  padding: 18px 0;\n  text-align: center;\n  font-size: 12px;\n  border: 0px;\n  border-bottom: 1px solid;\n}\n\n/*Misc*/\n\n\n/*Animations*/\n@-webkit-keyframes fadeIn {\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeIn {\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 1;\n  }\n}\n\n@-webkit-keyframes fadeInLeft {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    transform: translateX(-20px);\n  }\n\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    transform: translateX(0);\n  }\n}\n\n@keyframes fadeInLeft {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(-20px);\n    -ms-transform: translateX(-20px);\n    transform: translateX(-20px);\n  }\n\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0);\n  }\n}\n\n.fadeInLeft {\n  -webkit-animation-name: fadeInLeft;\n  animation-name: fadeInLeft;\n}\n\n@-webkit-keyframes fadeInRight {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    transform: translateX(20px);\n  }\n\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    transform: translateX(0);\n  }\n}\n\n@keyframes fadeInRight {\n  0% {\n    opacity: 0;\n    -webkit-transform: translateX(20px);\n    -ms-transform: translateX(20px);\n    transform: translateX(20px);\n  }\n\n  100% {\n    opacity: 1;\n    -webkit-transform: translateX(0);\n    -ms-transform: translateX(0);\n    transform: translateX(0);\n  }\n}\n\n.fadeInRight {\n  -webkit-animation-name: fadeInRight;\n  animation-name: fadeInRight;\n}\n\n@-webkit-keyframes fadeOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    transform: translateY(0);\n  }\n\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(5px);\n    transform: translateY(5px);\n  }\n}\n\n@keyframes fadeOutDown {\n  0% {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n\n  100% {\n    opacity: 0;\n    -webkit-transform: translateY(5px);\n    -ms-transform: translateY(5px);\n    transform: translateY(5px);\n  }\n}\n\n/*Mozilla Fixes*/\n@-moz-document url-prefix() { \n  .td.player .slider {\n    display: block;\n  }\n\n  .td.player .scrub-bar-box {\n    padding: 20px 0px;\n  }\n}\n\n/*Loader*/\n.tdspinner {\n      margin: 50px auto;\n      width: 50px;\n      height: 30px;\n      text-align: center;\n      font-size: 10px;\n    }\n\n    .tdspinner > div {\n      height: 100%;\n      width: 6px;\n      display: inline-block;\n      \n      -webkit-animation: stretchdelay 1.2s infinite ease-in-out;\n      animation: stretchdelay 1.2s infinite ease-in-out;\n    }\n\n    .tdspinner .rect2 {\n      -webkit-animation-delay: -1.1s;\n      animation-delay: -1.1s;\n    }\n\n    .tdspinner .rect3 {\n      -webkit-animation-delay: -1.0s;\n      animation-delay: -1.0s;\n    }\n\n    .tdspinner .rect4 {\n      -webkit-animation-delay: -0.9s;\n      animation-delay: -0.9s;\n    }\n\n    .tdspinner .rect5 {\n      -webkit-animation-delay: -0.8s;\n      animation-delay: -0.8s;\n    }\n\n    @-webkit-keyframes stretchdelay {\n      0%, 40%, 100% { -webkit-transform: scaleY(0.4) }  \n      20% { -webkit-transform: scaleY(1.0) }\n    }\n\n    @keyframes stretchdelay {\n      0%, 40%, 100% { \n        transform: scaleY(0.4);\n        -webkit-transform: scaleY(0.4);\n      } 20% {\n        transform: scaleY(1.0);\n        -webkit-transform: scaleY(1.0);\n      }\n    }\n\n.tdloader {\n  font-size: 12px;\n}\n\n.spin {\n  -webkit-animation: spin 2s infinite linear;\n  animation: spin 2s infinite linear;\n}\n@-webkit-keyframes spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(359deg);\n    transform: rotate(359deg);\n  }\n}\n@keyframes spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(359deg);\n    transform: rotate(359deg);\n  }\n}\n\n@media only screen {\n  .tdcolumn.tdsmall-centered,\n  .tdcolumns.tdsmall-centered {\n    margin-left: auto;\n    margin-right: auto;\n    float: none !important; }\n\n  .tdcolumn.tdsmall-uncentered,\n  .tdcolumns.tdsmall-uncentered {\n    margin-left: 0;\n    margin-right: 0;\n    float: left !important; }\n\n  .tdcolumn.tdsmall-uncentered.opposite,\n  .tdcolumns.tdsmall-uncentered.opposite {\n    float: right; }\n\n  .tdsmall-1 {\n    width: 8.33333%; }\n\n  .tdsmall-2 {\n    width: 16.66667%; }\n\n  .tdsmall-3 {\n    width: 25%; }\n\n  .tdsmall-4 {\n    width: 33.33333%; }\n\n  .tdsmall-5 {\n    width: 41.66667%; }\n\n  .tdsmall-6 {\n    width: 50%; }\n\n  .tdsmall-7 {\n    width: 58.33333%; }\n\n  .tdsmall-8 {\n    width: 66.66667%; }\n\n  .tdsmall-9 {\n    width: 75%; }\n\n  .tdsmall-10 {\n    width: 83.33333%; }\n\n  .tdsmall-11 {\n    width: 91.66667%; }\n\n  .tdsmall-12 {\n    width: 100%; }\n\n  [class*=\"tdcolumn\"] + [class*=\"tdcolumn\"]:last-child {\n    float: right; }\n\n  [class*=\"tdcolumn\"] + [class*=\"tdcolumn\"].end {\n    float: left; }\n\n.tdbutton {\n  border-style: solid;\n  border-width: 0px;\n  cursor: pointer;\n  line-height: normal;\n  position: relative;\n  text-decoration: none;\n  text-align: center;\n  display: inline-block;\n  padding-top: 1rem;\n  padding-right: 2rem;\n  padding-bottom: 1.0625rem;\n  padding-left: 2rem;\n  /*     @else                            { font-size: $padding - rem-calc(2); } */\n  color: #000;\n  -webkit-transition: background-color 300ms ease-out;\n  -moz-transition: background-color 300ms ease-out;\n  transition: background-color 300ms ease-out;\n  padding-top: 1rem;\n  padding-right: 2rem;\n  padding-bottom: 1.0625rem;\n  padding-left: 2rem;\n  /*     @else                            { font-size: $padding - rem-calc(2); } */ }\n  .tdbutton:hover, .tdbutton:focus {\n    /*background-color: #2285a2;*/ }\n  .tdbutton:hover, .tdbutton:focus {\n    /*color: white; */}\n  .tdbutton.tdlarge {\n    padding-top: 1.125rem;\n    padding-right: 2.25rem;\n    padding-bottom: 1.1875rem;\n    padding-left: 2.25rem;\n    font-size: 1.25rem;\n    /*     @else                            { font-size: $padding - rem-calc(2); } */ }\n  .tdbutton.tdsmall {\n    padding-top: 0.875rem;\n    padding-right: 1.75rem;\n    padding-bottom: 0.9375rem;\n    padding-left: 1.75rem;\n    font-size: 0.8125rem;\n    /*     @else                            { font-size: $padding - rem-calc(2); } */ }\n  .tdbutton.expand {\n    padding-right: 0;\n    padding-left: 0;\n    width: 100%; }\n}\n\n.td.player table {\n  background:none;\n  margin: 0px;\n  padding:0px;\n}\n  .td.player table thead,\n  .td.player table tfoot {\n    background:none;\n    margin: 0px;\n    padding:0px;\n    }\n    .td.player table thead tr th,\n    .td.player table thead tr td,\n    .td.player table tfoot tr th,\n    .td.player table tfoot tr td {\n      padding: 0.5rem 0.625rem 0.625rem;\n      text-align: left; }\n  .td.player table tr th,\n  .td.player table tr td {\n    padding: 0.5625rem 0.625rem;\n    color: inherit; }\n  .td.player table tr.even, .td.player table tr.alt, .td.player table tr:nth-of-type(even) {\n    background: none;\n  }\n  .td.player table thead tr th,\n  .td.player table tfoot tr th,\n  .td.player table tbody tr td,\n  .td.player table tr td,\n  .td.player table tfoot tr td {\n    display: table-cell;\n    line-height: 1.125rem; \n  }\n\n@media only screen and (min-width: 64.063em) {\n  .tdcolumn.tdlarge-centered,\n  .tdcolumns.tdlarge-centered {\n    margin-left: auto;\n    margin-right: auto;\n    float: none !important; }\n\n  .tdcolumn.tdlarge-uncentered,\n  .tdcolumns.tdlarge-uncentered {\n    margin-left: 0;\n    margin-right: 0;\n    float: left !important; }\n\n  .tdcolumn.tdlarge-uncentered.opposite,\n  .tdcolumns.tdlarge-uncentered.opposite {\n    float: right; }\n\n  .tdlarge-1 {\n    width: 8.33333%; }\n\n  .tdlarge-2 {\n    width: 16.66667%; }\n\n  .tdlarge-3 {\n    width: 25%; }\n\n  .tdlarge-4 {\n    width: 33.33333%; }\n\n  .tdlarge-5 {\n    width: 41.66667%; }\n\n  .tdlarge-6 {\n    width: 50%; }\n\n  .tdlarge-7 {\n    width: 58.33333%; }\n\n  .tdlarge-8 {\n    width: 66.66667%; }\n\n  .tdlarge-9 {\n    width: 75%; }\n\n  .tdlarge-10 {\n    width: 83.33333%; }\n\n  .tdlarge-11 {\n    width: 91.66667%; }\n\n  .tdlarge-12 {\n    width: 100%; }\n\n  [class*=\"tdcolumn\"] + [class*=\"tdcolumn\"]:last-child {\n    float: right; }\n\n  [class*=\"tdcolumn\"] + [class*=\"tdcolumn\"].end {\n    float: left; }\n\n}\n\n@media only screen and (max-width: 40em){\n\n  .td.player .track-info-stats {\n    display: none;\n  } \n\n  .td.player .follow, .td.player.buy {\n    display: none;\n  }\n\n  .td.player.mini {\n    height: initial;\n  }\n\n  .td.player.mini .player-play {\n    width: 80px;\n  }\n\n  .td.player.mini .tdspinner {\n    display: none;\n  }\n\n  .td.player.mini .mini-scrubber, .td.player.mini .mini-connect{\n    display: none;\n  }\n\n  .td.player.mini .mini-info, .td.player.mini .mini-social {\n    padding: 10px 0px;\n    border-top:1px solid;\n  }\n\n  .td.player .repeat-init, .td.player .volume-init, .td.player .volume-select {\n    margin: 15px 0px;\n  }\n\n  .td.player.solo .repeat-init, .td.player.solo .volume-init {\n    display: none;\n  }\n}\n", ""]);

	// exports


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(10);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./themes.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./themes.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports


	// module
	exports.push([module.id, "\n.td.player.light {\n  background: rgba(255,255,255,0.8);\n  color: black;\n  border-color: #E4E4E4;\n}\n\n.td.player.dark {\n  background: rgba(0,0,0,0.85);\n  color: white;\n  border-color: #333;\n}\n\n.td.player.aurora {\n    color: white;\n    background: #192F41;\n    border-color: #1B4B4B;\n}\n\n.td.player.mojave {\n    color: white;\n    background: #4F4E70;\n    border-color: #6D6C9A;\n}\n\n.td.player.light div, .td.player.light ul {\n  border-color: #E4E4E4!important;\n}\n\n.td.player.dark div, .td.player.dark ul {\n  border-color: #333 !important;\n}\n\n.td.player.aurora div, .td.player.aurora ul {\n    border-color: #1B4B4B !important;\n}\n\n.td.player.mojave div, .td.player.mojave ul {\n    border-color: #6D6C9A !important;\n}\n\n.td.player.light .waveform path {\n    fill: none;\n    stroke: #000;\n}\n\n.td.player.dark .waveform path {\n    fill: none;\n    stroke: white;\n}\n\n.td.player.aurora .waveform path {\n    fill: none;\n    stroke: #02DDA8;\n}\n\n.td.player.mojave .waveform path {\n    fill: none;\n    stroke: #F58F86;\n}\n\n.td.player.light .info {\n  border-color: #E4E4E4;\n  color: black;\n}\n\n.td.player.dark .info {\n  border-color: #333;\n  color: white;\n}\n\n.td.player.aurora .info {\n  border-color: #1B4B4B;\n  color: white;\n}\n\n.td.player.mojave .info {\n  border-color: #6D6C9A;\n  color: white;\n}\n\n.td.player.light .info a, .td.player.light .mini-song-info a{\n  color: black;\n}\n\n.td.player.dark .info a, .td.player.dark .mini-song-info a{\n  color: white;\n}\n\n.td.player.aurora .info a, .td.player.aurora .mini-song-info a{\n  color: white;\n}\n\n.td.player.mojave .info a, .td.player.mojave .mini-song-info a{\n  color: white;\n}\n\n.td.player.light .icon-td_logo {\n  color: #222;\n}\n\n.td.player.dark .icon-td_logo {\n  color:white;\n}\n\n.td.player.aurora .icon-td_logo {\n  color:white;\n}\n\n.td.player.mojave .icon-td_logo {\n  color:white;\n}\n\n.td.player.light .soundcloud-icon {\n}\n\n.td.player.dark .soundcloud-icon {\n  color:white;\n}\n\n.td.player.aurora .soundcloud-icon {\n  color:white;\n}\n\n.td.player.mojave .soundcloud-icon {\n  color:white;\n}\n\n.td.player.light .follow-link {\n  border-color: #E4E4E4!important;\n  color: #222;\n}\n\n.td.player.dark .follow-link {\n  border-color: #333 !important;\n  color: white;\n}\n\n.td.player.aurora .follow-link {\n  border-color: #1B4B4B !important;\n  color: white;\n}\n\n.td.player.mojave .follow-link {\n  border-color: #6D6C9A !important;\n  color: white;\n}\n\n.td.player.light .buy-link {\n  border-color: #E4E4E4!important;\n  color: #222;\n}\n\n.td.player.dark .buy-link {\n  border-color: #333 !important;\n  color: white;\n}\n\n.td.player.aurora .buy-link {\n  border-color: #1B4B4B !important;\n  color: white;\n}\n\n.td.player.mojave .buy-link {\n  border-color: #6D6C9A !important;\n  color: white;\n}\n\n.td.player.light .follow-link:hover,.td.player.light .buy-link:hover {\n  background: rgba(255,255,255,0.8);\n  color: #000;\n}\n\n.td.player.dark .follow-link:hover,.td.player.dark .buy-link:hover {\n  background: rgba(0,0,0,0.8);\n  color: white;\n}\n\n.td.player.aurora .follow-link:hover,.td.player.aurora .buy-link:hover {\n  background: #122230;\n  color: white;\n}\n\n.td.player.mojave .follow-link:hover,.td.player.mojave .buy-link:hover {\n  background: #44435F;\n  color: white;\n}\n\n.td.player.light .controls {\n  color: #000;\n  border-color: #E4E4E4;\n}\n\n.td.player.dark .controls {\n  color: white;\n  border-color: #333;\n}\n\n.td.player.aurora .controls {\n  color: #02DDA8;\n  border-color: #1B4B4B;\n}\n\n.td.player.mojave .controls {\n  color: #F58F86;\n  border-color: #6D6C9A;\n}\n\n.td.player.light .scrubber {\n  border-color: #E4E4E4;\n}\n\n.td.player.dark .scrubber {\n  border-color: #333;\n}\n\n.td.player.aurora .scrubber {\n  border-color: #1B4B4B;\n}\n\n.td.player.mojave .scrubber {\n  border-color: #6D6C9A;\n}\n\n.td.player.light .scrub-bar {\n  border-color: #E4E4E4;\n}\n\n.td.player.dark .scrub-bar {\n  border-color: #333;\n}\n\n.td.player.aurora .scrub-bar {\n  border-color: #1B4B4B;\n}\n\n.td.player.mojave .scrub-bar {\n  border-color: #6D6C9A;\n}\n\n.td.player.light .title {\n  border-color: #D6D6D6;\n}\n\n.td.player.dark .title {\n  border-color: #333;\n}\n\n.td.player.aurora .title {\n  border-color: #1B4B4B;\n}\n\n.td.player.mojave .title {\n  border-color: #6D6C9A;\n}\n\n.td.player.light .playlist-table tbody tr.playing {\n  color: #000;\n}\n\n.td.player.dark .playlist-table tbody tr.playing {\n  color: white;\n}\n\n.td.player.aurora .playlist-table tbody tr.playing {\n  color: #02DDA8;\n}\n\n.td.player.mojave .playlist-table tbody tr.playing {\n  color: white;\n}\n\n.td.player.light .playlist-table tr {\n  color: #000;\n}\n\n.td.player.dark .playlist-table tr {\n  color: white;\n}\n\n.td.player.aurora .playlist-table tr {\n  color: #02DDA8;\n}\n\n.td.player.mojave .playlist-table tr {\n  color: white;\n}\n\n.td.player.light tbody tr:hover {\n  border-color: rgba(175, 175, 175, 0.5);\n}\n\n.td.player.dark tbody tr:hover {\n  border-color: rgba(175, 175, 175, 0.5);\n}\n\n.td.player.aurora tbody tr:hover {\n  border-color: rgba(175, 175, 175, 0.5);\n}\n\n.td.player.mojave tbody tr:hover {\n  border-color: rgba(175, 175, 175, 0.5);\n}\n\n.td.player.light .playlist-table tbody tr td {\n  border-color: #E4E4E4;\n}\n\n.td.player.dark .playlist-table tbody tr td {\n  border-color: #333;\n}\n\n.td.player.aurora .playlist-table tbody tr td {\n  border-color: #1B4B4B;\n}\n\n.td.player.mojave .playlist-table tbody tr td {\n  border-color: #6D6C9A;\n}\n\n.td.player.light .slider > .dragger {\n  background: #BFC1CC;\n}\n\n.td.player.dark .slider > .dragger {\n  background: #ACACAC;\n}\n\n.td.player.aurora .slider > .dragger {\n  background: #ACACAC;\n}\n\n.td.player.mojave .slider > .dragger {\n  background: #6D6C9A;\n}\n\n.td.player.light .slider > .dragger:hover {\n   background: #000;\n}\n\n.td.player.dark .slider > .dragger:hover {\n   background: white;\n}\n\n.td.player.aurora .slider > .dragger:hover {\n   background: white;\n}\n\n.td.player.mojave .slider > .dragger:hover {\n   background: white;\n}\n\n.td.player.light .slider > .track {\n  background: #f8f8f8;\n  border-color: #E4E4E4;\n}\n\n.td.player.dark .slider > .track {\n   background: #494949;\n  border-color: #333;\n}\n\n.td.player.aurora .slider > .track {\n   background: #254364;\n  border-color: #254364;\n}\n\n.td.player.mojave .slider > .track {\n   background: #254364;\n  border-color: #6D6C9A;\n}\n\n.td.player.light .slider > .highlight-track {\n  border-color: #333;\n  background: #000;\n}\n\n.td.player.dark .slider > .highlight-track  {\n  border-color: #333;\n  background: white;\n}\n\n.td.player.aurora .slider > .highlight-track  {\n  border-color: #02DDA8;\n  background: #02DDA8;\n}\n\n.td.player.mojave .slider > .highlight-track  {\n  border-color: #F58F86;\n  background: #F58F86;\n}\n\n.td.player.light .line {\n  stroke: #000;\n}\n\n.td.player.dark .line {\n  stroke: white;\n}\n\n.td.player.aurora .line {\n  stroke: white;\n}\n\n.td.player.mojave .line {\n  stroke: white;\n}\n\n.td.player.light .axis path, .td.player.light .axis line {\n  stroke: #000;\n}\n\n.td.player.dark .axis path, .td.player.dark .axis line {\n  stroke: white;\n}\n\n.td.player.aurora .axis path, .td.player.aurora .axis line {\n  stroke: white;\n}\n\n.td.player.mojave .axis path, .td.player.mojave .axis line {\n  stroke: white;\n}\n\n.td.player.light svg rect {\n  fill: #000;\n}\n\n.td.player.dark svg rect {\n  fill: white;\n}\n\n.td.player.aurora svg rect {\n  fill: #02DDA8;\n}\n\n.td.player.mojave svg rect {\n  fill: #F58F86;\n}\n\n.td.player.light .follow-small .follow-link {\n  border-color: #E4E4E4!important;\n}\n\n.td.player.dark .follow-small .follow-link {\n  border-color: #333 !important;\n}\n\n.td.player.aurora .follow-small .follow-link {\n  border-color: #1B4B4B !important;\n}\n\n.td.player.mojave .follow-small .follow-link {\n  border-color: #6D6C9A !important;\n}\n\n.td.player.light .buy-small .buy-link {\n  border-color: #E4E4E4!important;\n}\n\n.td.player.dark .buy-small .buy-link {\n  border-color: #333 !important;\n}\n\n.td.player.aurora .buy-small .buy-link {\n  border-color: #1B4B4B !important;\n}\n\n.td.player.mojave .buy-small .buy-link {\n  border-color: #6D6C9A !important;\n}\n\n/*spinner*/\n\n.td.player.light .tdspinner > div {\n  background: #333;\n}\n\n.td.player.dark .tdspinner > div {\n  background: white ;\n}\n\n.td.player.aurora .tdspinner > div {\n  background: white ;\n}\n\n.td.player.mojave .tdspinner > div {\n  background: white;\n}\n\n.td.player.light .tdloader {\n  color: #333;\n}\n\n.td.player.dark .tdloader {\n  color: white ;\n}\n\n.td.player.aurora .tdloader {\n  color: white ;\n}\n\n.td.player.mojave .tdloader {\n  color: white;\n}\n\n.td.player.light .tdempty{\n  color: #333;\n}\n\n.td.player.dark .tdempty{\n  color: white;\n}\n\n.td.player.aurora .tdempty{\n  color: white;\n}\n\n.td.player.mojave .tdempty{\n  color: white;\n}\n", ""]);

	// exports


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var constants = __webpack_require__(12);
	var trackerName = 'ToneDenTracker';

	if(!window.ga) {
	    (function(i, s, o, g, r, a, m){
	      i['GoogleAnalyticsObject'] = r; // Acts as a pointer to support renaming.

	      // Creates an initial ga() function.  The queued commands will be executed once analytics.js loads.
	      i[r] = i[r] || function() {
	        (i[r].q = i[r].q || []).push(arguments)
	      },

	      // Sets the time (as an integer) this tag was executed.  Used for timing hits.
	      i[r].l = 1 * new Date();

	      // Insert the script tag asynchronously.  Inserts above current tag to prevent blocking in
	      // addition to using the async attribute.
	      a = s.createElement(o),
	      m = s.getElementsByTagName(o)[0];
	      a.async = 1;
	      a.src = g;
	      m.parentNode.insertBefore(a, m)
	    })(window, document, 'script', constants.protocol + '//www.google-analytics.com/analytics.js', 'ga');
	}

	if(!ga.getByName || !ga.getByName(trackerName)) {
	    ga('create', 'UA-55279667-1', 'auto', {
	        cookieDomain: 'none',
	        name: trackerName
	    });

	    module.exports = ga;
	} else {
	    module.exports = ga.getByName(trackerName);
	}


/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = {
	    protocol: window.location.protocol === 'file:' ? 'http:' : window.location.protocol
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(14);
	var $ = __webpack_require__(15);
	var d3 = __webpack_require__(16);
	var msToTimestamp = __webpack_require__(17);
	var SimpleSlider = __webpack_require__(26);

	var template = __webpack_require__(27);
	var template_solo = __webpack_require__(30);
	var template_mini = __webpack_require__(31);
	var template_feed = __webpack_require__(32);
	var template_empty = __webpack_require__(33);

	var analytics = __webpack_require__(11);
	var constants = __webpack_require__(12);
	var tdPlayer = __webpack_require__(34);

	module.exports = {
	    create: function(urls, dom, options) {
	        ToneDen.players = ToneDen.players || [];

	        var player;
	        var playerVolume=100;
	        var repeat;
	        var showVisualizer = true;

	        // Default parameters go here.
	        var playerParameters = {
	            debug: false, // Output debug messages?
	            feed: false,
	            keyboardEvents: false, // Should we listen to keyboard events?
	            mini: false,
	            onTrackReady: null,
	            onTrackFinished: null,
	            onPlaylistFinished: null,
	            shrink: true, // Default option to shrink player responsively if container is too small
	            single: null,
	            skin: 'light',
	            staticUrl: constants.protocol + '//sd.toneden.io/',
	            togglePause: true, // Default option to toggle pause/play when clicked
	            tracksPerArtist: 10, // How many tracks to load when given an artist SoundCloud URL.
	            useCustomPurchaseTitle: true,
	            visualizerType: 'waves' // Equalizer type. 'waves' or 'bars'
	        };

	        // Setup the parameters object with the given arguments and
	        // override the default parameters with the given options.
	        if(arguments.length === 1 && typeof arguments[0] === 'object') {
	            _.extend(playerParameters, arguments[0]);
	        } else {
	            playerParameters.urls = urls;
	            playerParameters.dom = dom;

	            delete options.urls;
	            delete options.dom;

	            _.extend(playerParameters, options);

	            // Make sure staticUrl ends in a '/'.
	            if(playerParameters.staticUrl.charAt(playerParameters.staticUrl.length - 1) !== '/') {
	                playerParameters.staticUrl += '/';
	            }
	        }

	        // Visualizer is currently only supported in Chrome.
	        if(navigator.userAgent.toLowerCase().indexOf('chrome') === -1) {
	            showVisualizer = false;
	        }

	        if(playerParameters.visualizerType === 'none') {
	            showVisualizer = false;
	        }

	        // Parameters for the SoundCloud interface.
	        var tdInstanceParameters = {
	            cache: true,
	            cachePrefix: new Date().getTime(),
	            consumerKey: '0e545f4886c0c8006a4f95e2036399c0',
	            debug: playerParameters.debug,
	            onPlaylistPreloaded: onPlaylistPreloaded,
	            preload: true,
	            togglePause: playerParameters.togglePause,
	            tracksPerArtist: playerParameters.tracksPerArtist,
	            visualizer: showVisualizer,
	            onTrackReady: playerParameters.onTrackReady,
	            onTrackFinished: playerParameters.onTrackFinished,
	            onPlaylistFinished: playerParameters.onPlaylistFinished
	        }

	        var dom = playerParameters.dom;
	        var urls = playerParameters.urls;
	        var container = $(dom);
	        var currentRatio = null;
	        var currentTimeIn = null;
	        var bufferPauseThreshold = 5000; // If the track plays within this many milliseconds of the buffer edge, pause and wait.
	        var bufferResumeThreshold = 10000; // Once the buffer is this far past the play progress, it will resume.
	        var trackLoadedPercent = null;
	        var trackLoadedTime = null;
	        var trackPlayedPercent = null;
	        var trackReady = false;
	        var trackSuspend = false;

	        var tdInstance = new tdPlayer(urls, tdInstanceParameters);
	        var titleArea = container.find('.title');

	        // Helper functions.
	        function log(message, level) {
	            // Level can be debug or error.
	            if(window.console) {
	                if(level === 'error') {
	                    console.error(message);
	                } else if(level === 'warning') {
	                    console.warn(message);
	                } else if(playerParameters.debug) {
	                    console.debug(message);
	                }
	            }
	        }

	        // 'this' will refer to tdInstance here.
	        function onPlaylistPreloaded(e) {
	            this.getTracks(function(tracks) {
	                var nowPlaying = this.getTrack();

	                log(tracks);

	                // If parameters.single is not explicitly set to false and
	                // there is only one track, render the single-track player.
	                if(tracks.length === 1 && playerParameters.single !== false && playerParameters.mini == false && playerParameters.feed == false) {
	                   playerParameters.single = true;
	                }

	                container.find('.tdspinner').hide();

	                rerender({
	                    feed: playerParameters.feed,
	                    mini: playerParameters.mini,
	                    nowPlaying: nowPlaying,
	                    shrink: playerParameters.shrink,
	                    single: playerParameters.single,
	                    skin: playerParameters.skin,
	                    tracks: tracks,
	                    tracksPerArtist: playerParameters.tracksPerArtist,
	                    visualizerType: playerParameters.visualizerType
	                });

	                if(this.getSound() && !this.getSound().paused) {
	                    changePlayButton(false);
	                }
	            }.bind(this));
	        }

	        function rerender(parameters) {
	            parameters = JSON.parse(JSON.stringify(parameters));
	            parameters.repeat = tdInstance && tdInstance.config.loopTrack;

	            // Render the empty template if no urls were originally supplied
	            // or if all of the tracks are falsy.
	            var empty = !playerParameters.urls ||
	                !_.any(playerParameters.urls) || 
	                (!_.any(parameters.tracks) && !parameters.loading);

	            if(parameters.nowPlaying) {
	                if(parameters.nowPlaying.purchase_title) {
	                    parameters.nowPlaying.useCustomPurchaseTitle = playerParameters.useCustomPurchaseTitle;
	                }

	                for(var i = 0; i < parameters.tracks.length; i++) {
	                    if(parameters.tracks[i].title === parameters.nowPlaying.title) {
	                        parameters.tracks[i].playing = true;
	                    }
	                }
	            }

	            if(empty) {
	                container.html(template_empty(parameters));
	            } else if(parameters.single === true) {
	                container.html(template_solo(parameters));
	                modifyVolumeUI();

	                if(parameters.tracks.length > 1){
	                    container.find('.prev').show();
	                    container.find('.next').show();
	                } else {
	                    container.find('.prev').hide();
	                    container.find('.next').hide();
	                }

	                //container responsiveness
	                if(container.width() < 400) {
	                    container.find('.header').addClass('header-small').css('width', '100%');
	                    container.find('.solo-container').addClass('solo-container-small').css('width', '100%').prependTo(container.find('.solo-buttons'));
	                    container.find('.scrubber').hide();
	                }
	            } else if(parameters.mini === true) {
	                container.html(template_mini(parameters));
	            } else if(parameters.feed === true) {
	                container.html(template_feed(parameters));
	            } else {
	                container.html(template(parameters));
	                modifyVolumeUI();

	                //container responsiveness
	                if(container.width() < 500) {
	                    container.find('.current-song-info').css('width', '100%').prependTo(container.find('.social'));
	                    container.find('.buy').hide();
	                    container.find('.follow').hide();
	                    container.find('.track-info-stats').hide();
	                }

	                if(container.height() < 500 && parameters.shrink === true) {
	                    container.find('.player').addClass('shrink');
	                }
	            }

	            container.find('.scrubber-slider').simpleSlider({
	                highlight: true
	            });
	        }

	        function drawEQ(data) {
	            if(!data) {
	                var data = [];

	                for(var i = 0; i < 128; i++) {
	                    data.push(0);
	                }
	            }

	            var d3Container = d3.select(container[0]);
	            var chart = d3Container.select('.waveform svg');

	            var n = 128;
	             
	            var margin = {
	                top: 0,
	                right: 0,
	                bottom: 0,
	                left: 0
	            };

	            var width = container.find('.cover').width();
	            var height = container.find('.cover').height();
	            var barWidth = (width - n) / n;
	             
	            var x = d3.scale.linear()
	                .domain([0, n - 1])
	                .range([0, width]);
	             
	            var y = d3.scale.linear()
	                .domain([0, 1.5])
	                .range([0, height]);

	            var line = d3.svg.line()
	                .x(function(d, i) {
	                    return x(i);
	                })
	                .y(function(d, i) {
	                    return height - y(d);
	                })
	                .interpolate('basis');

	            if(!chart.node()) {
	                chart = d3Container.select('.waveform').append('svg:svg')
	                    .attr('width', width + margin.left + margin.right)
	                    .attr('height', height + margin.top + margin.bottom)
	                    .append('g');

	                chart.selectAll('path')
	                    .data([data])
	                    .enter()
	                    .append('svg:path')
	                    .attr('d', line)
	                    .attr('stroke-width', 3);

	                chart.selectAll('rect')
	                    .data(data)
	                    .enter().append('rect')
	                    .attr('x', function(d, i) {
	                        return x(i);
	                    })
	                    .attr('y', function(d) {
	                        return height - y(d);
	                    })
	                    .attr('width', barWidth)
	                    .attr('height', function(d) {
	                        return y(d);
	                    });
	            }

	            function redrawEQ(svg, data) {
	                if(playerParameters.visualizerType === 'waves') {
	                    svg.selectAll('path')
	                        .data([data])
	                        .attr('d', line)
	                        .attr('visibility', 'visible')
	                        .transition()
	                            .ease('linear')
	                            .duration(100);

	                    chart.selectAll('rect')
	                        .attr('visibility', 'hidden');
	                } else if(playerParameters.visualizerType == 'bars') {
	                    chart.selectAll('rect')
	                        .data(data)
	                        .transition()
	                        .duration(100)
	                        .attr('y', function(d) {
	                            return height - y(d);
	                        })
	                        .attr('height', function(d) {
	                            return y(d);
	                        })
	                        .attr('visibility', 'visible');

	                    svg.selectAll('path')
	                        .attr('visibility', 'hidden');
	                }
	            }

	            redrawEQ(chart, data);
	        }

	        //TODO: Refactor
	        function modifyVolumeUI() {
	            if(playerVolume==100) {
	                container.find('.volume-init').removeClass().addClass('tdicon-volume-up volume-init');
	                container.find('.volume-select i.volume-active').removeClass('volume-active');
	                container.find('.volume-select i.volume-max').addClass('volume-active');
	            } else if(playerVolume==0) {
	                container.find('.volume-init').removeClass().addClass('tdicon-volume-off volume-init');
	                container.find('.volume-select i.volume-active').removeClass('volume-active');
	                container.find('.volume-select i.volume-off').addClass('volume-active');
	            } else {
	                container.find('.volume-init').removeClass().addClass('tdicon-volume-down volume-init');
	                container.find('.volume-select i.volume-active').removeClass('volume-active');
	                container.find('.volume-select i.volume-med').addClass('volume-active');
	            }
	        }

	        function changePlayButton(paused) {
	            var playClass = 'tdicon-play-circle-outline';
	            var pauseClass = 'tdicon-pause-circle-outline';
	            var playButton = container.find('.play');

	            if(paused) {
	                playButton.removeClass(pauseClass);
	                playButton.addClass(playClass);
	            } else {
	                playButton.removeClass(playClass);
	                playButton.addClass(pauseClass);
	            }
	        }

	        // Make sure the specified container is valid.
	        if(container.length > 0) {
	            rerender({
	                feed: playerParameters.feed,
	                loading: true,
	                mini: playerParameters.mini,
	                shrink: playerParameters.shrink,
	                single: playerParameters.single,
	                skin: playerParameters.skin,
	                tracks: [],
	                tracksPerArtist: playerParameters.tracksPerArtist,
	                visualizerType: playerParameters.visualizerType
	            });
	        } else {
	            log('ToneDen Player: the container specified by "' + playerParameters.dom + '" does not exist.', 'error');
	            return;
	        }

	        /**
	         * PLAYER DOM EVENT LISTENERS
	         */

	        container.on('click', '.controls', function(e) {
	            e.preventDefault();
	            var target = $(e.target);

	            if(target.hasClass('play')) {
	                tdInstance.pause();
	            } else if(target.hasClass('next')) {
	                tdInstance.next();
	            } else if(target.hasClass('prev')) {
	                if(tdInstance.position() > 4000) {
	                    tdInstance.seek(0);
	                }
	                else {
	                    tdInstance.prev();
	                }
	            }
	        });

	        container.on('click', '.repeat-init', function(e) {
	            e.preventDefault();
	            var target = $(e.target);

	            if(target.hasClass('repeat-on')) {
	                target.removeClass('repeat-on');
	                tdInstance.config.loopTrack = false;
	            } else {
	                target.addClass('repeat-on');
	                tdInstance.config.loopTrack = true;
	            }
	        });

	        container.on('click', '.volume-controls', function(e) {
	            e.preventDefault();
	            var target = $(e.target);
	            var newClass = target.attr('data-class');

	            if(target.hasClass('volume-init')) {
	                container.find('.volume-init').hide();
	                container.find('.volume-select').fadeIn();
	            }else if(target.hasClass('volume-off')) {
	                tdInstance.volume(0);
	                container.find('.volume-select i').removeClass('volume-active');
	                target.addClass('volume-active');
	                container.find('.volume-init').fadeIn().removeClass().addClass(newClass + ' volume-init');
	                container.find('.volume-select').hide();
	                playerVolume = 0;
	            } else if(target.hasClass('volume-med')) {
	                tdInstance.volume(50);
	                container.find('.volume-select i').removeClass('volume-active');
	                target.addClass('volume-active');
	                container.find('.volume-init').fadeIn().removeClass().addClass(newClass + ' volume-init');
	                container.find('.volume-select').hide();
	                playerVolume = 50;
	            } else if(target.hasClass('volume-max')) {
	                tdInstance.volume(100);
	                container.find('.volume-select i').removeClass('volume-active');
	                target.addClass('volume-active');
	                container.find('.volume-init').fadeIn().removeClass().addClass(newClass + ' volume-init');
	                container.find('.volume-select').hide();
	                playerVolume = 50;
	            }
	        });

	        container.on('click', '.track-info', function(e) {
	            var row = $(this);
	            var cls = row.attr('class');
	            var index = Number(row.attr('data-index'));

	            if(cls.indexOf('playing') === -1) {
	                tdInstance.goto(index);
	            }
	        });

	        container.on('slider:changed', '.scrubber-slider', function(e, slider) {
	            tdInstance.play();
	            log('Slider Ratio: ' + slider.ratio);
	            
	            tdInstance.seek(slider.ratio);
	        });

	        // Document-wide listeners.
	        if(playerParameters.keyboardEvents) {
	            document.addEventListener('keydown', function(e) {
	                if (e.keyCode == 32) {
	                    if(tdInstance) {
	                        tdInstance.pause();
	                    }

	                    e.preventDefault();
	                } else if (e.keyCode == 39) {
	                    if(tdInstance) {
	                        tdInstance.next();
	                    }

	                    e.preventDefault();
	                } else if (e.keyCode == 37) {
	                    if(tdInstance) {
	                        tdInstance.prev();
	                    }

	                    e.preventDefault();
	                }
	            }, false);
	        }

	        /**
	         * SOUNDCLOUD INTERFACE EVENT LISTENERS
	         */

	        tdInstance.on('tdplayer.play', function(e) {
	            log('Playing.');
	            changePlayButton(false);
	        });

	        tdInstance.on('tdplayer.pause', function(e) {
	            var sound = tdInstance.sound();
	            var paused = sound.paused;
	            var ratio = sound.position / sound.duration;

	            changePlayButton(paused);

	            if(ratio === 0 && !paused) {
	                analytics('ToneDenTracker.send', {
	                    hitType: 'event',
	                    eventCategory: 'track',
	                    action: 'started',
	                    label: sound.url.replace(/stream\?.+$/, '')
	                });
	            }
	        });

	        tdInstance.on('tdplayer.stop', function(e) {
	            log('Stopped.');
	            container.find('.play').attr('src', playerParameters.staticUrl + 'img/play.png');
	        });

	        tdInstance.on('tdplayer.track.whileloading', function(e, percent) {
	            trackLoadedPercent = percent;
	            trackLoadedTime = percent / 100 * tdInstance.sound().duration;

	            container.find('.buffer').css('width', percent + '%');

	            if(trackSuspend && (trackLoadedTime - tdInstance.position()) > bufferResumeThreshold) {
	                tdInstance.pause();

	                trackSuspend = false;
	            }
	        });

	        tdInstance.on('tdplayer.track.whileplaying', function(e, percent, eqData) {
	            if(showVisualizer == true && typeof(eqData[0]) === 'number' && !isNaN(eqData[0])) {
	                drawEQ(eqData);
	            }

	            var ratio = percent / 100;
	            var playPosition = tdInstance.position();
	            var timeIn = msToTimestamp(playPosition);
	            var timeLeft = msToTimestamp(tdInstance.track().duration - playPosition);

	            trackPlayedPercent = Math.round(percent);

	            // Round ratio to the nearest 3 decimal points.
	            ratio = ratio.toFixed(3);

	            // Only update the slider if the ratio has changed.
	            if(ratio !== currentRatio) {
	                container.find('.scrubber-slider').simpleSlider('setRatio', ratio, true);
	            }

	            // Only update the play times if they have changed.
	            if(timeIn !== currentTimeIn) {
	                container.find('.start-time').html(timeIn);
	                container.find('.stop-time').html(timeLeft);
	            }

	            currentRatio = ratio;
	            currentTimeIn = timeIn;

	            var waitToBuffer = (trackLoadedTime - playPosition) < bufferPauseThreshold &&
	                timeLeft > bufferPauseThreshold || !eqData || (trackLoadedPercent / 100) < currentRatio;

	            if(waitToBuffer) {
	                var loader = $('<i class="tdicon-circle-o-notch spin tdloader"></i>');

	                if(trackPlayedPercent != 100) {
	                    tdInstance.pause();
	                    trackSuspend = true;
	                    container.find('.stop-time').empty().append(loader);
	                }
	            }
	        });

	        tdInstance.on('tdplayer.track.ready', function(e) {
	            trackReady = true;
	        });

	        tdInstance.on('tdplayer.changing_track', function(e, trackIndex) {
	            log('New track index: ' + trackIndex);

	            container.find('.played').css('width', '0%');
	            container.find('.buffer').css('width', '0%');

	            tdInstance.tracks(function(tracks) {
	                rerender({
	                    feed: playerParameters.feed,
	                    mini: playerParameters.mini,
	                    nowPlaying: tdInstance.track(),
	                    shrink: playerParameters.shrink,
	                    single: playerParameters.single,
	                    skin: playerParameters.skin,
	                    tracks: tracks,
	                    tracksPerArtist: playerParameters.tracksPerArtist,
	                    visualizerType: playerParameters.visualizerType
	                });
	            });
	        });

	        /**
	         * PUBLIC INSTANCE METHODS
	         */

	        // Add the array of url strings to the player.
	        function addTracks(urls) {
	            tdInstance.addTracks(urls);
	            playerParameters.urls = tdInstance.playlist();

	            return playerParameters.urls;
	        }

	        function destroy() {
	            container.off();
	            container.html('');

	            tdInstance.destroy();

	            ToneDen.players.splice(ToneDen.players.indexOf(player), 1);
	            delete player;
	        }

	        function pause() {
	            tdInstance.pause();
	        }

	        function play() {
	            tdInstance.play();
	        }

	        function mute() {
	            tdInstance.volume(0);
	            container.find('.volume-select i').removeClass('volume-active');
	            target.addClass('volume-active');
	            container.find('.volume-init').fadeIn().removeClass().addClass(newClass + ' volume-init');
	            container.find('.volume-select').hide();
	            playerVolume = 0;
	        }

	        // Skip to the next track.
	        function next(play) {
	            tdInstance.next(play);
	        }

	        function on(evt, callback) {
	            tdInstance.on(evt, callback);
	        }

	        // Jump to the previous track.
	        function prev(play) {
	            tdInstance.prev(play);
	        }

	        // Remove tracks from the current playlist. Syntax is similar to 
	        // JavaScript's Array.splice() function.
	        function removeTracks(index, howMany) {
	            if(typeof index !== 'number') {
	                log('Index argument is not a number.', 'error');
	                return [];
	            }

	            playerParameters.urls.splice(index, howMany);
	            var tracksRemoved = tdInstance.removeTracks(index, howMany);

	            tdInstance.tracks(function(tracks) {
	                rerender({
	                    feed: playerParameters.feed,
	                    loading: false,
	                    mini: playerParameters.mini,
	                    nowPlaying: tdInstance.track(),
	                    shrink: playerParameters.shrink,
	                    single: playerParameters.single,
	                    skin: playerParameters.skin,
	                    tracks: tracks,
	                    tracksPerArtist: playerParameters.tracksPerArtist,
	                    visualizerType: playerParameters.visualizerType
	                });

	                tdInstance.pause(true);
	            });

	            return tracksRemoved;
	        }

	        // Jump to a track in a playlist specified by its index/position.
	        // If the 'play' parameter is true, play the track.
	        function skipTo(index, play) {
	            tdInstance.goto(index, play);
	        }

	        // Get the current track that's playing.
	        function getTrack() {
	            return tdInstance.track();
	        }

	        // Returns an array of urls loaded in the player.
	        function getAllTracks() {
	            // TODO: Return array of objects.
	            return tdInstance.playlist();
	        }

	        // Get the sound object for the current track.
	        function getSound() {
	            return tdInstance.sound();
	        }

	        // Merge the current parameters object with the new parameters and
	        // rerender to reflect changes.
	        function update(newParameters) {
	            var shouldLoad = false;

	            // Updating the DOM parameter not currently supported.
	            if(newParameters.dom) {
	                log('Updating the DOM parameter is not allowed, ignoring.', 'error');
	                delete newParameters.dom;
	            }

	            // If the new tracks array is different from the current one,
	            // we should load the new playlist.
	            if(newParameters.urls && !_.isEqual(newParameters.urls, playerParameters.urls)) {
	                tdInstance.setTracks(newParameters.urls);
	                tdInstance.goto(0, false);

	                _.extend(playerParameters, newParameters);
	            } else {
	                _.extend(playerParameters, newParameters);

	                tdInstance.tracks(function(tracks) {
	                    rerender({
	                        feed: playerParameters.feed,
	                        loading: shouldLoad,
	                        mini: playerParameters.mini,
	                        nowPlaying: tdInstance.track(),
	                        shrink: playerParameters.shrink,
	                        single: playerParameters.single,
	                        skin: playerParameters.skin,
	                        tracks: tracks,
	                        tracksPerArtist: playerParameters.tracksPerArtist,
	                        visualizerType: playerParameters.visualizerType
	                    });

	                    if(!tdInstance.sound().paused) {
	                        changePlayButton(false);
	                    }
	                });
	            }
	        }

	        player = {
	            addTracks: addTracks,
	            destroy: destroy,
	            getAllTracks: getAllTracks,
	            getSound: getSound,
	            getTrack: getTrack,
	            mute: mute,
	            next: next,
	            on: on,
	            parameters: playerParameters,
	            pause: pause,
	            play: play,
	            prev: prev,
	            removeTracks: removeTracks,
	            skipTo: skipTo,
	            update: update
	        };

	        ToneDen.players.push(player);

	        return player;
	    },
	    /**
	     * Returns the first player whose dom parameter matches the dom argument.
	     */
	    getInstanceByDom: function(dom) {
	        if(!ToneDen.players) {
	            return;
	        }

	        var testPlayer;

	        for(var i = 0; i < ToneDen.players.length; i++) {
	            testPlayer = ToneDen.players[i];

	            if(typeof dom === 'string') {
	                if(testPlayer.parameters.dom === dom) {
	                    return testPlayer;
	                }
	            } else if(dom instanceof $) {
	                if($(testPlayer.parameters.dom).is(dom)) {
	                    return testPlayer;
	                }
	            }
	        }
	    }
	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result — either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.1.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-04-28T16:01Z
	 */

	(function( global, factory ) {

		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//

	var arr = [];

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};



	var
		// Use the correct document accordingly with window argument (sandbox)
		document = window.document,

		version = "2.1.4",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {
		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		// (You can seed the arguments with an array of args, but this is
		// only used internally.)
		each: function( callback, args ) {
			return jQuery.each( this, callback, args );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map(this, function( elem, i ) {
				return callback.call( elem, i, elem );
			}));
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor(null);
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {
			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
		},

		isPlainObject: function( obj ) {
			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			if ( obj.constructor &&
					!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}

			// If the function hasn't returned already, we're confident that
			// |obj| is a plain object, created by {} or constructed with new Object
			return true;
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call(obj) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;

			code = jQuery.trim( code );

			if ( code ) {
				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf("use strict") === 1 ) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {
				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval
					indirect( code );
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		// args is for internal usage only
		each: function( obj, callback, args ) {
			var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike( obj );

			if ( args ) {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.apply( obj[ i ], args );

						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.apply( obj[ i ], args );

						if ( value === false ) {
							break;
						}
					}
				}

			// A special, fast, case for the most common use of each
			} else {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.call( obj[ i ], i, obj[ i ] );

						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.call( obj[ i ], i, obj[ i ] );

						if ( value === false ) {
							break;
						}
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArraylike( Object(arr) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var value,
				i = 0,
				length = elems.length,
				isArray = isArraylike( elems ),
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	});

	function isArraylike( obj ) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.nodeType === 1 && length ) {
			return true;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.0-pre
	 * http://sizzlejs.com/
	 *
	 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-12-16
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
		// http://www.w3.org/TR/css3-syntax/#characters
		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Loosely modeled on CSS identifier characters
		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = characterEncoding.replace( "w", "w#" ),

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + characterEncoding + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + characterEncoding + ")" ),
			"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
			"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,
		rescape = /'|\\/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}

		context = context || document;
		results = results || [];
		nodeType = context.nodeType;

		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		if ( !seed && documentIsHTML ) {

			// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
				// Speed-up: Sizzle("#ID")
				if ( (m = match[1]) ) {
					if ( nodeType === 9 ) {
						elem = context.getElementById( m );
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document (jQuery #6963)
						if ( elem && elem.parentNode ) {
							// Handle the case where IE, Opera, and Webkit return items
							// by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
					} else {
						// Context is not a document
						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
							contains( context, elem ) && elem.id === m ) {
							results.push( elem );
							return results;
						}
					}

				// Speed-up: Sizzle("TAG")
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Speed-up: Sizzle(".CLASS")
				} else if ( (m = match[3]) && support.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// QSA path
			if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				nid = old = expando;
				newContext = context;
				newSelector = nodeType !== 1 && selector;

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );

					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";

					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + toSelector( groups[i] );
					}
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
					newSelector = groups.join(",");
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = attrs.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// If no document and documentElement is available, return
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Set our document
		document = doc;
		docElem = doc.documentElement;
		parent = doc.defaultView;

		// Support: IE>8
		// If iframe document is assigned to "document" variable and if iframe has been reloaded,
		// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
		// IE6-8 do not support the defaultView property so parent will be undefined
		if ( parent && parent !== parent.top ) {
			// IE11 does not have attachEvent, so all must suffer
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Support tests
		---------------------------------------------------------------------- */
		documentIsHTML = !isXML( doc );

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( doc.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\f]' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = doc.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully does not implement inclusive descendent
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === doc ? -1 :
					b === doc ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return doc;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, outerCache, node, diff, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || (parent[ expando ] = {});
								cache = outerCache[ type ] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							// Use previously-cached element index if available
							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
								diff = cache[1];

							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
										// Cache the index of each encountered element
										if ( useCache ) {
											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
							if ( (oldCache = outerCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								outerCache[ dir ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context !== document && context;
				}

				// Add elements passing elementMatchers directly to results
				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// Apply set filters to unmatched elements
				matchedCount += i;
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is no seed and only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;



	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			});

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			});

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
		});
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			}));
	};

	jQuery.fn.extend({
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter(function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				}) );
			}

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow(this, selector || [], false) );
		},
		not: function( selector ) {
			return this.pushStack( winnow(this, selector || [], true) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	});


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		init = jQuery.fn.init = function( selector, context ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && (match[1] || !context) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[1] ) {
						context = context instanceof jQuery ? context[0] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[1],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[2] );

						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {
							// Inject the element directly into the jQuery object
							this.length = 1;
							this[0] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || rootjQuery ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[0] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return typeof rootjQuery.ready !== "undefined" ?
					rootjQuery.ready( selector ) :
					// Execute immediately if ready is not present
					selector( jQuery );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.extend({
		dir: function( elem, dir, until ) {
			var matched = [],
				truncate = until !== undefined;

			while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
				if ( elem.nodeType === 1 ) {
					if ( truncate && jQuery( elem ).is( until ) ) {
						break;
					}
					matched.push( elem );
				}
			}
			return matched;
		},

		sibling: function( n, elem ) {
			var matched = [];

			for ( ; n; n = n.nextSibling ) {
				if ( n.nodeType === 1 && n !== elem ) {
					matched.push( n );
				}
			}

			return matched;
		}
	});

	jQuery.fn.extend({
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter(function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[i] ) ) {
						return true;
					}
				}
			});
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
					// Always skip document fragments
					if ( cur.nodeType < 11 && (pos ?
						pos.index(cur) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector(cur, selectors)) ) {

						matched.push( cur );
						break;
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.unique(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter(selector)
			);
		}
	});

	function sibling( cur, dir ) {
		while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each({
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return jQuery.dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return jQuery.dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return jQuery.dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return jQuery.sibling( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.unique( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	});
	var rnotwhite = (/\S+/g);



	// String to Object options format cache
	var optionsCache = {};

	// Convert String-formatted options into Object-formatted ones and store in cache
	function createOptions( options ) {
		var object = optionsCache[ options ] = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		});
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			( optionsCache[ options ] || createOptions( options ) ) :
			jQuery.extend( {}, options );

		var // Last fire value (for non-forgettable lists)
			memory,
			// Flag to know if list was already fired
			fired,
			// Flag to know if list is currently firing
			firing,
			// First callback to fire (used internally by add and fireWith)
			firingStart,
			// End of the loop when firing
			firingLength,
			// Index of currently firing callback (modified by remove if needed)
			firingIndex,
			// Actual callback list
			list = [],
			// Stack of fire calls for repeatable lists
			stack = !options.once && [],
			// Fire callbacks
			fire = function( data ) {
				memory = options.memory && data;
				fired = true;
				firingIndex = firingStart || 0;
				firingStart = 0;
				firingLength = list.length;
				firing = true;
				for ( ; list && firingIndex < firingLength; firingIndex++ ) {
					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
						memory = false; // To prevent further calls using add
						break;
					}
				}
				firing = false;
				if ( list ) {
					if ( stack ) {
						if ( stack.length ) {
							fire( stack.shift() );
						}
					} else if ( memory ) {
						list = [];
					} else {
						self.disable();
					}
				}
			},
			// Actual Callbacks object
			self = {
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
						// First, we save the current length
						var start = list.length;
						(function add( args ) {
							jQuery.each( args, function( _, arg ) {
								var type = jQuery.type( arg );
								if ( type === "function" ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && type !== "string" ) {
									// Inspect recursively
									add( arg );
								}
							});
						})( arguments );
						// Do we need to add the callbacks to the
						// current firing batch?
						if ( firing ) {
							firingLength = list.length;
						// With memory, if we're not firing then
						// we should call right away
						} else if ( memory ) {
							firingStart = start;
							fire( memory );
						}
					}
					return this;
				},
				// Remove a callback from the list
				remove: function() {
					if ( list ) {
						jQuery.each( arguments, function( _, arg ) {
							var index;
							while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
								list.splice( index, 1 );
								// Handle firing indexes
								if ( firing ) {
									if ( index <= firingLength ) {
										firingLength--;
									}
									if ( index <= firingIndex ) {
										firingIndex--;
									}
								}
							}
						});
					}
					return this;
				},
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
				},
				// Remove all callbacks from the list
				empty: function() {
					list = [];
					firingLength = 0;
					return this;
				},
				// Have the list do nothing anymore
				disable: function() {
					list = stack = memory = undefined;
					return this;
				},
				// Is it disabled?
				disabled: function() {
					return !list;
				},
				// Lock the list in its current state
				lock: function() {
					stack = undefined;
					if ( !memory ) {
						self.disable();
					}
					return this;
				},
				// Is it locked?
				locked: function() {
					return !stack;
				},
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( list && ( !fired || stack ) ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						if ( firing ) {
							stack.push( args );
						} else {
							fire( args );
						}
					}
					return this;
				},
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	jQuery.extend({

		Deferred: function( func ) {
			var tuples = [
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks("memory") ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred(function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[1] ](function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
									}
								});
							});
							fns = null;
						}).promise();
					},
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[1] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(function() {
						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[0] ] = function() {
					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[0] + "With" ] = list.fireWith;
			});

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject )
							.progress( updateFunc( i, progressContexts, progressValues ) );
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	});


	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	};

	jQuery.extend({
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	});

	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );
		jQuery.ready();
	}

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called after the browser event has already occurred.
			// We once tried to use readyState "interactive" here, but it caused issues like the one
			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
			if ( document.readyState === "complete" ) {
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed, false );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed, false );
			}
		}
		return readyList.promise( obj );
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[0], key ) : emptyGet;
	};


	/**
	 * Determines whether an object can have data
	 */
	jQuery.acceptData = function( owner ) {
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};


	function Data() {
		// Support: Android<4,
		// Old WebKit does not have Object.preventExtensions/freeze method,
		// return new empty object instead with no [[set]] accessor
		Object.defineProperty( this.cache = {}, 0, {
			get: function() {
				return {};
			}
		});

		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;
	Data.accepts = jQuery.acceptData;

	Data.prototype = {
		key: function( owner ) {
			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return the key for a frozen object.
			if ( !Data.accepts( owner ) ) {
				return 0;
			}

			var descriptor = {},
				// Check if the owner object already has a cache key
				unlock = owner[ this.expando ];

			// If not, create one
			if ( !unlock ) {
				unlock = Data.uid++;

				// Secure it in a non-enumerable, non-writable property
				try {
					descriptor[ this.expando ] = { value: unlock };
					Object.defineProperties( owner, descriptor );

				// Support: Android<4
				// Fallback to a less secure definition
				} catch ( e ) {
					descriptor[ this.expando ] = unlock;
					jQuery.extend( owner, descriptor );
				}
			}

			// Ensure the cache object
			if ( !this.cache[ unlock ] ) {
				this.cache[ unlock ] = {};
			}

			return unlock;
		},
		set: function( owner, data, value ) {
			var prop,
				// There may be an unlock assigned to this node,
				// if there is no entry for this "owner", create one inline
				// and set the unlock as though an owner entry had always existed
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];

			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;

			// Handle: [ owner, { properties } ] args
			} else {
				// Fresh assignments by object are shallow copied
				if ( jQuery.isEmptyObject( cache ) ) {
					jQuery.extend( this.cache[ unlock ], data );
				// Otherwise, copy the properties one-by-one to the cache object
				} else {
					for ( prop in data ) {
						cache[ prop ] = data[ prop ];
					}
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			// Either a valid cache is found, or will be created.
			// New caches will be created and the unlock returned,
			// allowing direct access to the newly created
			// empty data object. A valid owner object must be provided.
			var cache = this.cache[ this.key( owner ) ];

			return key === undefined ?
				cache : cache[ key ];
		},
		access: function( owner, key, value ) {
			var stored;
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					((key && typeof key === "string") && value === undefined) ) {

				stored = this.get( owner, key );

				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase(key) );
			}

			// [*]When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];

			if ( key === undefined ) {
				this.cache[ unlock ] = {};

			} else {
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );
					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {
						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}

				i = name.length;
				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}
		},
		hasData: function( owner ) {
			return !jQuery.isEmptyObject(
				this.cache[ owner[ this.expando ] ] || {}
			);
		},
		discard: function( owner ) {
			if ( owner[ this.expando ] ) {
				delete this.cache[ owner[ this.expando ] ];
			}
		}
	};
	var data_priv = new Data();

	var data_user = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /([A-Z])/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch( e ) {}

				// Make sure we set the data so it isn't changed later
				data_user.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function( elem ) {
			return data_user.hasData( elem ) || data_priv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return data_user.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			data_user.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to data_priv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return data_priv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			data_priv.remove( elem, name );
		}
	});

	jQuery.fn.extend({
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = data_user.get( elem );

					if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice(5) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						data_priv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each(function() {
					data_user.set( this, key );
				});
			}

			return access( this, function( value ) {
				var data,
					camelKey = jQuery.camelCase( key );

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
					// Attempt to get data from the cache
					// with the key as-is
					data = data_user.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to get data from the cache
					// with the key camelized
					data = data_user.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each(function() {
					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = data_user.get( this, camelKey );

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					data_user.set( this, camelKey, value );

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf("-") !== -1 && data !== undefined ) {
						data_user.set( this, key, value );
					}
				});
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each(function() {
				data_user.remove( this, key );
			});
		}
	});


	jQuery.extend({
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = data_priv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = data_priv.access( elem, type, jQuery.makeArray(data) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return data_priv.get( elem, key ) || data_priv.access( elem, key, {
				empty: jQuery.Callbacks("once memory").add(function() {
					data_priv.remove( elem, [ type + "queue", key ] );
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[0], type );
			}

			return data === undefined ?
				this :
				this.each(function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[0] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				});
		},
		dequeue: function( type ) {
			return this.each(function() {
				jQuery.dequeue( this, type );
			});
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = data_priv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	});
	var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHidden = function( elem, el ) {
			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
		};

	var rcheckableType = (/^(?:checkbox|radio)$/i);



	(function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	})();
	var strundefined = typeof undefined;



	support.focusinBubbles = "onfocusin" in window;


	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !(events = elemData.events) ) {
				events = elemData.events = {};
			}
			if ( !(eventHandle = elemData.handle) ) {
				eventHandle = elemData.handle = function( e ) {
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join(".")
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !(handlers = events[ type ]) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle, false );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.hasData( elem ) && data_priv.get( elem );

			if ( !elemData || !(events = elemData.events) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				delete elemData.handle;
				data_priv.remove( elem, "events" );
			}
		},

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf(".") >= 0 ) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.namespace_re = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === (elem.ownerDocument || document) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
					jQuery.acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
								.apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( (event.result = ret) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			// Avoid non-left-click bubbling in Firefox (#3861)
			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.disabled !== true || event.type !== "click" ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) >= 0 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];

			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		special: {
			load: {
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		},

		simulate: function( type, elem, event, bubble ) {
			// Piggyback on a donor event to simulate a different one.
			// Fake originalEvent to avoid donor's stopPropagation, but if the
			// simulated event prevents default then we do the same on the donor.
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true,
					originalEvent: {}
				}
			);
			if ( bubble ) {
				jQuery.event.trigger( e, null, elem );
			} else {
				jQuery.event.dispatch.call( elem, e );
			}
			if ( e.isDefaultPrevented() ) {
				event.preventDefault();
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	};

	jQuery.Event = function( src, props ) {
		// Allow instantiation without the 'new' keyword
		if ( !(this instanceof jQuery.Event) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && e.preventDefault ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && e.stopPropagation ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && e.stopImmediatePropagation ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// Support: Chrome 15+
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mousenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	});

	// Support: Firefox, Chrome, Safari
	// Create "bubbling" focus and blur events
	if ( !support.focusinBubbles ) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
				};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						data_priv.remove( doc, fix );

					} else {
						data_priv.access( doc, fix, attaches );
					}
				}
			};
		});
	}

	jQuery.fn.extend({

		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
			var origFn, type;

			// Types can be a map of types/handlers
			if ( typeof types === "object" ) {
				// ( types-Object, selector, data )
				if ( typeof selector !== "string" ) {
					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for ( type in types ) {
					this.on( type, selector, data, types[ type ], one );
				}
				return this;
			}

			if ( data == null && fn == null ) {
				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if ( fn == null ) {
				if ( typeof selector === "string" ) {
					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {
					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if ( fn === false ) {
				fn = returnFalse;
			} else if ( !fn ) {
				return this;
			}

			if ( one === 1 ) {
				origFn = fn;
				fn = function( event ) {
					// Can use an empty set, since event contains the info
					jQuery().off( event );
					return origFn.apply( this, arguments );
				};
				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
			}
			return this.each( function() {
				jQuery.event.add( this, types, fn, data, selector );
			});
		},
		one: function( types, selector, data, fn ) {
			return this.on( types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each(function() {
				jQuery.event.remove( this, types, fn, selector );
			});
		},

		trigger: function( type, data ) {
			return this.each(function() {
				jQuery.event.trigger( type, data, this );
			});
		},
		triggerHandler: function( type, data ) {
			var elem = this[0];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	});


	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
		rtagName = /<([\w:]+)/,
		rhtml = /<|&#?\w+;/,
		rnoInnerhtml = /<(?:script|style|link)/i,
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptType = /^$|\/(?:java|ecma)script/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

		// We have to close these tags to support XHTML (#13200)
		wrapMap = {

			// Support: IE9
			option: [ 1, "<select multiple='multiple'>", "</select>" ],

			thead: [ 1, "<table>", "</table>" ],
			col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

			_default: [ 0, "", "" ]
		};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	// Support: 1.x compatibility
	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

			elem.getElementsByTagName("tbody")[0] ||
				elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
			elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			data_priv.set(
				elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
			);
		}
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( data_priv.hasData( src ) ) {
			pdataOld = data_priv.access( src );
			pdataCur = data_priv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( data_user.hasData( src ) ) {
			udataOld = data_user.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			data_user.set( dest, udataCur );
		}
	}

	function getAll( context, tag ) {
		var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
				context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	jQuery.extend({
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		buildFragment: function( elems, context, scripts, selection ) {
			var elem, tmp, tag, wrap, contains, j,
				fragment = context.createDocumentFragment(),
				nodes = [],
				i = 0,
				l = elems.length;

			for ( ; i < l; i++ ) {
				elem = elems[ i ];

				if ( elem || elem === 0 ) {

					// Add nodes directly
					if ( jQuery.type( elem ) === "object" ) {
						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

					// Convert non-html into a text node
					} else if ( !rhtml.test( elem ) ) {
						nodes.push( context.createTextNode( elem ) );

					// Convert html into DOM nodes
					} else {
						tmp = tmp || fragment.appendChild( context.createElement("div") );

						// Deserialize a standard representation
						tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
						wrap = wrapMap[ tag ] || wrapMap._default;
						tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

						// Descend through wrappers to the right content
						j = wrap[ 0 ];
						while ( j-- ) {
							tmp = tmp.lastChild;
						}

						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, tmp.childNodes );

						// Remember the top-level container
						tmp = fragment.firstChild;

						// Ensure the created nodes are orphaned (#12392)
						tmp.textContent = "";
					}
				}
			}

			// Remove wrapper from fragment
			fragment.textContent = "";

			i = 0;
			while ( (elem = nodes[ i++ ]) ) {

				// #4087 - If origin and destination elements are the same, and this is
				// that element, do not do anything
				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
					continue;
				}

				contains = jQuery.contains( elem.ownerDocument, elem );

				// Append to fragment
				tmp = getAll( fragment.appendChild( elem ), "script" );

				// Preserve script evaluation history
				if ( contains ) {
					setGlobalEval( tmp );
				}

				// Capture executables
				if ( scripts ) {
					j = 0;
					while ( (elem = tmp[ j++ ]) ) {
						if ( rscriptType.test( elem.type || "" ) ) {
							scripts.push( elem );
						}
					}
				}
			}

			return fragment;
		},

		cleanData: function( elems ) {
			var data, elem, type, key,
				special = jQuery.event.special,
				i = 0;

			for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
				if ( jQuery.acceptData( elem ) ) {
					key = elem[ data_priv.expando ];

					if ( key && (data = data_priv.cache[ key ]) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
						if ( data_priv.cache[ key ] ) {
							// Discard any remaining `private` data
							delete data_priv.cache[ key ];
						}
					}
				}
				// Discard any remaining `user` data
				delete data_user.cache[ elem[ data_user.expando ] ];
			}
		}
	});

	jQuery.fn.extend({
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each(function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					});
			}, null, value, arguments.length );
		},

		append: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			});
		},

		prepend: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			});
		},

		before: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			});
		},

		after: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			});
		},

		remove: function( selector, keepData /* Internal Use Only */ ) {
			var elem,
				elems = selector ? jQuery.filter( selector, this ) : this,
				i = 0;

			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem ) );
				}

				if ( elem.parentNode ) {
					if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
						setGlobalEval( getAll( elem, "script" ) );
					}
					elem.parentNode.removeChild( elem );
				}
			}

			return this;
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; (elem = this[i]) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			});
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = value.replace( rxhtmlTag, "<$1></$2>" );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var arg = arguments[ 0 ];

			// Make the changes, replacing each context element with the new content
			this.domManip( arguments, function( elem ) {
				arg = this.parentNode;

				jQuery.cleanData( getAll( this ) );

				if ( arg ) {
					arg.replaceChild( elem, this );
				}
			});

			// Force removal if there was no new content (e.g., from empty arguments)
			return arg && (arg.length || arg.nodeType) ? this : this.remove();
		},

		detach: function( selector ) {
			return this.remove( selector, true );
		},

		domManip: function( args, callback ) {

			// Flatten any nested arrays
			args = concat.apply( [], args );

			var fragment, first, scripts, hasScripts, node, doc,
				i = 0,
				l = this.length,
				set = this,
				iNoClone = l - 1,
				value = args[ 0 ],
				isFunction = jQuery.isFunction( value );

			// We can't cloneNode fragments that contain checked, in WebKit
			if ( isFunction ||
					( l > 1 && typeof value === "string" &&
						!support.checkClone && rchecked.test( value ) ) ) {
				return this.each(function( index ) {
					var self = set.eq( index );
					if ( isFunction ) {
						args[ 0 ] = value.call( this, index, self.html() );
					}
					self.domManip( args, callback );
				});
			}

			if ( l ) {
				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
				first = fragment.firstChild;

				if ( fragment.childNodes.length === 1 ) {
					fragment = first;
				}

				if ( first ) {
					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
					hasScripts = scripts.length;

					// Use the original fragment for the last item instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for ( ; i < l; i++ ) {
						node = fragment;

						if ( i !== iNoClone ) {
							node = jQuery.clone( node, true, true );

							// Keep references to cloned scripts for later restoration
							if ( hasScripts ) {
								// Support: QtWebKit
								// jQuery.merge because push.apply(_, arraylike) throws
								jQuery.merge( scripts, getAll( node, "script" ) );
							}
						}

						callback.call( this[ i ], node, i );
					}

					if ( hasScripts ) {
						doc = scripts[ scripts.length - 1 ].ownerDocument;

						// Reenable scripts
						jQuery.map( scripts, restoreScript );

						// Evaluate executable scripts on first document insertion
						for ( i = 0; i < hasScripts; i++ ) {
							node = scripts[ i ];
							if ( rscriptType.test( node.type || "" ) &&
								!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

								if ( node.src ) {
									// Optional AJAX dependency, but won't run scripts if not present
									if ( jQuery._evalUrl ) {
										jQuery._evalUrl( node.src );
									}
								} else {
									jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
								}
							}
						}
					}
				}
			}

			return this;
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	});


	var iframe,
		elemdisplay = {};

	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */
	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var style,
			elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

			// getDefaultComputedStyle might be reliably used only on attached element
			display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

				// Use of this method is a temporary fix (more like optimization) until something better comes along,
				// since it was removed from specification and supported only in FF
				style.display : jQuery.css( elem[ 0 ], "display" );

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {

				// Use the already-created iframe if possible
				iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}
	var rmargin = (/^margin/);

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {
			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			if ( elem.ownerDocument.defaultView.opener ) {
				return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
			}

			return window.getComputedStyle( elem, null );
		};



	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
		}

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// Support: iOS < 6
			// A tribute to the "awesome hack by Dean Edwards"
			// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?
			// Support: IE
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply( this, arguments );
			}
		};
	}


	(function() {
		var pixelPositionVal, boxSizingReliableVal,
			docElem = document.documentElement,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		if ( !div.style ) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
			"position:absolute";
		container.appendChild( div );

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computePixelPositionAndBoxSizingReliable() {
			div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
				"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
				"border:1px;padding:1px;width:4px;position:absolute";
			div.innerHTML = "";
			docElem.appendChild( container );

			var divStyle = window.getComputedStyle( div, null );
			pixelPositionVal = divStyle.top !== "1%";
			boxSizingReliableVal = divStyle.width === "4px";

			docElem.removeChild( container );
		}

		// Support: node.js jsdom
		// Don't assume that getComputedStyle is a property of the global object
		if ( window.getComputedStyle ) {
			jQuery.extend( support, {
				pixelPosition: function() {

					// This test is executed only once but we still do memoizing
					// since we can use the boxSizingReliable pre-computing.
					// No need to check if the test was already performed, though.
					computePixelPositionAndBoxSizingReliable();
					return pixelPositionVal;
				},
				boxSizingReliable: function() {
					if ( boxSizingReliableVal == null ) {
						computePixelPositionAndBoxSizingReliable();
					}
					return boxSizingReliableVal;
				},
				reliableMarginRight: function() {

					// Support: Android 2.3
					// Check if div with explicit width and no margin-right incorrectly
					// gets computed margin-right based on width of container. (#3333)
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// This support function is only executed once so no memoizing is needed.
					var ret,
						marginDiv = div.appendChild( document.createElement( "div" ) );

					// Reset CSS: box-sizing; display; margin; border; padding
					marginDiv.style.cssText = div.style.cssText =
						// Support: Firefox<29, Android 2.3
						// Vendor-prefix box-sizing
						"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
						"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
					marginDiv.style.marginRight = marginDiv.style.width = "0";
					div.style.width = "1px";
					docElem.appendChild( container );

					ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

					docElem.removeChild( container );
					div.removeChild( marginDiv );

					return ret;
				}
			});
		}
	})();


	// A method for quickly swapping in/out CSS properties to get correct calculations.
	jQuery.swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};


	var
		// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
		rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( style, name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in style ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
			origName = name,
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in style ) {
				return name;
			}
		}

		return origName;
	}

	function setPositiveNumber( elem, value, subtract ) {
		var matches = rnumsplit.exec( value );
		return matches ?
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
			// If we already have the right measurement, avoid augmentation
			4 :
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test(val) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			values[ index ] = data_priv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
				}
			} else {
				hidden = isHidden( elem );

				if ( display !== "none" || !hidden ) {
					data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && (ret = rrelNum.exec( value )) ) {
					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number, add 'px' to the (except for certain CSS properties)
				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
					value += "px";
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
					style[ name ] = value;
				}

			} else {
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each([ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
						jQuery.swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						}) :
						getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var styles = extra && getStyles( elem );
				return setPositiveNumber( elem, value, extra ?
					augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					) : 0
				);
			}
		};
	});

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return jQuery.swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split(" ") : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each(function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			});
		}
	});


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || "swing";
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				if ( tween.elem[ tween.prop ] != null &&
					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		}
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
		rrun = /queueHooks$/,
		animationPrefilters = [ defaultPrefilter ],
		tweeners = {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value ),
					target = tween.cur(),
					parts = rfxnum.exec( value ),
					unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

					// Starting value computation is required for potential unit mismatches
					start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
						rfxnum.exec( jQuery.css( tween.elem, prop ) ),
					scale = 1,
					maxIterations = 20;

				if ( start && start[ 3 ] !== unit ) {
					// Trust units reported by jQuery.css
					unit = unit || start[ 3 ];

					// Make sure we update the tween properties later on
					parts = parts || [];

					// Iteratively approximate from a nonzero starting point
					start = +target || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*.
						// Use string for doubling so we don't accidentally see scale as unchanged below
						scale = scale || ".5";

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

					// Update scale, tolerating zero or NaN from tween.cur(),
					// break the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}

				// Update tween properties
				if ( parts ) {
					start = tween.start = +start || +target || 0;
					tween.unit = unit;
					// If a +=/-= token was provided, we're doing a relative animation
					tween.end = parts[ 1 ] ?
						start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
						+parts[ 2 ];
				}

				return tween;
			} ]
		};

	// Animations created synchronously will run synchronously
	function createFxNow() {
		setTimeout(function() {
			fxNow = undefined;
		});
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( (tween = collection[ index ].call( animation, prop, value )) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = data_priv.get( elem, "fxshow" );

		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function() {
				// Ensure the complete handler is called before this completes
				anim.always(function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}

		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = data_priv.access( elem, "fxshow", {} );
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done(function() {
					jQuery( elem ).hide();
				});
			}
			anim.done(function() {
				var prop;

				data_priv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			});
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
			style.display = display;
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = animationPrefilters.length,
			deferred = jQuery.Deferred().always( function() {
				// Don't match elem in the :animated selector
				delete tick.elem;
			}),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ]);

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise({
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, { specialEasing: {} }, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			}),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			})
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.split(" ");
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				tweeners[ prop ] = tweeners[ prop ] || [];
				tweeners[ prop ].unshift( callback );
			}
		},

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				animationPrefilters.unshift( callback );
			} else {
				animationPrefilters.push( callback );
			}
		}
	});

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate({ opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || data_priv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each(function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = data_priv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			});
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each(function() {
				var index,
					data = data_priv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;

	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		clearInterval( timerId );
		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	};


	(function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();


	var nodeHook, boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each(function() {
				jQuery.removeAttr( this, name );
			});
		}
	});

	jQuery.extend({
		attr: function( elem, name, value ) {
			var hooks, ret,
				nType = elem.nodeType;

			// don't get/set attributes on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === strundefined ) {
				return jQuery.prop( elem, name, value );
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
			}

			if ( value !== undefined ) {

				if ( value === null ) {
					jQuery.removeAttr( elem, name );

				} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
					return ret;

				} else {
					elem.setAttribute( name, value + "" );
					return value;
				}

			} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				ret = jQuery.find.attr( elem, name );

				// Non-existent attributes return null, we normalize to undefined
				return ret == null ?
					undefined :
					ret;
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( (name = attrNames[i++]) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {
						// Set corresponding property to false
						elem[ propName ] = false;
					}

					elem.removeAttribute( name );
				}
			}
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	});




	var rfocusable = /^(?:input|select|textarea|button)$/i;

	jQuery.fn.extend({
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each(function() {
				delete this[ jQuery.propFix[ name ] || name ];
			});
		}
	});

	jQuery.extend({
		propFix: {
			"for": "htmlFor",
			"class": "className"
		},

		prop: function( elem, name, value ) {
			var ret, hooks, notxml,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

			if ( notxml ) {
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
					ret :
					( elem[ name ] = value );

			} else {
				return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
					ret :
					elem[ name ];
			}
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {
					return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
						elem.tabIndex :
						-1;
				}
			}
		}
	});

	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			}
		};
	}

	jQuery.each([
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	});




	var rclass = /[\t\r\n\f]/g;

	jQuery.fn.extend({
		addClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = typeof value === "string" && value,
				i = 0,
				len = this.length;

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).addClass( value.call( this, j, this.className ) );
				});
			}

			if ( proceed ) {
				// The disjunction here is for better compressibility (see removeClass)
				classes = ( value || "" ).match( rnotwhite ) || [];

				for ( ; i < len; i++ ) {
					elem = this[ i ];
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						" "
					);

					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = arguments.length === 0 || typeof value === "string" && value,
				i = 0,
				len = this.length;

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).removeClass( value.call( this, j, this.className ) );
				});
			}
			if ( proceed ) {
				classes = ( value || "" ).match( rnotwhite ) || [];

				for ( ; i < len; i++ ) {
					elem = this[ i ];
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						""
					);

					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = value ? jQuery.trim( cur ) : "";
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( i ) {
					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
				});
			}

			return this.each(function() {
				if ( type === "string" ) {
					// Toggle individual class names
					var className,
						i = 0,
						self = jQuery( this ),
						classNames = value.match( rnotwhite ) || [];

					while ( (className = classNames[ i++ ]) ) {
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( type === strundefined || type === "boolean" ) {
					if ( this.className ) {
						// store className if set
						data_priv.set( this, "__className__", this.className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
				}
			});
		},

		hasClass: function( selector ) {
			var className = " " + selector + " ",
				i = 0,
				l = this.length;
			for ( ; i < l; i++ ) {
				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
					return true;
				}
			}

			return false;
		}
	});




	var rreturn = /\r/g;

	jQuery.fn.extend({
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[0];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?
						// Handle most common string cases
						ret.replace(rreturn, "") :
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each(function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function( elem ) {
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						jQuery.trim( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// IE6-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];
						if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});




	// Return jQuery for attributes-only inclusion


	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	});

	jQuery.fn.extend({
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		},

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
		}
	});


	var nonce = jQuery.now();

	var rquery = (/\?/);



	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};


	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE9
		try {
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
		rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Document location
		ajaxLocation = window.location.href,

		// Segment location into parts
		ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {
				// For each dataType in the dataTypeExpression
				while ( (dataType = dataTypes[i++]) ) {
					// Prepend if requested
					if ( dataType[0] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

					// Otherwise append
					} else {
						(structure[ dataType ] = structure[ dataType ] || []).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			});
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s[ "throws" ] ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: ajaxLocation,
			type: "GET",
			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /xml/,
				html: /html/,
				json: /json/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,
				// URL without anti-cache param
				cacheURL,
				// Response headers
				responseHeadersString,
				responseHeaders,
				// timeout handle
				timeoutTimer,
				// Cross-domain detection vars
				parts,
				// To know if global events are to be dispatched
				fireGlobals,
				// Loop variable
				i,
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
				// Callbacks context
				callbackContext = s.context || s,
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks("once memory"),
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
				// The jqXHR state
				state = 0,
				// Default abort message
				strAbort = "canceled",
				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( (match = rheaders.exec( responseHeadersString )) ) {
									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
				.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when we have a protocol:host:port mismatch
			if ( s.crossDomain == null ) {
				parts = rurl.exec( s.url.toLowerCase() );
				s.crossDomain = !!( parts &&
					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
				);
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = setTimeout(function() {
						jqXHR.abort("timeout");
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	});

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			return jQuery.ajax({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			});
		};
	});


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};


	jQuery.fn.extend({
		wrapAll: function( html ) {
			var wrap;

			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapAll( html.call(this, i) );
				});
			}

			if ( this[ 0 ] ) {

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map(function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapInner( html.call(this, i) );
				});
			}

			return this.each(function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			});
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each(function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
			});
		},

		unwrap: function() {
			return this.parent().each(function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			}).end();
		}
	});


	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
	};
	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};




	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
					// Treat each array item as a scalar.
					add( prefix, v );

				} else {
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
				}
			});

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {
			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	jQuery.fn.extend({
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map(function() {
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			})
			.filter(function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			})
			.map(function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						}) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			}).get();
		}
	});


	jQuery.ajaxSettings.xhr = function() {
		try {
			return new XMLHttpRequest();
		} catch( e ) {}
	};

	var xhrId = 0,
		xhrCallbacks = {},
		xhrSuccessStatus = {
			// file protocol always yields status code 0, assume 200
			0: 200,
			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	// Support: IE9
	// Open requests must be manually aborted on unload (#5280)
	// See https://support.microsoft.com/kb/2856746 for more info
	if ( window.attachEvent ) {
		window.attachEvent( "onunload", function() {
			for ( var key in xhrCallbacks ) {
				xhrCallbacks[ key ]();
			}
		});
	}

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function( options ) {
		var callback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;

					xhr.open( options.type, options.url, options.async, options.username, options.password );

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								delete xhrCallbacks[ id ];
								callback = xhr.onload = xhr.onerror = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
									complete(
										// file: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
										// Support: IE9
										// Accessing binary-data responseText throws an exception
										// (#11426)
										typeof xhr.responseText === "string" ? {
											text: xhr.responseText
										} : undefined,
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					xhr.onerror = callback("error");

					// Create the abort callback
					callback = xhrCallbacks[ id ] = callback("abort");

					try {
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});




	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /(?:java|ecma)script/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery("<script>").prop({
						async: true,
						charset: s.scriptCharset,
						src: s.url
					}).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function() {
				// Restore preexisting value
				window[ callbackName ] = overwritten;

				// Save back as free
				if ( s[ callbackName ] ) {
					// make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});




	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf(" ");

		if ( off >= 0 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax({
				url: url,

				// if "type" variable is undefined, then "GET" method will be used
				type: type,
				dataType: "html",
				data: params
			}).done(function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			}).complete( callback && function( jqXHR, status ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			});
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	});




	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};




	var docElem = window.document.documentElement;

	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {
				options = options.call( elem, i, curOffset );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend({
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each(function( i ) {
						jQuery.offset.setOffset( this, options, i );
					});
			}

			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;

			if ( !doc ) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}

			// Support: BlackBerry 5, iOS 3 (original iPhone)
			// If we don't have gBCR, just use 0,0 rather than error
			if ( typeof elem.getBoundingClientRect !== strundefined ) {
				box = elem.getBoundingClientRect();
			}
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {
				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		offsetParent: function() {
			return this.map(function() {
				var offsetParent = this.offsetParent || docElem;

				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || docElem;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : window.pageXOffset,
						top ? val : window.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length, null );
		};
	});

	// Support: Safari<7+, Chrome<37+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	});


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		});
	});


	// The number of elements contained in the matched element set
	jQuery.fn.size = function() {
		return this.length;
	};

	jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( typeof noGlobal === strundefined ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;

	}));


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
	  var d3 = {
	    version: "3.5.5"
	  };
	  var d3_arraySlice = [].slice, d3_array = function(list) {
	    return d3_arraySlice.call(list);
	  };
	  var d3_document = this.document;
	  function d3_documentElement(node) {
	    return node && (node.ownerDocument || node.document || node).documentElement;
	  }
	  function d3_window(node) {
	    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
	  }
	  if (d3_document) {
	    try {
	      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
	    } catch (e) {
	      d3_array = function(list) {
	        var i = list.length, array = new Array(i);
	        while (i--) array[i] = list[i];
	        return array;
	      };
	    }
	  }
	  if (!Date.now) Date.now = function() {
	    return +new Date();
	  };
	  if (d3_document) {
	    try {
	      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
	    } catch (error) {
	      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
	      d3_element_prototype.setAttribute = function(name, value) {
	        d3_element_setAttribute.call(this, name, value + "");
	      };
	      d3_element_prototype.setAttributeNS = function(space, local, value) {
	        d3_element_setAttributeNS.call(this, space, local, value + "");
	      };
	      d3_style_prototype.setProperty = function(name, value, priority) {
	        d3_style_setProperty.call(this, name, value + "", priority);
	      };
	    }
	  }
	  d3.ascending = d3_ascending;
	  function d3_ascending(a, b) {
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  }
	  d3.descending = function(a, b) {
	    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	  };
	  d3.min = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
	    }
	    return a;
	  };
	  d3.max = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
	    }
	    return a;
	  };
	  d3.extent = function(array, f) {
	    var i = -1, n = array.length, a, b, c;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    }
	    return [ a, c ];
	  };
	  function d3_number(x) {
	    return x === null ? NaN : +x;
	  }
	  function d3_numeric(x) {
	    return !isNaN(x);
	  }
	  d3.sum = function(array, f) {
	    var s = 0, n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
	    } else {
	      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
	    }
	    return s;
	  };
	  d3.mean = function(array, f) {
	    var s = 0, n = array.length, a, i = -1, j = n;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
	    }
	    if (j) return s / j;
	  };
	  d3.quantile = function(values, p) {
	    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
	    return e ? v + e * (values[h] - v) : v;
	  };
	  d3.median = function(array, f) {
	    var numbers = [], n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
	    }
	    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
	  };
	  d3.variance = function(array, f) {
	    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
	    if (arguments.length === 1) {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(array[i]))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    } else {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    }
	    if (j > 1) return s / (j - 1);
	  };
	  d3.deviation = function() {
	    var v = d3.variance.apply(this, arguments);
	    return v ? Math.sqrt(v) : v;
	  };
	  function d3_bisector(compare) {
	    return {
	      left: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
	        }
	        return lo;
	      },
	      right: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
	        }
	        return lo;
	      }
	    };
	  }
	  var d3_bisect = d3_bisector(d3_ascending);
	  d3.bisectLeft = d3_bisect.left;
	  d3.bisect = d3.bisectRight = d3_bisect.right;
	  d3.bisector = function(f) {
	    return d3_bisector(f.length === 1 ? function(d, x) {
	      return d3_ascending(f(d), x);
	    } : f);
	  };
	  d3.shuffle = function(array, i0, i1) {
	    if ((m = arguments.length) < 3) {
	      i1 = array.length;
	      if (m < 2) i0 = 0;
	    }
	    var m = i1 - i0, t, i;
	    while (m) {
	      i = Math.random() * m-- | 0;
	      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
	    }
	    return array;
	  };
	  d3.permute = function(array, indexes) {
	    var i = indexes.length, permutes = new Array(i);
	    while (i--) permutes[i] = array[indexes[i]];
	    return permutes;
	  };
	  d3.pairs = function(array) {
	    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
	    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
	    return pairs;
	  };
	  d3.zip = function() {
	    if (!(n = arguments.length)) return [];
	    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
	      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
	        zip[j] = arguments[j][i];
	      }
	    }
	    return zips;
	  };
	  function d3_zipLength(d) {
	    return d.length;
	  }
	  d3.transpose = function(matrix) {
	    return d3.zip.apply(d3, matrix);
	  };
	  d3.keys = function(map) {
	    var keys = [];
	    for (var key in map) keys.push(key);
	    return keys;
	  };
	  d3.values = function(map) {
	    var values = [];
	    for (var key in map) values.push(map[key]);
	    return values;
	  };
	  d3.entries = function(map) {
	    var entries = [];
	    for (var key in map) entries.push({
	      key: key,
	      value: map[key]
	    });
	    return entries;
	  };
	  d3.merge = function(arrays) {
	    var n = arrays.length, m, i = -1, j = 0, merged, array;
	    while (++i < n) j += arrays[i].length;
	    merged = new Array(j);
	    while (--n >= 0) {
	      array = arrays[n];
	      m = array.length;
	      while (--m >= 0) {
	        merged[--j] = array[m];
	      }
	    }
	    return merged;
	  };
	  var abs = Math.abs;
	  d3.range = function(start, stop, step) {
	    if (arguments.length < 3) {
	      step = 1;
	      if (arguments.length < 2) {
	        stop = start;
	        start = 0;
	      }
	    }
	    if ((stop - start) / step === Infinity) throw new Error("infinite range");
	    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
	    start *= k, stop *= k, step *= k;
	    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
	    return range;
	  };
	  function d3_range_integerScale(x) {
	    var k = 1;
	    while (x * k % 1) k *= 10;
	    return k;
	  }
	  function d3_class(ctor, properties) {
	    for (var key in properties) {
	      Object.defineProperty(ctor.prototype, key, {
	        value: properties[key],
	        enumerable: false
	      });
	    }
	  }
	  d3.map = function(object, f) {
	    var map = new d3_Map();
	    if (object instanceof d3_Map) {
	      object.forEach(function(key, value) {
	        map.set(key, value);
	      });
	    } else if (Array.isArray(object)) {
	      var i = -1, n = object.length, o;
	      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
	    } else {
	      for (var key in object) map.set(key, object[key]);
	    }
	    return map;
	  };
	  function d3_Map() {
	    this._ = Object.create(null);
	  }
	  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
	  d3_class(d3_Map, {
	    has: d3_map_has,
	    get: function(key) {
	      return this._[d3_map_escape(key)];
	    },
	    set: function(key, value) {
	      return this._[d3_map_escape(key)] = value;
	    },
	    remove: d3_map_remove,
	    keys: d3_map_keys,
	    values: function() {
	      var values = [];
	      for (var key in this._) values.push(this._[key]);
	      return values;
	    },
	    entries: function() {
	      var entries = [];
	      for (var key in this._) entries.push({
	        key: d3_map_unescape(key),
	        value: this._[key]
	      });
	      return entries;
	    },
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
	    }
	  });
	  function d3_map_escape(key) {
	    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
	  }
	  function d3_map_unescape(key) {
	    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
	  }
	  function d3_map_has(key) {
	    return d3_map_escape(key) in this._;
	  }
	  function d3_map_remove(key) {
	    return (key = d3_map_escape(key)) in this._ && delete this._[key];
	  }
	  function d3_map_keys() {
	    var keys = [];
	    for (var key in this._) keys.push(d3_map_unescape(key));
	    return keys;
	  }
	  function d3_map_size() {
	    var size = 0;
	    for (var key in this._) ++size;
	    return size;
	  }
	  function d3_map_empty() {
	    for (var key in this._) return false;
	    return true;
	  }
	  d3.nest = function() {
	    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
	    function map(mapType, array, depth) {
	      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
	      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
	      while (++i < n) {
	        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
	          values.push(object);
	        } else {
	          valuesByKey.set(keyValue, [ object ]);
	        }
	      }
	      if (mapType) {
	        object = mapType();
	        setter = function(keyValue, values) {
	          object.set(keyValue, map(mapType, values, depth));
	        };
	      } else {
	        object = {};
	        setter = function(keyValue, values) {
	          object[keyValue] = map(mapType, values, depth);
	        };
	      }
	      valuesByKey.forEach(setter);
	      return object;
	    }
	    function entries(map, depth) {
	      if (depth >= keys.length) return map;
	      var array = [], sortKey = sortKeys[depth++];
	      map.forEach(function(key, keyMap) {
	        array.push({
	          key: key,
	          values: entries(keyMap, depth)
	        });
	      });
	      return sortKey ? array.sort(function(a, b) {
	        return sortKey(a.key, b.key);
	      }) : array;
	    }
	    nest.map = function(array, mapType) {
	      return map(mapType, array, 0);
	    };
	    nest.entries = function(array) {
	      return entries(map(d3.map, array, 0), 0);
	    };
	    nest.key = function(d) {
	      keys.push(d);
	      return nest;
	    };
	    nest.sortKeys = function(order) {
	      sortKeys[keys.length - 1] = order;
	      return nest;
	    };
	    nest.sortValues = function(order) {
	      sortValues = order;
	      return nest;
	    };
	    nest.rollup = function(f) {
	      rollup = f;
	      return nest;
	    };
	    return nest;
	  };
	  d3.set = function(array) {
	    var set = new d3_Set();
	    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
	    return set;
	  };
	  function d3_Set() {
	    this._ = Object.create(null);
	  }
	  d3_class(d3_Set, {
	    has: d3_map_has,
	    add: function(key) {
	      this._[d3_map_escape(key += "")] = true;
	      return key;
	    },
	    remove: d3_map_remove,
	    values: d3_map_keys,
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key));
	    }
	  });
	  d3.behavior = {};
	  function d3_identity(d) {
	    return d;
	  }
	  d3.rebind = function(target, source) {
	    var i = 1, n = arguments.length, method;
	    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
	    return target;
	  };
	  function d3_rebind(target, source, method) {
	    return function() {
	      var value = method.apply(source, arguments);
	      return value === source ? target : value;
	    };
	  }
	  function d3_vendorSymbol(object, name) {
	    if (name in object) return name;
	    name = name.charAt(0).toUpperCase() + name.slice(1);
	    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
	      var prefixName = d3_vendorPrefixes[i] + name;
	      if (prefixName in object) return prefixName;
	    }
	  }
	  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
	  function d3_noop() {}
	  d3.dispatch = function() {
	    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    return dispatch;
	  };
	  function d3_dispatch() {}
	  d3_dispatch.prototype.on = function(type, listener) {
	    var i = type.indexOf("."), name = "";
	    if (i >= 0) {
	      name = type.slice(i + 1);
	      type = type.slice(0, i);
	    }
	    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
	    if (arguments.length === 2) {
	      if (listener == null) for (type in this) {
	        if (this.hasOwnProperty(type)) this[type].on(name, null);
	      }
	      return this;
	    }
	  };
	  function d3_dispatch_event(dispatch) {
	    var listeners = [], listenerByName = new d3_Map();
	    function event() {
	      var z = listeners, i = -1, n = z.length, l;
	      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
	      return dispatch;
	    }
	    event.on = function(name, listener) {
	      var l = listenerByName.get(name), i;
	      if (arguments.length < 2) return l && l.on;
	      if (l) {
	        l.on = null;
	        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
	        listenerByName.remove(name);
	      }
	      if (listener) listeners.push(listenerByName.set(name, {
	        on: listener
	      }));
	      return dispatch;
	    };
	    return event;
	  }
	  d3.event = null;
	  function d3_eventPreventDefault() {
	    d3.event.preventDefault();
	  }
	  function d3_eventSource() {
	    var e = d3.event, s;
	    while (s = e.sourceEvent) e = s;
	    return e;
	  }
	  function d3_eventDispatch(target) {
	    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    dispatch.of = function(thiz, argumentz) {
	      return function(e1) {
	        try {
	          var e0 = e1.sourceEvent = d3.event;
	          e1.target = target;
	          d3.event = e1;
	          dispatch[e1.type].apply(thiz, argumentz);
	        } finally {
	          d3.event = e0;
	        }
	      };
	    };
	    return dispatch;
	  }
	  d3.requote = function(s) {
	    return s.replace(d3_requote_re, "\\$&");
	  };
	  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	  var d3_subclass = {}.__proto__ ? function(object, prototype) {
	    object.__proto__ = prototype;
	  } : function(object, prototype) {
	    for (var property in prototype) object[property] = prototype[property];
	  };
	  function d3_selection(groups) {
	    d3_subclass(groups, d3_selectionPrototype);
	    return groups;
	  }
	  var d3_select = function(s, n) {
	    return n.querySelector(s);
	  }, d3_selectAll = function(s, n) {
	    return n.querySelectorAll(s);
	  }, d3_selectMatches = function(n, s) {
	    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
	    d3_selectMatches = function(n, s) {
	      return d3_selectMatcher.call(n, s);
	    };
	    return d3_selectMatches(n, s);
	  };
	  if (typeof Sizzle === "function") {
	    d3_select = function(s, n) {
	      return Sizzle(s, n)[0] || null;
	    };
	    d3_selectAll = Sizzle;
	    d3_selectMatches = Sizzle.matchesSelector;
	  }
	  d3.selection = function() {
	    return d3.select(d3_document.documentElement);
	  };
	  var d3_selectionPrototype = d3.selection.prototype = [];
	  d3_selectionPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, group, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
	          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selector(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_select(selector, this);
	    };
	  }
	  d3_selectionPrototype.selectAll = function(selector) {
	    var subgroups = [], subgroup, node;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
	          subgroup.parentNode = node;
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selectorAll(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_selectAll(selector, this);
	    };
	  }
	  var d3_nsPrefix = {
	    svg: "http://www.w3.org/2000/svg",
	    xhtml: "http://www.w3.org/1999/xhtml",
	    xlink: "http://www.w3.org/1999/xlink",
	    xml: "http://www.w3.org/XML/1998/namespace",
	    xmlns: "http://www.w3.org/2000/xmlns/"
	  };
	  d3.ns = {
	    prefix: d3_nsPrefix,
	    qualify: function(name) {
	      var i = name.indexOf(":"), prefix = name;
	      if (i >= 0) {
	        prefix = name.slice(0, i);
	        name = name.slice(i + 1);
	      }
	      return d3_nsPrefix.hasOwnProperty(prefix) ? {
	        space: d3_nsPrefix[prefix],
	        local: name
	      } : name;
	    }
	  };
	  d3_selectionPrototype.attr = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node();
	        name = d3.ns.qualify(name);
	        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
	      }
	      for (value in name) this.each(d3_selection_attr(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_attr(name, value));
	  };
	  function d3_selection_attr(name, value) {
	    name = d3.ns.qualify(name);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrConstant() {
	      this.setAttribute(name, value);
	    }
	    function attrConstantNS() {
	      this.setAttributeNS(name.space, name.local, value);
	    }
	    function attrFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
	    }
	    function attrFunctionNS() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
	    }
	    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
	  }
	  function d3_collapse(s) {
	    return s.trim().replace(/\s+/g, " ");
	  }
	  d3_selectionPrototype.classed = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
	        if (value = node.classList) {
	          while (++i < n) if (!value.contains(name[i])) return false;
	        } else {
	          value = node.getAttribute("class");
	          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
	        }
	        return true;
	      }
	      for (value in name) this.each(d3_selection_classed(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_classed(name, value));
	  };
	  function d3_selection_classedRe(name) {
	    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
	  }
	  function d3_selection_classes(name) {
	    return (name + "").trim().split(/^|\s+/);
	  }
	  function d3_selection_classed(name, value) {
	    name = d3_selection_classes(name).map(d3_selection_classedName);
	    var n = name.length;
	    function classedConstant() {
	      var i = -1;
	      while (++i < n) name[i](this, value);
	    }
	    function classedFunction() {
	      var i = -1, x = value.apply(this, arguments);
	      while (++i < n) name[i](this, x);
	    }
	    return typeof value === "function" ? classedFunction : classedConstant;
	  }
	  function d3_selection_classedName(name) {
	    var re = d3_selection_classedRe(name);
	    return function(node, value) {
	      if (c = node.classList) return value ? c.add(name) : c.remove(name);
	      var c = node.getAttribute("class") || "";
	      if (value) {
	        re.lastIndex = 0;
	        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
	      } else {
	        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
	      }
	    };
	  }
	  d3_selectionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
	        return this;
	      }
	      if (n < 2) {
	        var node = this.node();
	        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
	      }
	      priority = "";
	    }
	    return this.each(d3_selection_style(name, value, priority));
	  };
	  function d3_selection_style(name, value, priority) {
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleConstant() {
	      this.style.setProperty(name, value, priority);
	    }
	    function styleFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
	    }
	    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
	  }
	  d3_selectionPrototype.property = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") return this.node()[name];
	      for (value in name) this.each(d3_selection_property(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_property(name, value));
	  };
	  function d3_selection_property(name, value) {
	    function propertyNull() {
	      delete this[name];
	    }
	    function propertyConstant() {
	      this[name] = value;
	    }
	    function propertyFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) delete this[name]; else this[name] = x;
	    }
	    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
	  }
	  d3_selectionPrototype.text = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.textContent = v == null ? "" : v;
	    } : value == null ? function() {
	      this.textContent = "";
	    } : function() {
	      this.textContent = value;
	    }) : this.node().textContent;
	  };
	  d3_selectionPrototype.html = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.innerHTML = v == null ? "" : v;
	    } : value == null ? function() {
	      this.innerHTML = "";
	    } : function() {
	      this.innerHTML = value;
	    }) : this.node().innerHTML;
	  };
	  d3_selectionPrototype.append = function(name) {
	    name = d3_selection_creator(name);
	    return this.select(function() {
	      return this.appendChild(name.apply(this, arguments));
	    });
	  };
	  function d3_selection_creator(name) {
	    function create() {
	      var document = this.ownerDocument, namespace = this.namespaceURI;
	      return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
	    }
	    function createNS() {
	      return this.ownerDocument.createElementNS(name.space, name.local);
	    }
	    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
	  }
	  d3_selectionPrototype.insert = function(name, before) {
	    name = d3_selection_creator(name);
	    before = d3_selection_selector(before);
	    return this.select(function() {
	      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
	    });
	  };
	  d3_selectionPrototype.remove = function() {
	    return this.each(d3_selectionRemove);
	  };
	  function d3_selectionRemove() {
	    var parent = this.parentNode;
	    if (parent) parent.removeChild(this);
	  }
	  d3_selectionPrototype.data = function(value, key) {
	    var i = -1, n = this.length, group, node;
	    if (!arguments.length) {
	      value = new Array(n = (group = this[0]).length);
	      while (++i < n) {
	        if (node = group[i]) {
	          value[i] = node.__data__;
	        }
	      }
	      return value;
	    }
	    function bind(group, groupData) {
	      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
	      if (key) {
	        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
	        for (i = -1; ++i < n; ) {
	          if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
	            exitNodes[i] = node;
	          } else {
	            nodeByKeyValue.set(keyValue, node);
	          }
	          keyValues[i] = keyValue;
	        }
	        for (i = -1; ++i < m; ) {
	          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          } else if (node !== true) {
	            updateNodes[i] = node;
	            node.__data__ = nodeData;
	          }
	          nodeByKeyValue.set(keyValue, true);
	        }
	        for (i = -1; ++i < n; ) {
	          if (nodeByKeyValue.get(keyValues[i]) !== true) {
	            exitNodes[i] = group[i];
	          }
	        }
	      } else {
	        for (i = -1; ++i < n0; ) {
	          node = group[i];
	          nodeData = groupData[i];
	          if (node) {
	            node.__data__ = nodeData;
	            updateNodes[i] = node;
	          } else {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          }
	        }
	        for (;i < m; ++i) {
	          enterNodes[i] = d3_selection_dataNode(groupData[i]);
	        }
	        for (;i < n; ++i) {
	          exitNodes[i] = group[i];
	        }
	      }
	      enterNodes.update = updateNodes;
	      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
	      enter.push(enterNodes);
	      update.push(updateNodes);
	      exit.push(exitNodes);
	    }
	    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
	    if (typeof value === "function") {
	      while (++i < n) {
	        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
	      }
	    } else {
	      while (++i < n) {
	        bind(group = this[i], value);
	      }
	    }
	    update.enter = function() {
	      return enter;
	    };
	    update.exit = function() {
	      return exit;
	    };
	    return update;
	  };
	  function d3_selection_dataNode(data) {
	    return {
	      __data__: data
	    };
	  }
	  d3_selectionPrototype.datum = function(value) {
	    return arguments.length ? this.property("__data__", value) : this.property("__data__");
	  };
	  d3_selectionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_filter(selector) {
	    return function() {
	      return d3_selectMatches(this, selector);
	    };
	  }
	  d3_selectionPrototype.order = function() {
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
	        if (node = group[i]) {
	          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	          next = node;
	        }
	      }
	    }
	    return this;
	  };
	  d3_selectionPrototype.sort = function(comparator) {
	    comparator = d3_selection_sortComparator.apply(this, arguments);
	    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
	    return this.order();
	  };
	  function d3_selection_sortComparator(comparator) {
	    if (!arguments.length) comparator = d3_ascending;
	    return function(a, b) {
	      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
	    };
	  }
	  d3_selectionPrototype.each = function(callback) {
	    return d3_selection_each(this, function(node, i, j) {
	      callback.call(node, node.__data__, i, j);
	    });
	  };
	  function d3_selection_each(groups, callback) {
	    for (var j = 0, m = groups.length; j < m; j++) {
	      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
	        if (node = group[i]) callback(node, i, j);
	      }
	    }
	    return groups;
	  }
	  d3_selectionPrototype.call = function(callback) {
	    var args = d3_array(arguments);
	    callback.apply(args[0] = this, args);
	    return this;
	  };
	  d3_selectionPrototype.empty = function() {
	    return !this.node();
	  };
	  d3_selectionPrototype.node = function() {
	    for (var j = 0, m = this.length; j < m; j++) {
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        var node = group[i];
	        if (node) return node;
	      }
	    }
	    return null;
	  };
	  d3_selectionPrototype.size = function() {
	    var n = 0;
	    d3_selection_each(this, function() {
	      ++n;
	    });
	    return n;
	  };
	  function d3_selection_enter(selection) {
	    d3_subclass(selection, d3_selection_enterPrototype);
	    return selection;
	  }
	  var d3_selection_enterPrototype = [];
	  d3.selection.enter = d3_selection_enter;
	  d3.selection.enter.prototype = d3_selection_enterPrototype;
	  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
	  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
	  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
	  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
	  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
	  d3_selection_enterPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, upgroup, group, node;
	    for (var j = -1, m = this.length; ++j < m; ) {
	      upgroup = (group = this[j]).update;
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = group.parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
	          subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  d3_selection_enterPrototype.insert = function(name, before) {
	    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
	    return d3_selectionPrototype.insert.call(this, name, before);
	  };
	  function d3_selection_enterInsertBefore(enter) {
	    var i0, j0;
	    return function(d, i, j) {
	      var group = enter[j].update, n = group.length, node;
	      if (j != j0) j0 = j, i0 = 0;
	      if (i >= i0) i0 = i + 1;
	      while (!(node = group[i0]) && ++i0 < n) ;
	      return node;
	    };
	  }
	  d3.select = function(node) {
	    var group;
	    if (typeof node === "string") {
	      group = [ d3_select(node, d3_document) ];
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = [ node ];
	      group.parentNode = d3_documentElement(node);
	    }
	    return d3_selection([ group ]);
	  };
	  d3.selectAll = function(nodes) {
	    var group;
	    if (typeof nodes === "string") {
	      group = d3_array(d3_selectAll(nodes, d3_document));
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = nodes;
	      group.parentNode = null;
	    }
	    return d3_selection([ group ]);
	  };
	  d3_selectionPrototype.on = function(type, listener, capture) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof type !== "string") {
	        if (n < 2) listener = false;
	        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
	        return this;
	      }
	      if (n < 2) return (n = this.node()["__on" + type]) && n._;
	      capture = false;
	    }
	    return this.each(d3_selection_on(type, listener, capture));
	  };
	  function d3_selection_on(type, listener, capture) {
	    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
	    if (i > 0) type = type.slice(0, i);
	    var filter = d3_selection_onFilters.get(type);
	    if (filter) type = filter, wrap = d3_selection_onFilter;
	    function onRemove() {
	      var l = this[name];
	      if (l) {
	        this.removeEventListener(type, l, l.$);
	        delete this[name];
	      }
	    }
	    function onAdd() {
	      var l = wrap(listener, d3_array(arguments));
	      onRemove.call(this);
	      this.addEventListener(type, this[name] = l, l.$ = capture);
	      l._ = listener;
	    }
	    function removeAll() {
	      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
	      for (var name in this) {
	        if (match = name.match(re)) {
	          var l = this[name];
	          this.removeEventListener(match[1], l, l.$);
	          delete this[name];
	        }
	      }
	    }
	    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
	  }
	  var d3_selection_onFilters = d3.map({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout"
	  });
	  if (d3_document) {
	    d3_selection_onFilters.forEach(function(k) {
	      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
	    });
	  }
	  function d3_selection_onListener(listener, argumentz) {
	    return function(e) {
	      var o = d3.event;
	      d3.event = e;
	      argumentz[0] = this.__data__;
	      try {
	        listener.apply(this, argumentz);
	      } finally {
	        d3.event = o;
	      }
	    };
	  }
	  function d3_selection_onFilter(listener, argumentz) {
	    var l = d3_selection_onListener(listener, argumentz);
	    return function(e) {
	      var target = this, related = e.relatedTarget;
	      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
	        l.call(target, e);
	      }
	    };
	  }
	  var d3_event_dragSelect, d3_event_dragId = 0;
	  function d3_event_dragSuppress(node) {
	    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
	    if (d3_event_dragSelect == null) {
	      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
	    }
	    if (d3_event_dragSelect) {
	      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
	      style[d3_event_dragSelect] = "none";
	    }
	    return function(suppressClick) {
	      w.on(name, null);
	      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
	      if (suppressClick) {
	        var off = function() {
	          w.on(click, null);
	        };
	        w.on(click, function() {
	          d3_eventPreventDefault();
	          off();
	        }, true);
	        setTimeout(off, 0);
	      }
	    };
	  }
	  d3.mouse = function(container) {
	    return d3_mousePoint(container, d3_eventSource());
	  };
	  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
	  function d3_mousePoint(container, e) {
	    if (e.changedTouches) e = e.changedTouches[0];
	    var svg = container.ownerSVGElement || container;
	    if (svg.createSVGPoint) {
	      var point = svg.createSVGPoint();
	      if (d3_mouse_bug44083 < 0) {
	        var window = d3_window(container);
	        if (window.scrollX || window.scrollY) {
	          svg = d3.select("body").append("svg").style({
	            position: "absolute",
	            top: 0,
	            left: 0,
	            margin: 0,
	            padding: 0,
	            border: "none"
	          }, "important");
	          var ctm = svg[0][0].getScreenCTM();
	          d3_mouse_bug44083 = !(ctm.f || ctm.e);
	          svg.remove();
	        }
	      }
	      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
	      point.y = e.clientY;
	      point = point.matrixTransform(container.getScreenCTM().inverse());
	      return [ point.x, point.y ];
	    }
	    var rect = container.getBoundingClientRect();
	    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
	  }
	  d3.touch = function(container, touches, identifier) {
	    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
	    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
	      if ((touch = touches[i]).identifier === identifier) {
	        return d3_mousePoint(container, touch);
	      }
	    }
	  };
	  d3.behavior.drag = function() {
	    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
	    function drag() {
	      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
	    }
	    function dragstart(id, position, subject, move, end) {
	      return function() {
	        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
	        if (origin) {
	          dragOffset = origin.apply(that, arguments);
	          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
	        } else {
	          dragOffset = [ 0, 0 ];
	        }
	        dispatch({
	          type: "dragstart"
	        });
	        function moved() {
	          var position1 = position(parent, dragId), dx, dy;
	          if (!position1) return;
	          dx = position1[0] - position0[0];
	          dy = position1[1] - position0[1];
	          dragged |= dx | dy;
	          position0 = position1;
	          dispatch({
	            type: "drag",
	            x: position1[0] + dragOffset[0],
	            y: position1[1] + dragOffset[1],
	            dx: dx,
	            dy: dy
	          });
	        }
	        function ended() {
	          if (!position(parent, dragId)) return;
	          dragSubject.on(move + dragName, null).on(end + dragName, null);
	          dragRestore(dragged && d3.event.target === target);
	          dispatch({
	            type: "dragend"
	          });
	        }
	      };
	    }
	    drag.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return drag;
	    };
	    return d3.rebind(drag, event, "on");
	  };
	  function d3_behavior_dragTouchId() {
	    return d3.event.changedTouches[0].identifier;
	  }
	  d3.touches = function(container, touches) {
	    if (arguments.length < 2) touches = d3_eventSource().touches;
	    return touches ? d3_array(touches).map(function(touch) {
	      var point = d3_mousePoint(container, touch);
	      point.identifier = touch.identifier;
	      return point;
	    }) : [];
	  };
	  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
	  function d3_sgn(x) {
	    return x > 0 ? 1 : x < 0 ? -1 : 0;
	  }
	  function d3_cross2d(a, b, c) {
	    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	  }
	  function d3_acos(x) {
	    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
	  }
	  function d3_asin(x) {
	    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
	  }
	  function d3_sinh(x) {
	    return ((x = Math.exp(x)) - 1 / x) / 2;
	  }
	  function d3_cosh(x) {
	    return ((x = Math.exp(x)) + 1 / x) / 2;
	  }
	  function d3_tanh(x) {
	    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	  }
	  function d3_haversin(x) {
	    return (x = Math.sin(x / 2)) * x;
	  }
	  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
	  d3.interpolateZoom = function(p0, p1) {
	    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
	    var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
	    function interpolate(t) {
	      var s = t * S;
	      if (dr) {
	        var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
	        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
	      }
	      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
	    }
	    interpolate.duration = S * 1e3;
	    return interpolate;
	  };
	  d3.behavior.zoom = function() {
	    var view = {
	      x: 0,
	      y: 0,
	      k: 1
	    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
	    if (!d3_behavior_zoomWheel) {
	      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
	      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return d3.event.wheelDelta;
	      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
	        return -d3.event.detail;
	      }, "MozMousePixelScroll");
	    }
	    function zoom(g) {
	      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
	    }
	    zoom.event = function(g) {
	      g.each(function() {
	        var dispatch = event.of(this, arguments), view1 = view;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.zoom", function() {
	            view = this.__chart__ || {
	              x: 0,
	              y: 0,
	              k: 1
	            };
	            zoomstarted(dispatch);
	          }).tween("zoom:zoom", function() {
	            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
	            return function(t) {
	              var l = i(t), k = dx / l[2];
	              this.__chart__ = view = {
	                x: cx - l[0] * k,
	                y: cy - l[1] * k,
	                k: k
	              };
	              zoomed(dispatch);
	            };
	          }).each("interrupt.zoom", function() {
	            zoomended(dispatch);
	          }).each("end.zoom", function() {
	            zoomended(dispatch);
	          });
	        } else {
	          this.__chart__ = view;
	          zoomstarted(dispatch);
	          zoomed(dispatch);
	          zoomended(dispatch);
	        }
	      });
	    };
	    zoom.translate = function(_) {
	      if (!arguments.length) return [ view.x, view.y ];
	      view = {
	        x: +_[0],
	        y: +_[1],
	        k: view.k
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scale = function(_) {
	      if (!arguments.length) return view.k;
	      view = {
	        x: view.x,
	        y: view.y,
	        k: +_
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scaleExtent = function(_) {
	      if (!arguments.length) return scaleExtent;
	      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.center = function(_) {
	      if (!arguments.length) return center;
	      center = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.size = function(_) {
	      if (!arguments.length) return size;
	      size = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.duration = function(_) {
	      if (!arguments.length) return duration;
	      duration = +_;
	      return zoom;
	    };
	    zoom.x = function(z) {
	      if (!arguments.length) return x1;
	      x1 = z;
	      x0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    zoom.y = function(z) {
	      if (!arguments.length) return y1;
	      y1 = z;
	      y0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    function location(p) {
	      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
	    }
	    function point(l) {
	      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
	    }
	    function scaleTo(s) {
	      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
	    }
	    function translateTo(p, l) {
	      l = point(l);
	      view.x += p[0] - l[0];
	      view.y += p[1] - l[1];
	    }
	    function zoomTo(that, p, l, k) {
	      that.__chart__ = {
	        x: view.x,
	        y: view.y,
	        k: view.k
	      };
	      scaleTo(Math.pow(2, k));
	      translateTo(center0 = p, l);
	      that = d3.select(that);
	      if (duration > 0) that = that.transition().duration(duration);
	      that.call(zoom.event);
	    }
	    function rescale() {
	      if (x1) x1.domain(x0.range().map(function(x) {
	        return (x - view.x) / view.k;
	      }).map(x0.invert));
	      if (y1) y1.domain(y0.range().map(function(y) {
	        return (y - view.y) / view.k;
	      }).map(y0.invert));
	    }
	    function zoomstarted(dispatch) {
	      if (!zooming++) dispatch({
	        type: "zoomstart"
	      });
	    }
	    function zoomed(dispatch) {
	      rescale();
	      dispatch({
	        type: "zoom",
	        scale: view.k,
	        translate: [ view.x, view.y ]
	      });
	    }
	    function zoomended(dispatch) {
	      if (!--zooming) dispatch({
	        type: "zoomend"
	      });
	      center0 = null;
	    }
	    function mousedowned() {
	      var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
	      d3_selection_interrupt.call(that);
	      zoomstarted(dispatch);
	      function moved() {
	        dragged = 1;
	        translateTo(d3.mouse(that), location0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        subject.on(mousemove, null).on(mouseup, null);
	        dragRestore(dragged && d3.event.target === target);
	        zoomended(dispatch);
	      }
	    }
	    function touchstarted() {
	      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
	      started();
	      zoomstarted(dispatch);
	      subject.on(mousedown, null).on(touchstart, started);
	      function relocate() {
	        var touches = d3.touches(that);
	        scale0 = view.k;
	        touches.forEach(function(t) {
	          if (t.identifier in locations0) locations0[t.identifier] = location(t);
	        });
	        return touches;
	      }
	      function started() {
	        var target = d3.event.target;
	        d3.select(target).on(touchmove, moved).on(touchend, ended);
	        targets.push(target);
	        var changed = d3.event.changedTouches;
	        for (var i = 0, n = changed.length; i < n; ++i) {
	          locations0[changed[i].identifier] = null;
	        }
	        var touches = relocate(), now = Date.now();
	        if (touches.length === 1) {
	          if (now - touchtime < 500) {
	            var p = touches[0];
	            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
	            d3_eventPreventDefault();
	          }
	          touchtime = now;
	        } else if (touches.length > 1) {
	          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
	          distance0 = dx * dx + dy * dy;
	        }
	      }
	      function moved() {
	        var touches = d3.touches(that), p0, l0, p1, l1;
	        d3_selection_interrupt.call(that);
	        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
	          p1 = touches[i];
	          if (l1 = locations0[p1.identifier]) {
	            if (l0) break;
	            p0 = p1, l0 = l1;
	          }
	        }
	        if (l1) {
	          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
	          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
	          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
	          scaleTo(scale1 * scale0);
	        }
	        touchtime = null;
	        translateTo(p0, l0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        if (d3.event.touches.length) {
	          var changed = d3.event.changedTouches;
	          for (var i = 0, n = changed.length; i < n; ++i) {
	            delete locations0[changed[i].identifier];
	          }
	          for (var identifier in locations0) {
	            return void relocate();
	          }
	        }
	        d3.selectAll(targets).on(zoomName, null);
	        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
	        dragRestore();
	        zoomended(dispatch);
	      }
	    }
	    function mousewheeled() {
	      var dispatch = event.of(this, arguments);
	      if (mousewheelTimer) clearTimeout(mousewheelTimer); else translate0 = location(center0 = center || d3.mouse(this)), 
	      d3_selection_interrupt.call(this), zoomstarted(dispatch);
	      mousewheelTimer = setTimeout(function() {
	        mousewheelTimer = null;
	        zoomended(dispatch);
	      }, 50);
	      d3_eventPreventDefault();
	      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
	      translateTo(center0, translate0);
	      zoomed(dispatch);
	    }
	    function dblclicked() {
	      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
	      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
	    }
	    return d3.rebind(zoom, event, "on");
	  };
	  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
	  d3.color = d3_color;
	  function d3_color() {}
	  d3_color.prototype.toString = function() {
	    return this.rgb() + "";
	  };
	  d3.hsl = d3_hsl;
	  function d3_hsl(h, s, l) {
	    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
	  }
	  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
	  d3_hslPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, this.l / k);
	  };
	  d3_hslPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, k * this.l);
	  };
	  d3_hslPrototype.rgb = function() {
	    return d3_hsl_rgb(this.h, this.s, this.l);
	  };
	  function d3_hsl_rgb(h, s, l) {
	    var m1, m2;
	    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
	    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
	    l = l < 0 ? 0 : l > 1 ? 1 : l;
	    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
	    m1 = 2 * l - m2;
	    function v(h) {
	      if (h > 360) h -= 360; else if (h < 0) h += 360;
	      if (h < 60) return m1 + (m2 - m1) * h / 60;
	      if (h < 180) return m2;
	      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
	      return m1;
	    }
	    function vv(h) {
	      return Math.round(v(h) * 255);
	    }
	    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
	  }
	  d3.hcl = d3_hcl;
	  function d3_hcl(h, c, l) {
	    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
	  }
	  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
	  d3_hclPrototype.brighter = function(k) {
	    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.darker = function(k) {
	    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.rgb = function() {
	    return d3_hcl_lab(this.h, this.c, this.l).rgb();
	  };
	  function d3_hcl_lab(h, c, l) {
	    if (isNaN(h)) h = 0;
	    if (isNaN(c)) c = 0;
	    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
	  }
	  d3.lab = d3_lab;
	  function d3_lab(l, a, b) {
	    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
	  }
	  var d3_lab_K = 18;
	  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
	  var d3_labPrototype = d3_lab.prototype = new d3_color();
	  d3_labPrototype.brighter = function(k) {
	    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.darker = function(k) {
	    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.rgb = function() {
	    return d3_lab_rgb(this.l, this.a, this.b);
	  };
	  function d3_lab_rgb(l, a, b) {
	    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
	    x = d3_lab_xyz(x) * d3_lab_X;
	    y = d3_lab_xyz(y) * d3_lab_Y;
	    z = d3_lab_xyz(z) * d3_lab_Z;
	    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
	  }
	  function d3_lab_hcl(l, a, b) {
	    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
	  }
	  function d3_lab_xyz(x) {
	    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
	  }
	  function d3_xyz_lab(x) {
	    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
	  }
	  function d3_xyz_rgb(r) {
	    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
	  }
	  d3.rgb = d3_rgb;
	  function d3_rgb(r, g, b) {
	    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
	  }
	  function d3_rgbNumber(value) {
	    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
	  }
	  function d3_rgbString(value) {
	    return d3_rgbNumber(value) + "";
	  }
	  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
	  d3_rgbPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    var r = this.r, g = this.g, b = this.b, i = 30;
	    if (!r && !g && !b) return new d3_rgb(i, i, i);
	    if (r && r < i) r = i;
	    if (g && g < i) g = i;
	    if (b && b < i) b = i;
	    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
	  };
	  d3_rgbPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_rgb(k * this.r, k * this.g, k * this.b);
	  };
	  d3_rgbPrototype.hsl = function() {
	    return d3_rgb_hsl(this.r, this.g, this.b);
	  };
	  d3_rgbPrototype.toString = function() {
	    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
	  };
	  function d3_rgb_hex(v) {
	    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
	  }
	  function d3_rgb_parse(format, rgb, hsl) {
	    var r = 0, g = 0, b = 0, m1, m2, color;
	    m1 = /([a-z]+)\((.*)\)/i.exec(format);
	    if (m1) {
	      m2 = m1[2].split(",");
	      switch (m1[1]) {
	       case "hsl":
	        {
	          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
	        }

	       case "rgb":
	        {
	          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
	        }
	      }
	    }
	    if (color = d3_rgb_names.get(format.toLowerCase())) {
	      return rgb(color.r, color.g, color.b);
	    }
	    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
	      if (format.length === 4) {
	        r = (color & 3840) >> 4;
	        r = r >> 4 | r;
	        g = color & 240;
	        g = g >> 4 | g;
	        b = color & 15;
	        b = b << 4 | b;
	      } else if (format.length === 7) {
	        r = (color & 16711680) >> 16;
	        g = (color & 65280) >> 8;
	        b = color & 255;
	      }
	    }
	    return rgb(r, g, b);
	  }
	  function d3_rgb_hsl(r, g, b) {
	    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
	    if (d) {
	      s = l < .5 ? d / (max + min) : d / (2 - max - min);
	      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
	      h *= 60;
	    } else {
	      h = NaN;
	      s = l > 0 && l < 1 ? 0 : h;
	    }
	    return new d3_hsl(h, s, l);
	  }
	  function d3_rgb_lab(r, g, b) {
	    r = d3_rgb_xyz(r);
	    g = d3_rgb_xyz(g);
	    b = d3_rgb_xyz(b);
	    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
	    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
	  }
	  function d3_rgb_xyz(r) {
	    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
	  }
	  function d3_rgb_parseNumber(c) {
	    var f = parseFloat(c);
	    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
	  }
	  var d3_rgb_names = d3.map({
	    aliceblue: 15792383,
	    antiquewhite: 16444375,
	    aqua: 65535,
	    aquamarine: 8388564,
	    azure: 15794175,
	    beige: 16119260,
	    bisque: 16770244,
	    black: 0,
	    blanchedalmond: 16772045,
	    blue: 255,
	    blueviolet: 9055202,
	    brown: 10824234,
	    burlywood: 14596231,
	    cadetblue: 6266528,
	    chartreuse: 8388352,
	    chocolate: 13789470,
	    coral: 16744272,
	    cornflowerblue: 6591981,
	    cornsilk: 16775388,
	    crimson: 14423100,
	    cyan: 65535,
	    darkblue: 139,
	    darkcyan: 35723,
	    darkgoldenrod: 12092939,
	    darkgray: 11119017,
	    darkgreen: 25600,
	    darkgrey: 11119017,
	    darkkhaki: 12433259,
	    darkmagenta: 9109643,
	    darkolivegreen: 5597999,
	    darkorange: 16747520,
	    darkorchid: 10040012,
	    darkred: 9109504,
	    darksalmon: 15308410,
	    darkseagreen: 9419919,
	    darkslateblue: 4734347,
	    darkslategray: 3100495,
	    darkslategrey: 3100495,
	    darkturquoise: 52945,
	    darkviolet: 9699539,
	    deeppink: 16716947,
	    deepskyblue: 49151,
	    dimgray: 6908265,
	    dimgrey: 6908265,
	    dodgerblue: 2003199,
	    firebrick: 11674146,
	    floralwhite: 16775920,
	    forestgreen: 2263842,
	    fuchsia: 16711935,
	    gainsboro: 14474460,
	    ghostwhite: 16316671,
	    gold: 16766720,
	    goldenrod: 14329120,
	    gray: 8421504,
	    green: 32768,
	    greenyellow: 11403055,
	    grey: 8421504,
	    honeydew: 15794160,
	    hotpink: 16738740,
	    indianred: 13458524,
	    indigo: 4915330,
	    ivory: 16777200,
	    khaki: 15787660,
	    lavender: 15132410,
	    lavenderblush: 16773365,
	    lawngreen: 8190976,
	    lemonchiffon: 16775885,
	    lightblue: 11393254,
	    lightcoral: 15761536,
	    lightcyan: 14745599,
	    lightgoldenrodyellow: 16448210,
	    lightgray: 13882323,
	    lightgreen: 9498256,
	    lightgrey: 13882323,
	    lightpink: 16758465,
	    lightsalmon: 16752762,
	    lightseagreen: 2142890,
	    lightskyblue: 8900346,
	    lightslategray: 7833753,
	    lightslategrey: 7833753,
	    lightsteelblue: 11584734,
	    lightyellow: 16777184,
	    lime: 65280,
	    limegreen: 3329330,
	    linen: 16445670,
	    magenta: 16711935,
	    maroon: 8388608,
	    mediumaquamarine: 6737322,
	    mediumblue: 205,
	    mediumorchid: 12211667,
	    mediumpurple: 9662683,
	    mediumseagreen: 3978097,
	    mediumslateblue: 8087790,
	    mediumspringgreen: 64154,
	    mediumturquoise: 4772300,
	    mediumvioletred: 13047173,
	    midnightblue: 1644912,
	    mintcream: 16121850,
	    mistyrose: 16770273,
	    moccasin: 16770229,
	    navajowhite: 16768685,
	    navy: 128,
	    oldlace: 16643558,
	    olive: 8421376,
	    olivedrab: 7048739,
	    orange: 16753920,
	    orangered: 16729344,
	    orchid: 14315734,
	    palegoldenrod: 15657130,
	    palegreen: 10025880,
	    paleturquoise: 11529966,
	    palevioletred: 14381203,
	    papayawhip: 16773077,
	    peachpuff: 16767673,
	    peru: 13468991,
	    pink: 16761035,
	    plum: 14524637,
	    powderblue: 11591910,
	    purple: 8388736,
	    rebeccapurple: 6697881,
	    red: 16711680,
	    rosybrown: 12357519,
	    royalblue: 4286945,
	    saddlebrown: 9127187,
	    salmon: 16416882,
	    sandybrown: 16032864,
	    seagreen: 3050327,
	    seashell: 16774638,
	    sienna: 10506797,
	    silver: 12632256,
	    skyblue: 8900331,
	    slateblue: 6970061,
	    slategray: 7372944,
	    slategrey: 7372944,
	    snow: 16775930,
	    springgreen: 65407,
	    steelblue: 4620980,
	    tan: 13808780,
	    teal: 32896,
	    thistle: 14204888,
	    tomato: 16737095,
	    turquoise: 4251856,
	    violet: 15631086,
	    wheat: 16113331,
	    white: 16777215,
	    whitesmoke: 16119285,
	    yellow: 16776960,
	    yellowgreen: 10145074
	  });
	  d3_rgb_names.forEach(function(key, value) {
	    d3_rgb_names.set(key, d3_rgbNumber(value));
	  });
	  function d3_functor(v) {
	    return typeof v === "function" ? v : function() {
	      return v;
	    };
	  }
	  d3.functor = d3_functor;
	  d3.xhr = d3_xhrType(d3_identity);
	  function d3_xhrType(response) {
	    return function(url, mimeType, callback) {
	      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
	      mimeType = null;
	      return d3_xhr(url, mimeType, response, callback);
	    };
	  }
	  function d3_xhr(url, mimeType, response, callback) {
	    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
	    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
	    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
	      request.readyState > 3 && respond();
	    };
	    function respond() {
	      var status = request.status, result;
	      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
	        try {
	          result = response.call(xhr, request);
	        } catch (e) {
	          dispatch.error.call(xhr, e);
	          return;
	        }
	        dispatch.load.call(xhr, result);
	      } else {
	        dispatch.error.call(xhr, request);
	      }
	    }
	    request.onprogress = function(event) {
	      var o = d3.event;
	      d3.event = event;
	      try {
	        dispatch.progress.call(xhr, request);
	      } finally {
	        d3.event = o;
	      }
	    };
	    xhr.header = function(name, value) {
	      name = (name + "").toLowerCase();
	      if (arguments.length < 2) return headers[name];
	      if (value == null) delete headers[name]; else headers[name] = value + "";
	      return xhr;
	    };
	    xhr.mimeType = function(value) {
	      if (!arguments.length) return mimeType;
	      mimeType = value == null ? null : value + "";
	      return xhr;
	    };
	    xhr.responseType = function(value) {
	      if (!arguments.length) return responseType;
	      responseType = value;
	      return xhr;
	    };
	    xhr.response = function(value) {
	      response = value;
	      return xhr;
	    };
	    [ "get", "post" ].forEach(function(method) {
	      xhr[method] = function() {
	        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
	      };
	    });
	    xhr.send = function(method, data, callback) {
	      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
	      request.open(method, url, true);
	      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
	      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
	      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
	      if (responseType != null) request.responseType = responseType;
	      if (callback != null) xhr.on("error", callback).on("load", function(request) {
	        callback(null, request);
	      });
	      dispatch.beforesend.call(xhr, request);
	      request.send(data == null ? null : data);
	      return xhr;
	    };
	    xhr.abort = function() {
	      request.abort();
	      return xhr;
	    };
	    d3.rebind(xhr, dispatch, "on");
	    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
	  }
	  function d3_xhr_fixCallback(callback) {
	    return callback.length === 1 ? function(error, request) {
	      callback(error == null ? request : null);
	    } : callback;
	  }
	  function d3_xhrHasResponse(request) {
	    var type = request.responseType;
	    return type && type !== "text" ? request.response : request.responseText;
	  }
	  d3.dsv = function(delimiter, mimeType) {
	    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
	    function dsv(url, row, callback) {
	      if (arguments.length < 3) callback = row, row = null;
	      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
	      xhr.row = function(_) {
	        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
	      };
	      return xhr;
	    }
	    function response(request) {
	      return dsv.parse(request.responseText);
	    }
	    function typedResponse(f) {
	      return function(request) {
	        return dsv.parse(request.responseText, f);
	      };
	    }
	    dsv.parse = function(text, f) {
	      var o;
	      return dsv.parseRows(text, function(row, i) {
	        if (o) return o(row, i - 1);
	        var a = new Function("d", "return {" + row.map(function(name, i) {
	          return JSON.stringify(name) + ": d[" + i + "]";
	        }).join(",") + "}");
	        o = f ? function(row, i) {
	          return f(a(row), i);
	        } : a;
	      });
	    };
	    dsv.parseRows = function(text, f) {
	      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
	      function token() {
	        if (I >= N) return EOF;
	        if (eol) return eol = false, EOL;
	        var j = I;
	        if (text.charCodeAt(j) === 34) {
	          var i = j;
	          while (i++ < N) {
	            if (text.charCodeAt(i) === 34) {
	              if (text.charCodeAt(i + 1) !== 34) break;
	              ++i;
	            }
	          }
	          I = i + 2;
	          var c = text.charCodeAt(i + 1);
	          if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(i + 2) === 10) ++I;
	          } else if (c === 10) {
	            eol = true;
	          }
	          return text.slice(j + 1, i).replace(/""/g, '"');
	        }
	        while (I < N) {
	          var c = text.charCodeAt(I++), k = 1;
	          if (c === 10) eol = true; else if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(I) === 10) ++I, ++k;
	          } else if (c !== delimiterCode) continue;
	          return text.slice(j, I - k);
	        }
	        return text.slice(j);
	      }
	      while ((t = token()) !== EOF) {
	        var a = [];
	        while (t !== EOL && t !== EOF) {
	          a.push(t);
	          t = token();
	        }
	        if (f && (a = f(a, n++)) == null) continue;
	        rows.push(a);
	      }
	      return rows;
	    };
	    dsv.format = function(rows) {
	      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
	      var fieldSet = new d3_Set(), fields = [];
	      rows.forEach(function(row) {
	        for (var field in row) {
	          if (!fieldSet.has(field)) {
	            fields.push(fieldSet.add(field));
	          }
	        }
	      });
	      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
	        return fields.map(function(field) {
	          return formatValue(row[field]);
	        }).join(delimiter);
	      })).join("\n");
	    };
	    dsv.formatRows = function(rows) {
	      return rows.map(formatRow).join("\n");
	    };
	    function formatRow(row) {
	      return row.map(formatValue).join(delimiter);
	    }
	    function formatValue(text) {
	      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
	    }
	    return dsv;
	  };
	  d3.csv = d3.dsv(",", "text/csv");
	  d3.tsv = d3.dsv("	", "text/tab-separated-values");
	  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
	    setTimeout(callback, 17);
	  };
	  d3.timer = function(callback, delay, then) {
	    var n = arguments.length;
	    if (n < 2) delay = 0;
	    if (n < 3) then = Date.now();
	    var time = then + delay, timer = {
	      c: callback,
	      t: time,
	      f: false,
	      n: null
	    };
	    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
	    d3_timer_queueTail = timer;
	    if (!d3_timer_interval) {
	      d3_timer_timeout = clearTimeout(d3_timer_timeout);
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  };
	  function d3_timer_step() {
	    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
	    if (delay > 24) {
	      if (isFinite(delay)) {
	        clearTimeout(d3_timer_timeout);
	        d3_timer_timeout = setTimeout(d3_timer_step, delay);
	      }
	      d3_timer_interval = 0;
	    } else {
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  }
	  d3.timer.flush = function() {
	    d3_timer_mark();
	    d3_timer_sweep();
	  };
	  function d3_timer_mark() {
	    var now = Date.now();
	    d3_timer_active = d3_timer_queueHead;
	    while (d3_timer_active) {
	      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
	      d3_timer_active = d3_timer_active.n;
	    }
	    return now;
	  }
	  function d3_timer_sweep() {
	    var t0, t1 = d3_timer_queueHead, time = Infinity;
	    while (t1) {
	      if (t1.f) {
	        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
	      } else {
	        if (t1.t < time) time = t1.t;
	        t1 = (t0 = t1).n;
	      }
	    }
	    d3_timer_queueTail = t0;
	    return time;
	  }
	  function d3_format_precision(x, p) {
	    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
	  }
	  d3.round = function(x, n) {
	    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
	  };
	  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
	  d3.formatPrefix = function(value, precision) {
	    var i = 0;
	    if (value) {
	      if (value < 0) value *= -1;
	      if (precision) value = d3.round(value, d3_format_precision(value, precision));
	      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
	      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
	    }
	    return d3_formatPrefixes[8 + i / 3];
	  };
	  function d3_formatPrefix(d, i) {
	    var k = Math.pow(10, abs(8 - i) * 3);
	    return {
	      scale: i > 8 ? function(d) {
	        return d / k;
	      } : function(d) {
	        return d * k;
	      },
	      symbol: d
	    };
	  }
	  function d3_locale_numberFormat(locale) {
	    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
	      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
	      while (i > 0 && g > 0) {
	        if (length + g + 1 > width) g = Math.max(1, width - length);
	        t.push(value.substring(i -= g, i + g));
	        if ((length += g + 1) > width) break;
	        g = locale_grouping[j = (j + 1) % locale_grouping.length];
	      }
	      return t.reverse().join(locale_thousands);
	    } : d3_identity;
	    return function(specifier) {
	      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
	      if (precision) precision = +precision.substring(1);
	      if (zfill || fill === "0" && align === "=") {
	        zfill = fill = "0";
	        align = "=";
	      }
	      switch (type) {
	       case "n":
	        comma = true;
	        type = "g";
	        break;

	       case "%":
	        scale = 100;
	        suffix = "%";
	        type = "f";
	        break;

	       case "p":
	        scale = 100;
	        suffix = "%";
	        type = "r";
	        break;

	       case "b":
	       case "o":
	       case "x":
	       case "X":
	        if (symbol === "#") prefix = "0" + type.toLowerCase();

	       case "c":
	        exponent = false;

	       case "d":
	        integer = true;
	        precision = 0;
	        break;

	       case "s":
	        scale = -1;
	        type = "r";
	        break;
	      }
	      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
	      if (type == "r" && !precision) type = "g";
	      if (precision != null) {
	        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
	      }
	      type = d3_format_types.get(type) || d3_format_typeDefault;
	      var zcomma = zfill && comma;
	      return function(value) {
	        var fullSuffix = suffix;
	        if (integer && value % 1) return "";
	        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
	        if (scale < 0) {
	          var unit = d3.formatPrefix(value, precision);
	          value = unit.scale(value);
	          fullSuffix = unit.symbol + suffix;
	        } else {
	          value *= scale;
	        }
	        value = type(value, precision);
	        var i = value.lastIndexOf("."), before, after;
	        if (i < 0) {
	          var j = exponent ? value.lastIndexOf("e") : -1;
	          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
	        } else {
	          before = value.substring(0, i);
	          after = locale_decimal + value.substring(i + 1);
	        }
	        if (!zfill && comma) before = formatGroup(before, Infinity);
	        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
	        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
	        negative += prefix;
	        value = before + after;
	        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
	      };
	    };
	  }
	  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
	  var d3_format_types = d3.map({
	    b: function(x) {
	      return x.toString(2);
	    },
	    c: function(x) {
	      return String.fromCharCode(x);
	    },
	    o: function(x) {
	      return x.toString(8);
	    },
	    x: function(x) {
	      return x.toString(16);
	    },
	    X: function(x) {
	      return x.toString(16).toUpperCase();
	    },
	    g: function(x, p) {
	      return x.toPrecision(p);
	    },
	    e: function(x, p) {
	      return x.toExponential(p);
	    },
	    f: function(x, p) {
	      return x.toFixed(p);
	    },
	    r: function(x, p) {
	      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
	    }
	  });
	  function d3_format_typeDefault(x) {
	    return x + "";
	  }
	  var d3_time = d3.time = {}, d3_date = Date;
	  function d3_date_utc() {
	    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
	  }
	  d3_date_utc.prototype = {
	    getDate: function() {
	      return this._.getUTCDate();
	    },
	    getDay: function() {
	      return this._.getUTCDay();
	    },
	    getFullYear: function() {
	      return this._.getUTCFullYear();
	    },
	    getHours: function() {
	      return this._.getUTCHours();
	    },
	    getMilliseconds: function() {
	      return this._.getUTCMilliseconds();
	    },
	    getMinutes: function() {
	      return this._.getUTCMinutes();
	    },
	    getMonth: function() {
	      return this._.getUTCMonth();
	    },
	    getSeconds: function() {
	      return this._.getUTCSeconds();
	    },
	    getTime: function() {
	      return this._.getTime();
	    },
	    getTimezoneOffset: function() {
	      return 0;
	    },
	    valueOf: function() {
	      return this._.valueOf();
	    },
	    setDate: function() {
	      d3_time_prototype.setUTCDate.apply(this._, arguments);
	    },
	    setDay: function() {
	      d3_time_prototype.setUTCDay.apply(this._, arguments);
	    },
	    setFullYear: function() {
	      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
	    },
	    setHours: function() {
	      d3_time_prototype.setUTCHours.apply(this._, arguments);
	    },
	    setMilliseconds: function() {
	      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
	    },
	    setMinutes: function() {
	      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
	    },
	    setMonth: function() {
	      d3_time_prototype.setUTCMonth.apply(this._, arguments);
	    },
	    setSeconds: function() {
	      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
	    },
	    setTime: function() {
	      d3_time_prototype.setTime.apply(this._, arguments);
	    }
	  };
	  var d3_time_prototype = Date.prototype;
	  function d3_time_interval(local, step, number) {
	    function round(date) {
	      var d0 = local(date), d1 = offset(d0, 1);
	      return date - d0 < d1 - date ? d0 : d1;
	    }
	    function ceil(date) {
	      step(date = local(new d3_date(date - 1)), 1);
	      return date;
	    }
	    function offset(date, k) {
	      step(date = new d3_date(+date), k);
	      return date;
	    }
	    function range(t0, t1, dt) {
	      var time = ceil(t0), times = [];
	      if (dt > 1) {
	        while (time < t1) {
	          if (!(number(time) % dt)) times.push(new Date(+time));
	          step(time, 1);
	        }
	      } else {
	        while (time < t1) times.push(new Date(+time)), step(time, 1);
	      }
	      return times;
	    }
	    function range_utc(t0, t1, dt) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = t0;
	        return range(utc, t1, dt);
	      } finally {
	        d3_date = Date;
	      }
	    }
	    local.floor = local;
	    local.round = round;
	    local.ceil = ceil;
	    local.offset = offset;
	    local.range = range;
	    var utc = local.utc = d3_time_interval_utc(local);
	    utc.floor = utc;
	    utc.round = d3_time_interval_utc(round);
	    utc.ceil = d3_time_interval_utc(ceil);
	    utc.offset = d3_time_interval_utc(offset);
	    utc.range = range_utc;
	    return local;
	  }
	  function d3_time_interval_utc(method) {
	    return function(date, k) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = date;
	        return method(utc, k)._;
	      } finally {
	        d3_date = Date;
	      }
	    };
	  }
	  d3_time.year = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setMonth(0, 1);
	    return date;
	  }, function(date, offset) {
	    date.setFullYear(date.getFullYear() + offset);
	  }, function(date) {
	    return date.getFullYear();
	  });
	  d3_time.years = d3_time.year.range;
	  d3_time.years.utc = d3_time.year.utc.range;
	  d3_time.day = d3_time_interval(function(date) {
	    var day = new d3_date(2e3, 0);
	    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	    return day;
	  }, function(date, offset) {
	    date.setDate(date.getDate() + offset);
	  }, function(date) {
	    return date.getDate() - 1;
	  });
	  d3_time.days = d3_time.day.range;
	  d3_time.days.utc = d3_time.day.utc.range;
	  d3_time.dayOfYear = function(date) {
	    var year = d3_time.year(date);
	    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
	  };
	  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
	    i = 7 - i;
	    var interval = d3_time[day] = d3_time_interval(function(date) {
	      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
	      return date;
	    }, function(date, offset) {
	      date.setDate(date.getDate() + Math.floor(offset) * 7);
	    }, function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
	    });
	    d3_time[day + "s"] = interval.range;
	    d3_time[day + "s"].utc = interval.utc.range;
	    d3_time[day + "OfYear"] = function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
	    };
	  });
	  d3_time.week = d3_time.sunday;
	  d3_time.weeks = d3_time.sunday.range;
	  d3_time.weeks.utc = d3_time.sunday.utc.range;
	  d3_time.weekOfYear = d3_time.sundayOfYear;
	  function d3_locale_timeFormat(locale) {
	    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
	    function d3_time_format(template) {
	      var n = template.length;
	      function format(date) {
	        var string = [], i = -1, j = 0, c, p, f;
	        while (++i < n) {
	          if (template.charCodeAt(i) === 37) {
	            string.push(template.slice(j, i));
	            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
	            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
	            string.push(c);
	            j = i + 1;
	          }
	        }
	        string.push(template.slice(j, i));
	        return string.join("");
	      }
	      format.parse = function(string) {
	        var d = {
	          y: 1900,
	          m: 0,
	          d: 1,
	          H: 0,
	          M: 0,
	          S: 0,
	          L: 0,
	          Z: null
	        }, i = d3_time_parse(d, template, string, 0);
	        if (i != string.length) return null;
	        if ("p" in d) d.H = d.H % 12 + d.p * 12;
	        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
	        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
	          date.setFullYear(d.y, 0, 1);
	          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
	        } else date.setFullYear(d.y, d.m, d.d);
	        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
	        return localZ ? date._ : date;
	      };
	      format.toString = function() {
	        return template;
	      };
	      return format;
	    }
	    function d3_time_parse(date, template, string, j) {
	      var c, p, t, i = 0, n = template.length, m = string.length;
	      while (i < n) {
	        if (j >= m) return -1;
	        c = template.charCodeAt(i++);
	        if (c === 37) {
	          t = template.charAt(i++);
	          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
	          if (!p || (j = p(date, string, j)) < 0) return -1;
	        } else if (c != string.charCodeAt(j++)) {
	          return -1;
	        }
	      }
	      return j;
	    }
	    d3_time_format.utc = function(template) {
	      var local = d3_time_format(template);
	      function format(date) {
	        try {
	          d3_date = d3_date_utc;
	          var utc = new d3_date();
	          utc._ = date;
	          return local(utc);
	        } finally {
	          d3_date = Date;
	        }
	      }
	      format.parse = function(string) {
	        try {
	          d3_date = d3_date_utc;
	          var date = local.parse(string);
	          return date && date._;
	        } finally {
	          d3_date = Date;
	        }
	      };
	      format.toString = local.toString;
	      return format;
	    };
	    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
	    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
	    locale_periods.forEach(function(p, i) {
	      d3_time_periodLookup.set(p.toLowerCase(), i);
	    });
	    var d3_time_formats = {
	      a: function(d) {
	        return locale_shortDays[d.getDay()];
	      },
	      A: function(d) {
	        return locale_days[d.getDay()];
	      },
	      b: function(d) {
	        return locale_shortMonths[d.getMonth()];
	      },
	      B: function(d) {
	        return locale_months[d.getMonth()];
	      },
	      c: d3_time_format(locale_dateTime),
	      d: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      e: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      H: function(d, p) {
	        return d3_time_formatPad(d.getHours(), p, 2);
	      },
	      I: function(d, p) {
	        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
	      },
	      j: function(d, p) {
	        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
	      },
	      L: function(d, p) {
	        return d3_time_formatPad(d.getMilliseconds(), p, 3);
	      },
	      m: function(d, p) {
	        return d3_time_formatPad(d.getMonth() + 1, p, 2);
	      },
	      M: function(d, p) {
	        return d3_time_formatPad(d.getMinutes(), p, 2);
	      },
	      p: function(d) {
	        return locale_periods[+(d.getHours() >= 12)];
	      },
	      S: function(d, p) {
	        return d3_time_formatPad(d.getSeconds(), p, 2);
	      },
	      U: function(d, p) {
	        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
	      },
	      w: function(d) {
	        return d.getDay();
	      },
	      W: function(d, p) {
	        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
	      },
	      x: d3_time_format(locale_date),
	      X: d3_time_format(locale_time),
	      y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
	      },
	      Y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
	      },
	      Z: d3_time_zone,
	      "%": function() {
	        return "%";
	      }
	    };
	    var d3_time_parsers = {
	      a: d3_time_parseWeekdayAbbrev,
	      A: d3_time_parseWeekday,
	      b: d3_time_parseMonthAbbrev,
	      B: d3_time_parseMonth,
	      c: d3_time_parseLocaleFull,
	      d: d3_time_parseDay,
	      e: d3_time_parseDay,
	      H: d3_time_parseHour24,
	      I: d3_time_parseHour24,
	      j: d3_time_parseDayOfYear,
	      L: d3_time_parseMilliseconds,
	      m: d3_time_parseMonthNumber,
	      M: d3_time_parseMinutes,
	      p: d3_time_parseAmPm,
	      S: d3_time_parseSeconds,
	      U: d3_time_parseWeekNumberSunday,
	      w: d3_time_parseWeekdayNumber,
	      W: d3_time_parseWeekNumberMonday,
	      x: d3_time_parseLocaleDate,
	      X: d3_time_parseLocaleTime,
	      y: d3_time_parseYear,
	      Y: d3_time_parseFullYear,
	      Z: d3_time_parseZone,
	      "%": d3_time_parseLiteralPercent
	    };
	    function d3_time_parseWeekdayAbbrev(date, string, i) {
	      d3_time_dayAbbrevRe.lastIndex = 0;
	      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseWeekday(date, string, i) {
	      d3_time_dayRe.lastIndex = 0;
	      var n = d3_time_dayRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonthAbbrev(date, string, i) {
	      d3_time_monthAbbrevRe.lastIndex = 0;
	      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonth(date, string, i) {
	      d3_time_monthRe.lastIndex = 0;
	      var n = d3_time_monthRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseLocaleFull(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
	    }
	    function d3_time_parseLocaleDate(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
	    }
	    function d3_time_parseLocaleTime(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
	    }
	    function d3_time_parseAmPm(date, string, i) {
	      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
	      return n == null ? -1 : (date.p = n, i);
	    }
	    return d3_time_format;
	  }
	  var d3_time_formatPads = {
	    "-": "",
	    _: " ",
	    "0": "0"
	  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
	  function d3_time_formatPad(value, fill, width) {
	    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
	    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	  }
	  function d3_time_formatRe(names) {
	    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
	  }
	  function d3_time_formatLookup(names) {
	    var map = new d3_Map(), i = -1, n = names.length;
	    while (++i < n) map.set(names[i].toLowerCase(), i);
	    return map;
	  }
	  function d3_time_parseWeekdayNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
	    return n ? (date.w = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberSunday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.U = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberMonday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.W = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseFullYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
	    return n ? (date.y = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
	  }
	  function d3_time_parseZone(date, string, i) {
	    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
	    i + 5) : -1;
	  }
	  function d3_time_expandYear(d) {
	    return d + (d > 68 ? 1900 : 2e3);
	  }
	  function d3_time_parseMonthNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
	  }
	  function d3_time_parseDay(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.d = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseDayOfYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.j = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseHour24(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.H = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMinutes(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.M = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseSeconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.S = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMilliseconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.L = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_zone(d) {
	    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
	    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
	  }
	  function d3_time_parseLiteralPercent(date, string, i) {
	    d3_time_percentRe.lastIndex = 0;
	    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
	    return n ? i + n[0].length : -1;
	  }
	  function d3_time_formatMulti(formats) {
	    var n = formats.length, i = -1;
	    while (++i < n) formats[i][0] = this(formats[i][0]);
	    return function(date) {
	      var i = 0, f = formats[i];
	      while (!f[1](date)) f = formats[++i];
	      return f[0](date);
	    };
	  }
	  d3.locale = function(locale) {
	    return {
	      numberFormat: d3_locale_numberFormat(locale),
	      timeFormat: d3_locale_timeFormat(locale)
	    };
	  };
	  var d3_locale_enUS = d3.locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [ 3 ],
	    currency: [ "$", "" ],
	    dateTime: "%a %b %e %X %Y",
	    date: "%m/%d/%Y",
	    time: "%H:%M:%S",
	    periods: [ "AM", "PM" ],
	    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
	    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
	    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
	    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
	  });
	  d3.format = d3_locale_enUS.numberFormat;
	  d3.geo = {};
	  function d3_adder() {}
	  d3_adder.prototype = {
	    s: 0,
	    t: 0,
	    add: function(y) {
	      d3_adderSum(y, this.t, d3_adderTemp);
	      d3_adderSum(d3_adderTemp.s, this.s, this);
	      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
	    },
	    reset: function() {
	      this.s = this.t = 0;
	    },
	    valueOf: function() {
	      return this.s;
	    }
	  };
	  var d3_adderTemp = new d3_adder();
	  function d3_adderSum(a, b, o) {
	    var x = o.s = a + b, bv = x - a, av = x - bv;
	    o.t = a - av + (b - bv);
	  }
	  d3.geo.stream = function(object, listener) {
	    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
	      d3_geo_streamObjectType[object.type](object, listener);
	    } else {
	      d3_geo_streamGeometry(object, listener);
	    }
	  };
	  function d3_geo_streamGeometry(geometry, listener) {
	    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
	      d3_geo_streamGeometryType[geometry.type](geometry, listener);
	    }
	  }
	  var d3_geo_streamObjectType = {
	    Feature: function(feature, listener) {
	      d3_geo_streamGeometry(feature.geometry, listener);
	    },
	    FeatureCollection: function(object, listener) {
	      var features = object.features, i = -1, n = features.length;
	      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
	    }
	  };
	  var d3_geo_streamGeometryType = {
	    Sphere: function(object, listener) {
	      listener.sphere();
	    },
	    Point: function(object, listener) {
	      object = object.coordinates;
	      listener.point(object[0], object[1], object[2]);
	    },
	    MultiPoint: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
	    },
	    LineString: function(object, listener) {
	      d3_geo_streamLine(object.coordinates, listener, 0);
	    },
	    MultiLineString: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
	    },
	    Polygon: function(object, listener) {
	      d3_geo_streamPolygon(object.coordinates, listener);
	    },
	    MultiPolygon: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
	    },
	    GeometryCollection: function(object, listener) {
	      var geometries = object.geometries, i = -1, n = geometries.length;
	      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
	    }
	  };
	  function d3_geo_streamLine(coordinates, listener, closed) {
	    var i = -1, n = coordinates.length - closed, coordinate;
	    listener.lineStart();
	    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
	    listener.lineEnd();
	  }
	  function d3_geo_streamPolygon(coordinates, listener) {
	    var i = -1, n = coordinates.length;
	    listener.polygonStart();
	    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
	    listener.polygonEnd();
	  }
	  d3.geo.area = function(object) {
	    d3_geo_areaSum = 0;
	    d3.geo.stream(object, d3_geo_area);
	    return d3_geo_areaSum;
	  };
	  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
	  var d3_geo_area = {
	    sphere: function() {
	      d3_geo_areaSum += 4 * π;
	    },
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_areaRingSum.reset();
	      d3_geo_area.lineStart = d3_geo_areaRingStart;
	    },
	    polygonEnd: function() {
	      var area = 2 * d3_geo_areaRingSum;
	      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
	      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
	    }
	  };
	  function d3_geo_areaRingStart() {
	    var λ00, φ00, λ0, cosφ0, sinφ0;
	    d3_geo_area.point = function(λ, φ) {
	      d3_geo_area.point = nextPoint;
	      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
	      sinφ0 = Math.sin(φ);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      φ = φ * d3_radians / 2 + π / 4;
	      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
	      d3_geo_areaRingSum.add(Math.atan2(v, u));
	      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
	    }
	    d3_geo_area.lineEnd = function() {
	      nextPoint(λ00, φ00);
	    };
	  }
	  function d3_geo_cartesian(spherical) {
	    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
	    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
	  }
	  function d3_geo_cartesianDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	  }
	  function d3_geo_cartesianCross(a, b) {
	    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
	  }
	  function d3_geo_cartesianAdd(a, b) {
	    a[0] += b[0];
	    a[1] += b[1];
	    a[2] += b[2];
	  }
	  function d3_geo_cartesianScale(vector, k) {
	    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
	  }
	  function d3_geo_cartesianNormalize(d) {
	    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	    d[0] /= l;
	    d[1] /= l;
	    d[2] /= l;
	  }
	  function d3_geo_spherical(cartesian) {
	    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
	  }
	  function d3_geo_sphericalEqual(a, b) {
	    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
	  }
	  d3.geo.bounds = function() {
	    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
	    var bound = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        bound.point = ringPoint;
	        bound.lineStart = ringStart;
	        bound.lineEnd = ringEnd;
	        dλSum = 0;
	        d3_geo_area.polygonStart();
	      },
	      polygonEnd: function() {
	        d3_geo_area.polygonEnd();
	        bound.point = point;
	        bound.lineStart = lineStart;
	        bound.lineEnd = lineEnd;
	        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
	        range[0] = λ0, range[1] = λ1;
	      }
	    };
	    function point(λ, φ) {
	      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
	      if (φ < φ0) φ0 = φ;
	      if (φ > φ1) φ1 = φ;
	    }
	    function linePoint(λ, φ) {
	      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
	      if (p0) {
	        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
	        d3_geo_cartesianNormalize(inflection);
	        inflection = d3_geo_spherical(inflection);
	        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
	        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = inflection[1] * d3_degrees;
	          if (φi > φ1) φ1 = φi;
	        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = -inflection[1] * d3_degrees;
	          if (φi < φ0) φ0 = φi;
	        } else {
	          if (φ < φ0) φ0 = φ;
	          if (φ > φ1) φ1 = φ;
	        }
	        if (antimeridian) {
	          if (λ < λ_) {
	            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	          } else {
	            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	          }
	        } else {
	          if (λ1 >= λ0) {
	            if (λ < λ0) λ0 = λ;
	            if (λ > λ1) λ1 = λ;
	          } else {
	            if (λ > λ_) {
	              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	            } else {
	              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	            }
	          }
	        }
	      } else {
	        point(λ, φ);
	      }
	      p0 = p, λ_ = λ;
	    }
	    function lineStart() {
	      bound.point = linePoint;
	    }
	    function lineEnd() {
	      range[0] = λ0, range[1] = λ1;
	      bound.point = point;
	      p0 = null;
	    }
	    function ringPoint(λ, φ) {
	      if (p0) {
	        var dλ = λ - λ_;
	        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
	      } else λ__ = λ, φ__ = φ;
	      d3_geo_area.point(λ, φ);
	      linePoint(λ, φ);
	    }
	    function ringStart() {
	      d3_geo_area.lineStart();
	    }
	    function ringEnd() {
	      ringPoint(λ__, φ__);
	      d3_geo_area.lineEnd();
	      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
	      range[0] = λ0, range[1] = λ1;
	      p0 = null;
	    }
	    function angle(λ0, λ1) {
	      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
	    }
	    function compareRanges(a, b) {
	      return a[0] - b[0];
	    }
	    function withinRange(x, range) {
	      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	    }
	    return function(feature) {
	      φ1 = λ1 = -(λ0 = φ0 = Infinity);
	      ranges = [];
	      d3.geo.stream(feature, bound);
	      var n = ranges.length;
	      if (n) {
	        ranges.sort(compareRanges);
	        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
	          b = ranges[i];
	          if (withinRange(b[0], a) || withinRange(b[1], a)) {
	            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	          } else {
	            merged.push(a = b);
	          }
	        }
	        var best = -Infinity, dλ;
	        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
	          b = merged[i];
	          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
	        }
	      }
	      ranges = range = null;
	      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
	    };
	  }();
	  d3.geo.centroid = function(object) {
	    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	    d3.geo.stream(object, d3_geo_centroid);
	    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
	    if (m < ε2) {
	      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
	      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
	      m = x * x + y * y + z * z;
	      if (m < ε2) return [ NaN, NaN ];
	    }
	    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
	  };
	  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
	  var d3_geo_centroid = {
	    sphere: d3_noop,
	    point: d3_geo_centroidPoint,
	    lineStart: d3_geo_centroidLineStart,
	    lineEnd: d3_geo_centroidLineEnd,
	    polygonStart: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
	    }
	  };
	  function d3_geo_centroidPoint(λ, φ) {
	    λ *= d3_radians;
	    var cosφ = Math.cos(φ *= d3_radians);
	    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
	  }
	  function d3_geo_centroidPointXYZ(x, y, z) {
	    ++d3_geo_centroidW0;
	    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
	    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
	    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
	  }
	  function d3_geo_centroidLineStart() {
	    var x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroid.point = nextPoint;
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_centroidLineEnd() {
	    d3_geo_centroid.point = d3_geo_centroidPoint;
	  }
	  function d3_geo_centroidRingStart() {
	    var λ00, φ00, x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ00 = λ, φ00 = φ;
	      d3_geo_centroid.point = nextPoint;
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    d3_geo_centroid.lineEnd = function() {
	      nextPoint(λ00, φ00);
	      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
	      d3_geo_centroid.point = d3_geo_centroidPoint;
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
	      d3_geo_centroidX2 += v * cx;
	      d3_geo_centroidY2 += v * cy;
	      d3_geo_centroidZ2 += v * cz;
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_compose(a, b) {
	    function compose(x, y) {
	      return x = a(x, y), b(x[0], x[1]);
	    }
	    if (a.invert && b.invert) compose.invert = function(x, y) {
	      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	    };
	    return compose;
	  }
	  function d3_true() {
	    return true;
	  }
	  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
	    var subject = [], clip = [];
	    segments.forEach(function(segment) {
	      if ((n = segment.length - 1) <= 0) return;
	      var n, p0 = segment[0], p1 = segment[n];
	      if (d3_geo_sphericalEqual(p0, p1)) {
	        listener.lineStart();
	        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
	        listener.lineEnd();
	        return;
	      }
	      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
	      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	    });
	    clip.sort(compare);
	    d3_geo_clipPolygonLinkCircular(subject);
	    d3_geo_clipPolygonLinkCircular(clip);
	    if (!subject.length) return;
	    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
	      clip[i].e = entry = !entry;
	    }
	    var start = subject[0], points, point;
	    while (1) {
	      var current = start, isSubject = true;
	      while (current.v) if ((current = current.n) === start) return;
	      points = current.z;
	      listener.lineStart();
	      do {
	        current.v = current.o.v = true;
	        if (current.e) {
	          if (isSubject) {
	            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.n.x, 1, listener);
	          }
	          current = current.n;
	        } else {
	          if (isSubject) {
	            points = current.p.z;
	            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.p.x, -1, listener);
	          }
	          current = current.p;
	        }
	        current = current.o;
	        points = current.z;
	        isSubject = !isSubject;
	      } while (!current.v);
	      listener.lineEnd();
	    }
	  }
	  function d3_geo_clipPolygonLinkCircular(array) {
	    if (!(n = array.length)) return;
	    var n, i = 0, a = array[0], b;
	    while (++i < n) {
	      a.n = b = array[i];
	      b.p = a;
	      a = b;
	    }
	    a.n = b = array[0];
	    b.p = a;
	  }
	  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
	    this.x = point;
	    this.z = points;
	    this.o = other;
	    this.e = entry;
	    this.v = false;
	    this.n = this.p = null;
	  }
	  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
	    return function(rotate, listener) {
	      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          clip.point = pointRing;
	          clip.lineStart = ringStart;
	          clip.lineEnd = ringEnd;
	          segments = [];
	          polygon = [];
	        },
	        polygonEnd: function() {
	          clip.point = point;
	          clip.lineStart = lineStart;
	          clip.lineEnd = lineEnd;
	          segments = d3.merge(segments);
	          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
	          if (segments.length) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
	          } else if (clipStartInside) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            interpolate(null, null, 1, listener);
	            listener.lineEnd();
	          }
	          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
	          segments = polygon = null;
	        },
	        sphere: function() {
	          listener.polygonStart();
	          listener.lineStart();
	          interpolate(null, null, 1, listener);
	          listener.lineEnd();
	          listener.polygonEnd();
	        }
	      };
	      function point(λ, φ) {
	        var point = rotate(λ, φ);
	        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
	      }
	      function pointLine(λ, φ) {
	        var point = rotate(λ, φ);
	        line.point(point[0], point[1]);
	      }
	      function lineStart() {
	        clip.point = pointLine;
	        line.lineStart();
	      }
	      function lineEnd() {
	        clip.point = point;
	        line.lineEnd();
	      }
	      var segments;
	      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
	      function pointRing(λ, φ) {
	        ring.push([ λ, φ ]);
	        var point = rotate(λ, φ);
	        ringListener.point(point[0], point[1]);
	      }
	      function ringStart() {
	        ringListener.lineStart();
	        ring = [];
	      }
	      function ringEnd() {
	        pointRing(ring[0][0], ring[0][1]);
	        ringListener.lineEnd();
	        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
	        ring.pop();
	        polygon.push(ring);
	        ring = null;
	        if (!n) return;
	        if (clean & 1) {
	          segment = ringSegments[0];
	          var n = segment.length - 1, i = -1, point;
	          if (n > 0) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            while (++i < n) listener.point((point = segment[i])[0], point[1]);
	            listener.lineEnd();
	          }
	          return;
	        }
	        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
	        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
	      }
	      return clip;
	    };
	  }
	  function d3_geo_clipSegmentLength1(segment) {
	    return segment.length > 1;
	  }
	  function d3_geo_clipBufferListener() {
	    var lines = [], line;
	    return {
	      lineStart: function() {
	        lines.push(line = []);
	      },
	      point: function(λ, φ) {
	        line.push([ λ, φ ]);
	      },
	      lineEnd: d3_noop,
	      buffer: function() {
	        var buffer = lines;
	        lines = [];
	        line = null;
	        return buffer;
	      },
	      rejoin: function() {
	        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	      }
	    };
	  }
	  function d3_geo_clipSort(a, b) {
	    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
	  }
	  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
	  function d3_geo_clipAntimeridianLine(listener) {
	    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
	    return {
	      lineStart: function() {
	        listener.lineStart();
	        clean = 1;
	      },
	      point: function(λ1, φ1) {
	        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
	        if (abs(dλ - π) < ε) {
	          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          listener.point(λ1, φ0);
	          clean = 0;
	        } else if (sλ0 !== sλ1 && dλ >= π) {
	          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
	          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
	          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          clean = 0;
	        }
	        listener.point(λ0 = λ1, φ0 = φ1);
	        sλ0 = sλ1;
	      },
	      lineEnd: function() {
	        listener.lineEnd();
	        λ0 = φ0 = NaN;
	      },
	      clean: function() {
	        return 2 - clean;
	      }
	    };
	  }
	  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
	    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
	    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
	  }
	  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
	    var φ;
	    if (from == null) {
	      φ = direction * halfπ;
	      listener.point(-π, φ);
	      listener.point(0, φ);
	      listener.point(π, φ);
	      listener.point(π, 0);
	      listener.point(π, -φ);
	      listener.point(0, -φ);
	      listener.point(-π, -φ);
	      listener.point(-π, 0);
	      listener.point(-π, φ);
	    } else if (abs(from[0] - to[0]) > ε) {
	      var s = from[0] < to[0] ? π : -π;
	      φ = direction * s / 2;
	      listener.point(-s, φ);
	      listener.point(0, φ);
	      listener.point(s, φ);
	    } else {
	      listener.point(to[0], to[1]);
	    }
	  }
	  function d3_geo_pointInPolygon(point, polygon) {
	    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
	    d3_geo_areaRingSum.reset();
	    for (var i = 0, n = polygon.length; i < n; ++i) {
	      var ring = polygon[i], m = ring.length;
	      if (!m) continue;
	      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
	      while (true) {
	        if (j === m) j = 0;
	        point = ring[j];
	        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
	        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
	        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
	        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
	          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
	          d3_geo_cartesianNormalize(arc);
	          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
	          d3_geo_cartesianNormalize(intersection);
	          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
	          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
	            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
	          }
	        }
	        if (!j++) break;
	        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
	      }
	    }
	    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
	  }
	  function d3_geo_clipCircle(radius) {
	    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
	    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
	    function visible(λ, φ) {
	      return Math.cos(λ) * Math.cos(φ) > cr;
	    }
	    function clipLine(listener) {
	      var point0, c0, v0, v00, clean;
	      return {
	        lineStart: function() {
	          v00 = v0 = false;
	          clean = 1;
	        },
	        point: function(λ, φ) {
	          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
	          if (!point0 && (v00 = v0 = v)) listener.lineStart();
	          if (v !== v0) {
	            point2 = intersect(point0, point1);
	            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
	              point1[0] += ε;
	              point1[1] += ε;
	              v = visible(point1[0], point1[1]);
	            }
	          }
	          if (v !== v0) {
	            clean = 0;
	            if (v) {
	              listener.lineStart();
	              point2 = intersect(point1, point0);
	              listener.point(point2[0], point2[1]);
	            } else {
	              point2 = intersect(point0, point1);
	              listener.point(point2[0], point2[1]);
	              listener.lineEnd();
	            }
	            point0 = point2;
	          } else if (notHemisphere && point0 && smallRadius ^ v) {
	            var t;
	            if (!(c & c0) && (t = intersect(point1, point0, true))) {
	              clean = 0;
	              if (smallRadius) {
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	              } else {
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	              }
	            }
	          }
	          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
	            listener.point(point1[0], point1[1]);
	          }
	          point0 = point1, v0 = v, c0 = c;
	        },
	        lineEnd: function() {
	          if (v0) listener.lineEnd();
	          point0 = null;
	        },
	        clean: function() {
	          return clean | (v00 && v0) << 1;
	        }
	      };
	    }
	    function intersect(a, b, two) {
	      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
	      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
	      if (!determinant) return !two && a;
	      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
	      d3_geo_cartesianAdd(A, B);
	      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
	      if (t2 < 0) return;
	      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
	      d3_geo_cartesianAdd(q, A);
	      q = d3_geo_spherical(q);
	      if (!two) return q;
	      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
	      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
	      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
	      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
	      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
	        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
	        d3_geo_cartesianAdd(q1, A);
	        return [ q, d3_geo_spherical(q1) ];
	      }
	    }
	    function code(λ, φ) {
	      var r = smallRadius ? radius : π - radius, code = 0;
	      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
	      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
	      return code;
	    }
	  }
	  function d3_geom_clipLine(x0, y0, x1, y1) {
	    return function(line) {
	      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
	      r = x0 - ax;
	      if (!dx && r > 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dx > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = x1 - ax;
	      if (!dx && r < 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dx > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      r = y0 - ay;
	      if (!dy && r > 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dy > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = y1 - ay;
	      if (!dy && r < 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dy > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      if (t0 > 0) line.a = {
	        x: ax + t0 * dx,
	        y: ay + t0 * dy
	      };
	      if (t1 < 1) line.b = {
	        x: ax + t1 * dx,
	        y: ay + t1 * dy
	      };
	      return line;
	    };
	  }
	  var d3_geo_clipExtentMAX = 1e9;
	  d3.geo.clipExtent = function() {
	    var x0, y0, x1, y1, stream, clip, clipExtent = {
	      stream: function(output) {
	        if (stream) stream.valid = false;
	        stream = clip(output);
	        stream.valid = true;
	        return stream;
	      },
	      extent: function(_) {
	        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
	        if (stream) stream.valid = false, stream = null;
	        return clipExtent;
	      }
	    };
	    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
	  };
	  function d3_geo_clipExtent(x0, y0, x1, y1) {
	    return function(listener) {
	      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          listener = bufferListener;
	          segments = [];
	          polygon = [];
	          clean = true;
	        },
	        polygonEnd: function() {
	          listener = listener_;
	          segments = d3.merge(segments);
	          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
	          if (inside || visible) {
	            listener.polygonStart();
	            if (inside) {
	              listener.lineStart();
	              interpolate(null, null, 1, listener);
	              listener.lineEnd();
	            }
	            if (visible) {
	              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
	            }
	            listener.polygonEnd();
	          }
	          segments = polygon = ring = null;
	        }
	      };
	      function insidePolygon(p) {
	        var wn = 0, n = polygon.length, y = p[1];
	        for (var i = 0; i < n; ++i) {
	          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
	            b = v[j];
	            if (a[1] <= y) {
	              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
	            } else {
	              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
	            }
	            a = b;
	          }
	        }
	        return wn !== 0;
	      }
	      function interpolate(from, to, direction, listener) {
	        var a = 0, a1 = 0;
	        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
	          do {
	            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	          } while ((a = (a + direction + 4) % 4) !== a1);
	        } else {
	          listener.point(to[0], to[1]);
	        }
	      }
	      function pointVisible(x, y) {
	        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	      }
	      function point(x, y) {
	        if (pointVisible(x, y)) listener.point(x, y);
	      }
	      var x__, y__, v__, x_, y_, v_, first, clean;
	      function lineStart() {
	        clip.point = linePoint;
	        if (polygon) polygon.push(ring = []);
	        first = true;
	        v_ = false;
	        x_ = y_ = NaN;
	      }
	      function lineEnd() {
	        if (segments) {
	          linePoint(x__, y__);
	          if (v__ && v_) bufferListener.rejoin();
	          segments.push(bufferListener.buffer());
	        }
	        clip.point = point;
	        if (v_) listener.lineEnd();
	      }
	      function linePoint(x, y) {
	        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
	        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
	        var v = pointVisible(x, y);
	        if (polygon) ring.push([ x, y ]);
	        if (first) {
	          x__ = x, y__ = y, v__ = v;
	          first = false;
	          if (v) {
	            listener.lineStart();
	            listener.point(x, y);
	          }
	        } else {
	          if (v && v_) listener.point(x, y); else {
	            var l = {
	              a: {
	                x: x_,
	                y: y_
	              },
	              b: {
	                x: x,
	                y: y
	              }
	            };
	            if (clipLine(l)) {
	              if (!v_) {
	                listener.lineStart();
	                listener.point(l.a.x, l.a.y);
	              }
	              listener.point(l.b.x, l.b.y);
	              if (!v) listener.lineEnd();
	              clean = false;
	            } else if (v) {
	              listener.lineStart();
	              listener.point(x, y);
	              clean = false;
	            }
	          }
	        }
	        x_ = x, y_ = y, v_ = v;
	      }
	      return clip;
	    };
	    function corner(p, direction) {
	      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
	    }
	    function compare(a, b) {
	      return comparePoints(a.x, b.x);
	    }
	    function comparePoints(a, b) {
	      var ca = corner(a, 1), cb = corner(b, 1);
	      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
	    }
	  }
	  function d3_geo_conic(projectAt) {
	    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
	    p.parallels = function(_) {
	      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
	      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
	    };
	    return p;
	  }
	  function d3_geo_conicEqualArea(φ0, φ1) {
	    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
	    function forward(λ, φ) {
	      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
	      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = ρ0 - y;
	      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEqualArea = function() {
	    return d3_geo_conic(d3_geo_conicEqualArea);
	  }).raw = d3_geo_conicEqualArea;
	  d3.geo.albers = function() {
	    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
	  };
	  d3.geo.albersUsa = function() {
	    var lower48 = d3.geo.albers();
	    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
	    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
	    var point, pointStream = {
	      point: function(x, y) {
	        point = [ x, y ];
	      }
	    }, lower48Point, alaskaPoint, hawaiiPoint;
	    function albersUsa(coordinates) {
	      var x = coordinates[0], y = coordinates[1];
	      point = null;
	      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
	      return point;
	    }
	    albersUsa.invert = function(coordinates) {
	      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
	      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
	    };
	    albersUsa.stream = function(stream) {
	      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
	      return {
	        point: function(x, y) {
	          lower48Stream.point(x, y);
	          alaskaStream.point(x, y);
	          hawaiiStream.point(x, y);
	        },
	        sphere: function() {
	          lower48Stream.sphere();
	          alaskaStream.sphere();
	          hawaiiStream.sphere();
	        },
	        lineStart: function() {
	          lower48Stream.lineStart();
	          alaskaStream.lineStart();
	          hawaiiStream.lineStart();
	        },
	        lineEnd: function() {
	          lower48Stream.lineEnd();
	          alaskaStream.lineEnd();
	          hawaiiStream.lineEnd();
	        },
	        polygonStart: function() {
	          lower48Stream.polygonStart();
	          alaskaStream.polygonStart();
	          hawaiiStream.polygonStart();
	        },
	        polygonEnd: function() {
	          lower48Stream.polygonEnd();
	          alaskaStream.polygonEnd();
	          hawaiiStream.polygonEnd();
	        }
	      };
	    };
	    albersUsa.precision = function(_) {
	      if (!arguments.length) return lower48.precision();
	      lower48.precision(_);
	      alaska.precision(_);
	      hawaii.precision(_);
	      return albersUsa;
	    };
	    albersUsa.scale = function(_) {
	      if (!arguments.length) return lower48.scale();
	      lower48.scale(_);
	      alaska.scale(_ * .35);
	      hawaii.scale(_);
	      return albersUsa.translate(lower48.translate());
	    };
	    albersUsa.translate = function(_) {
	      if (!arguments.length) return lower48.translate();
	      var k = lower48.scale(), x = +_[0], y = +_[1];
	      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
	      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      return albersUsa;
	    };
	    return albersUsa.scale(1070);
	  };
	  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_pathAreaPolygon = 0;
	      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
	      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
	    }
	  };
	  function d3_geo_pathAreaRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathArea.point = function(x, y) {
	      d3_geo_pathArea.point = nextPoint;
	      x00 = x0 = x, y00 = y0 = y;
	    };
	    function nextPoint(x, y) {
	      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
	      x0 = x, y0 = y;
	    }
	    d3_geo_pathArea.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
	  var d3_geo_pathBounds = {
	    point: d3_geo_pathBoundsPoint,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_pathBoundsPoint(x, y) {
	    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
	    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
	    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
	    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
	  }
	  function d3_geo_pathBuffer() {
	    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointCircle = d3_geo_pathBufferCircle(_);
	        return stream;
	      },
	      result: function() {
	        if (buffer.length) {
	          var result = buffer.join("");
	          buffer = [];
	          return result;
	        }
	      }
	    };
	    function point(x, y) {
	      buffer.push("M", x, ",", y, pointCircle);
	    }
	    function pointLineStart(x, y) {
	      buffer.push("M", x, ",", y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      buffer.push("L", x, ",", y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      buffer.push("Z");
	    }
	    return stream;
	  }
	  function d3_geo_pathBufferCircle(radius) {
	    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
	  }
	  var d3_geo_pathCentroid = {
	    point: d3_geo_pathCentroidPoint,
	    lineStart: d3_geo_pathCentroidLineStart,
	    lineEnd: d3_geo_pathCentroidLineEnd,
	    polygonStart: function() {
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
	      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
	    }
	  };
	  function d3_geo_pathCentroidPoint(x, y) {
	    d3_geo_centroidX0 += x;
	    d3_geo_centroidY0 += y;
	    ++d3_geo_centroidZ0;
	  }
	  function d3_geo_pathCentroidLineStart() {
	    var x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	  }
	  function d3_geo_pathCentroidLineEnd() {
	    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	  }
	  function d3_geo_pathCentroidRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      z = y0 * x - x0 * y;
	      d3_geo_centroidX2 += z * (x0 + x);
	      d3_geo_centroidY2 += z * (y0 + y);
	      d3_geo_centroidZ2 += z * 3;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	    d3_geo_pathCentroid.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  function d3_geo_pathContext(context) {
	    var pointRadius = 4.5;
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointRadius = _;
	        return stream;
	      },
	      result: d3_noop
	    };
	    function point(x, y) {
	      context.moveTo(x + pointRadius, y);
	      context.arc(x, y, pointRadius, 0, τ);
	    }
	    function pointLineStart(x, y) {
	      context.moveTo(x, y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      context.lineTo(x, y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      context.closePath();
	    }
	    return stream;
	  }
	  function d3_geo_resample(project) {
	    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
	    function resample(stream) {
	      return (maxDepth ? resampleRecursive : resampleNone)(stream);
	    }
	    function resampleNone(stream) {
	      return d3_geo_transformPoint(stream, function(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      });
	    }
	    function resampleRecursive(stream) {
	      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
	      var resample = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          stream.polygonStart();
	          resample.lineStart = ringStart;
	        },
	        polygonEnd: function() {
	          stream.polygonEnd();
	          resample.lineStart = lineStart;
	        }
	      };
	      function point(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      }
	      function lineStart() {
	        x0 = NaN;
	        resample.point = linePoint;
	        stream.lineStart();
	      }
	      function linePoint(λ, φ) {
	        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	        stream.point(x0, y0);
	      }
	      function lineEnd() {
	        resample.point = point;
	        stream.lineEnd();
	      }
	      function ringStart() {
	        lineStart();
	        resample.point = ringPoint;
	        resample.lineEnd = ringEnd;
	      }
	      function ringPoint(λ, φ) {
	        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	        resample.point = linePoint;
	      }
	      function ringEnd() {
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
	        resample.lineEnd = lineEnd;
	        lineEnd();
	      }
	      return resample;
	    }
	    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
	      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
	      if (d2 > 4 * δ2 && depth--) {
	        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
	        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
	          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
	          stream.point(x2, y2);
	          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
	        }
	      }
	    }
	    resample.precision = function(_) {
	      if (!arguments.length) return Math.sqrt(δ2);
	      maxDepth = (δ2 = _ * _) > 0 && 16;
	      return resample;
	    };
	    return resample;
	  }
	  d3.geo.path = function() {
	    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
	    function path(object) {
	      if (object) {
	        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
	        d3.geo.stream(object, cacheStream);
	      }
	      return contextStream.result();
	    }
	    path.area = function(object) {
	      d3_geo_pathAreaSum = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathArea));
	      return d3_geo_pathAreaSum;
	    };
	    path.centroid = function(object) {
	      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
	      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
	    };
	    path.bounds = function(object) {
	      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
	      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
	      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
	    };
	    path.projection = function(_) {
	      if (!arguments.length) return projection;
	      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
	      return reset();
	    };
	    path.context = function(_) {
	      if (!arguments.length) return context;
	      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
	      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	      return reset();
	    };
	    path.pointRadius = function(_) {
	      if (!arguments.length) return pointRadius;
	      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	      return path;
	    };
	    function reset() {
	      cacheStream = null;
	      return path;
	    }
	    return path.projection(d3.geo.albersUsa()).context(null);
	  };
	  function d3_geo_pathProjectStream(project) {
	    var resample = d3_geo_resample(function(x, y) {
	      return project([ x * d3_degrees, y * d3_degrees ]);
	    });
	    return function(stream) {
	      return d3_geo_projectionRadians(resample(stream));
	    };
	  }
	  d3.geo.transform = function(methods) {
	    return {
	      stream: function(stream) {
	        var transform = new d3_geo_transform(stream);
	        for (var k in methods) transform[k] = methods[k];
	        return transform;
	      }
	    };
	  };
	  function d3_geo_transform(stream) {
	    this.stream = stream;
	  }
	  d3_geo_transform.prototype = {
	    point: function(x, y) {
	      this.stream.point(x, y);
	    },
	    sphere: function() {
	      this.stream.sphere();
	    },
	    lineStart: function() {
	      this.stream.lineStart();
	    },
	    lineEnd: function() {
	      this.stream.lineEnd();
	    },
	    polygonStart: function() {
	      this.stream.polygonStart();
	    },
	    polygonEnd: function() {
	      this.stream.polygonEnd();
	    }
	  };
	  function d3_geo_transformPoint(stream, point) {
	    return {
	      point: point,
	      sphere: function() {
	        stream.sphere();
	      },
	      lineStart: function() {
	        stream.lineStart();
	      },
	      lineEnd: function() {
	        stream.lineEnd();
	      },
	      polygonStart: function() {
	        stream.polygonStart();
	      },
	      polygonEnd: function() {
	        stream.polygonEnd();
	      }
	    };
	  }
	  d3.geo.projection = d3_geo_projection;
	  d3.geo.projectionMutator = d3_geo_projectionMutator;
	  function d3_geo_projection(project) {
	    return d3_geo_projectionMutator(function() {
	      return project;
	    })();
	  }
	  function d3_geo_projectionMutator(projectAt) {
	    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
	      x = project(x, y);
	      return [ x[0] * k + δx, δy - x[1] * k ];
	    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
	    function projection(point) {
	      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
	      return [ point[0] * k + δx, δy - point[1] * k ];
	    }
	    function invert(point) {
	      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
	      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
	    }
	    projection.stream = function(output) {
	      if (stream) stream.valid = false;
	      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
	      stream.valid = true;
	      return stream;
	    };
	    projection.clipAngle = function(_) {
	      if (!arguments.length) return clipAngle;
	      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
	      return invalidate();
	    };
	    projection.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent;
	      clipExtent = _;
	      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
	      return invalidate();
	    };
	    projection.scale = function(_) {
	      if (!arguments.length) return k;
	      k = +_;
	      return reset();
	    };
	    projection.translate = function(_) {
	      if (!arguments.length) return [ x, y ];
	      x = +_[0];
	      y = +_[1];
	      return reset();
	    };
	    projection.center = function(_) {
	      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
	      λ = _[0] % 360 * d3_radians;
	      φ = _[1] % 360 * d3_radians;
	      return reset();
	    };
	    projection.rotate = function(_) {
	      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
	      δλ = _[0] % 360 * d3_radians;
	      δφ = _[1] % 360 * d3_radians;
	      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
	      return reset();
	    };
	    d3.rebind(projection, projectResample, "precision");
	    function reset() {
	      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
	      var center = project(λ, φ);
	      δx = x - center[0] * k;
	      δy = y + center[1] * k;
	      return invalidate();
	    }
	    function invalidate() {
	      if (stream) stream.valid = false, stream = null;
	      return projection;
	    }
	    return function() {
	      project = projectAt.apply(this, arguments);
	      projection.invert = project.invert && invert;
	      return reset();
	    };
	  }
	  function d3_geo_projectionRadians(stream) {
	    return d3_geo_transformPoint(stream, function(x, y) {
	      stream.point(x * d3_radians, y * d3_radians);
	    });
	  }
	  function d3_geo_equirectangular(λ, φ) {
	    return [ λ, φ ];
	  }
	  (d3.geo.equirectangular = function() {
	    return d3_geo_projection(d3_geo_equirectangular);
	  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
	  d3.geo.rotation = function(rotate) {
	    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
	    function forward(coordinates) {
	      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    }
	    forward.invert = function(coordinates) {
	      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    };
	    return forward;
	  };
	  function d3_geo_identityRotation(λ, φ) {
	    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	  }
	  d3_geo_identityRotation.invert = d3_geo_equirectangular;
	  function d3_geo_rotation(δλ, δφ, δγ) {
	    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
	  }
	  function d3_geo_forwardRotationλ(δλ) {
	    return function(λ, φ) {
	      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	    };
	  }
	  function d3_geo_rotationλ(δλ) {
	    var rotation = d3_geo_forwardRotationλ(δλ);
	    rotation.invert = d3_geo_forwardRotationλ(-δλ);
	    return rotation;
	  }
	  function d3_geo_rotationφγ(δφ, δγ) {
	    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
	    function rotation(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
	      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
	    }
	    rotation.invert = function(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
	      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
	    };
	    return rotation;
	  }
	  d3.geo.circle = function() {
	    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
	    function circle() {
	      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
	      interpolate(null, null, 1, {
	        point: function(x, y) {
	          ring.push(x = rotate(x, y));
	          x[0] *= d3_degrees, x[1] *= d3_degrees;
	        }
	      });
	      return {
	        type: "Polygon",
	        coordinates: [ ring ]
	      };
	    }
	    circle.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return circle;
	    };
	    circle.angle = function(x) {
	      if (!arguments.length) return angle;
	      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
	      return circle;
	    };
	    circle.precision = function(_) {
	      if (!arguments.length) return precision;
	      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
	      return circle;
	    };
	    return circle.angle(90);
	  };
	  function d3_geo_circleInterpolate(radius, precision) {
	    var cr = Math.cos(radius), sr = Math.sin(radius);
	    return function(from, to, direction, listener) {
	      var step = direction * precision;
	      if (from != null) {
	        from = d3_geo_circleAngle(cr, from);
	        to = d3_geo_circleAngle(cr, to);
	        if (direction > 0 ? from < to : from > to) from += direction * τ;
	      } else {
	        from = radius + direction * τ;
	        to = radius - .5 * step;
	      }
	      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
	        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
	      }
	    };
	  }
	  function d3_geo_circleAngle(cr, point) {
	    var a = d3_geo_cartesian(point);
	    a[0] -= cr;
	    d3_geo_cartesianNormalize(a);
	    var angle = d3_acos(-a[1]);
	    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
	  }
	  d3.geo.distance = function(a, b) {
	    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
	    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
	  };
	  d3.geo.graticule = function() {
	    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
	    function graticule() {
	      return {
	        type: "MultiLineString",
	        coordinates: lines()
	      };
	    }
	    function lines() {
	      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
	        return abs(x % DX) > ε;
	      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
	        return abs(y % DY) > ε;
	      }).map(y));
	    }
	    graticule.lines = function() {
	      return lines().map(function(coordinates) {
	        return {
	          type: "LineString",
	          coordinates: coordinates
	        };
	      });
	    };
	    graticule.outline = function() {
	      return {
	        type: "Polygon",
	        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
	      };
	    };
	    graticule.extent = function(_) {
	      if (!arguments.length) return graticule.minorExtent();
	      return graticule.majorExtent(_).minorExtent(_);
	    };
	    graticule.majorExtent = function(_) {
	      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
	      X0 = +_[0][0], X1 = +_[1][0];
	      Y0 = +_[0][1], Y1 = +_[1][1];
	      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.minorExtent = function(_) {
	      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	      x0 = +_[0][0], x1 = +_[1][0];
	      y0 = +_[0][1], y1 = +_[1][1];
	      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.step = function(_) {
	      if (!arguments.length) return graticule.minorStep();
	      return graticule.majorStep(_).minorStep(_);
	    };
	    graticule.majorStep = function(_) {
	      if (!arguments.length) return [ DX, DY ];
	      DX = +_[0], DY = +_[1];
	      return graticule;
	    };
	    graticule.minorStep = function(_) {
	      if (!arguments.length) return [ dx, dy ];
	      dx = +_[0], dy = +_[1];
	      return graticule;
	    };
	    graticule.precision = function(_) {
	      if (!arguments.length) return precision;
	      precision = +_;
	      x = d3_geo_graticuleX(y0, y1, 90);
	      y = d3_geo_graticuleY(x0, x1, precision);
	      X = d3_geo_graticuleX(Y0, Y1, 90);
	      Y = d3_geo_graticuleY(X0, X1, precision);
	      return graticule;
	    };
	    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
	  };
	  function d3_geo_graticuleX(y0, y1, dy) {
	    var y = d3.range(y0, y1 - ε, dy).concat(y1);
	    return function(x) {
	      return y.map(function(y) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_geo_graticuleY(x0, x1, dx) {
	    var x = d3.range(x0, x1 - ε, dx).concat(x1);
	    return function(y) {
	      return x.map(function(x) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_source(d) {
	    return d.source;
	  }
	  function d3_target(d) {
	    return d.target;
	  }
	  d3.geo.greatArc = function() {
	    var source = d3_source, source_, target = d3_target, target_;
	    function greatArc() {
	      return {
	        type: "LineString",
	        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
	      };
	    }
	    greatArc.distance = function() {
	      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
	    };
	    greatArc.source = function(_) {
	      if (!arguments.length) return source;
	      source = _, source_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.target = function(_) {
	      if (!arguments.length) return target;
	      target = _, target_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.precision = function() {
	      return arguments.length ? greatArc : 0;
	    };
	    return greatArc;
	  };
	  d3.geo.interpolate = function(source, target) {
	    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
	  };
	  function d3_geo_interpolate(x0, y0, x1, y1) {
	    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
	    var interpolate = d ? function(t) {
	      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
	      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
	    } : function() {
	      return [ x0 * d3_degrees, y0 * d3_degrees ];
	    };
	    interpolate.distance = d;
	    return interpolate;
	  }
	  d3.geo.length = function(object) {
	    d3_geo_lengthSum = 0;
	    d3.geo.stream(object, d3_geo_length);
	    return d3_geo_lengthSum;
	  };
	  var d3_geo_lengthSum;
	  var d3_geo_length = {
	    sphere: d3_noop,
	    point: d3_noop,
	    lineStart: d3_geo_lengthLineStart,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_lengthLineStart() {
	    var λ0, sinφ0, cosφ0;
	    d3_geo_length.point = function(λ, φ) {
	      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
	      d3_geo_length.point = nextPoint;
	    };
	    d3_geo_length.lineEnd = function() {
	      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
	    };
	    function nextPoint(λ, φ) {
	      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
	      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
	      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
	    }
	  }
	  function d3_geo_azimuthal(scale, angle) {
	    function azimuthal(λ, φ) {
	      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
	      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
	    }
	    azimuthal.invert = function(x, y) {
	      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
	      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
	    };
	    return azimuthal;
	  }
	  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
	    return Math.sqrt(2 / (1 + cosλcosφ));
	  }, function(ρ) {
	    return 2 * Math.asin(ρ / 2);
	  });
	  (d3.geo.azimuthalEqualArea = function() {
	    return d3_geo_projection(d3_geo_azimuthalEqualArea);
	  }).raw = d3_geo_azimuthalEqualArea;
	  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
	    var c = Math.acos(cosλcosφ);
	    return c && c / Math.sin(c);
	  }, d3_identity);
	  (d3.geo.azimuthalEquidistant = function() {
	    return d3_geo_projection(d3_geo_azimuthalEquidistant);
	  }).raw = d3_geo_azimuthalEquidistant;
	  function d3_geo_conicConformal(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), t = function(φ) {
	      return Math.tan(π / 4 + φ / 2);
	    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
	    if (!n) return d3_geo_mercator;
	    function forward(λ, φ) {
	      if (F > 0) {
	        if (φ < -halfπ + ε) φ = -halfπ + ε;
	      } else {
	        if (φ > halfπ - ε) φ = halfπ - ε;
	      }
	      var ρ = F / Math.pow(t(φ), n);
	      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
	      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
	    };
	    return forward;
	  }
	  (d3.geo.conicConformal = function() {
	    return d3_geo_conic(d3_geo_conicConformal);
	  }).raw = d3_geo_conicConformal;
	  function d3_geo_conicEquidistant(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
	    if (abs(n) < ε) return d3_geo_equirectangular;
	    function forward(λ, φ) {
	      var ρ = G - φ;
	      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = G - y;
	      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEquidistant = function() {
	    return d3_geo_conic(d3_geo_conicEquidistant);
	  }).raw = d3_geo_conicEquidistant;
	  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / cosλcosφ;
	  }, Math.atan);
	  (d3.geo.gnomonic = function() {
	    return d3_geo_projection(d3_geo_gnomonic);
	  }).raw = d3_geo_gnomonic;
	  function d3_geo_mercator(λ, φ) {
	    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
	  }
	  d3_geo_mercator.invert = function(x, y) {
	    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
	  };
	  function d3_geo_mercatorProjection(project) {
	    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
	    m.scale = function() {
	      var v = scale.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.translate = function() {
	      var v = translate.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.clipExtent = function(_) {
	      var v = clipExtent.apply(m, arguments);
	      if (v === m) {
	        if (clipAuto = _ == null) {
	          var k = π * scale(), t = translate();
	          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
	        }
	      } else if (clipAuto) {
	        v = null;
	      }
	      return v;
	    };
	    return m.clipExtent(null);
	  }
	  (d3.geo.mercator = function() {
	    return d3_geo_mercatorProjection(d3_geo_mercator);
	  }).raw = d3_geo_mercator;
	  var d3_geo_orthographic = d3_geo_azimuthal(function() {
	    return 1;
	  }, Math.asin);
	  (d3.geo.orthographic = function() {
	    return d3_geo_projection(d3_geo_orthographic);
	  }).raw = d3_geo_orthographic;
	  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / (1 + cosλcosφ);
	  }, function(ρ) {
	    return 2 * Math.atan(ρ);
	  });
	  (d3.geo.stereographic = function() {
	    return d3_geo_projection(d3_geo_stereographic);
	  }).raw = d3_geo_stereographic;
	  function d3_geo_transverseMercator(λ, φ) {
	    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
	  }
	  d3_geo_transverseMercator.invert = function(x, y) {
	    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
	  };
	  (d3.geo.transverseMercator = function() {
	    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
	    projection.center = function(_) {
	      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
	    };
	    projection.rotate = function(_) {
	      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
	      [ _[0], _[1], _[2] - 90 ]);
	    };
	    return rotate([ 0, 0, 90 ]);
	  }).raw = d3_geo_transverseMercator;
	  d3.geom = {};
	  function d3_geom_pointX(d) {
	    return d[0];
	  }
	  function d3_geom_pointY(d) {
	    return d[1];
	  }
	  d3.geom.hull = function(vertices) {
	    var x = d3_geom_pointX, y = d3_geom_pointY;
	    if (arguments.length) return hull(vertices);
	    function hull(data) {
	      if (data.length < 3) return [];
	      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
	      for (i = 0; i < n; i++) {
	        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
	      }
	      points.sort(d3_geom_hullOrder);
	      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
	      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
	      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
	      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
	      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
	      return polygon;
	    }
	    hull.x = function(_) {
	      return arguments.length ? (x = _, hull) : x;
	    };
	    hull.y = function(_) {
	      return arguments.length ? (y = _, hull) : y;
	    };
	    return hull;
	  };
	  function d3_geom_hullUpper(points) {
	    var n = points.length, hull = [ 0, 1 ], hs = 2;
	    for (var i = 2; i < n; i++) {
	      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
	      hull[hs++] = i;
	    }
	    return hull.slice(0, hs);
	  }
	  function d3_geom_hullOrder(a, b) {
	    return a[0] - b[0] || a[1] - b[1];
	  }
	  d3.geom.polygon = function(coordinates) {
	    d3_subclass(coordinates, d3_geom_polygonPrototype);
	    return coordinates;
	  };
	  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
	  d3_geom_polygonPrototype.area = function() {
	    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      area += a[1] * b[0] - a[0] * b[1];
	    }
	    return area * .5;
	  };
	  d3_geom_polygonPrototype.centroid = function(k) {
	    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
	    if (!arguments.length) k = -1 / (6 * this.area());
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      c = a[0] * b[1] - b[0] * a[1];
	      x += (a[0] + b[0]) * c;
	      y += (a[1] + b[1]) * c;
	    }
	    return [ x * k, y * k ];
	  };
	  d3_geom_polygonPrototype.clip = function(subject) {
	    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
	    while (++i < n) {
	      input = subject.slice();
	      subject.length = 0;
	      b = this[i];
	      c = input[(m = input.length - closed) - 1];
	      j = -1;
	      while (++j < m) {
	        d = input[j];
	        if (d3_geom_polygonInside(d, a, b)) {
	          if (!d3_geom_polygonInside(c, a, b)) {
	            subject.push(d3_geom_polygonIntersect(c, d, a, b));
	          }
	          subject.push(d);
	        } else if (d3_geom_polygonInside(c, a, b)) {
	          subject.push(d3_geom_polygonIntersect(c, d, a, b));
	        }
	        c = d;
	      }
	      if (closed) subject.push(subject[0]);
	      a = b;
	    }
	    return subject;
	  };
	  function d3_geom_polygonInside(p, a, b) {
	    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
	  }
	  function d3_geom_polygonIntersect(c, d, a, b) {
	    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
	    return [ x1 + ua * x21, y1 + ua * y21 ];
	  }
	  function d3_geom_polygonClosed(coordinates) {
	    var a = coordinates[0], b = coordinates[coordinates.length - 1];
	    return !(a[0] - b[0] || a[1] - b[1]);
	  }
	  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
	  function d3_geom_voronoiBeach() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.edge = this.site = this.circle = null;
	  }
	  function d3_geom_voronoiCreateBeach(site) {
	    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
	    beach.site = site;
	    return beach;
	  }
	  function d3_geom_voronoiDetachBeach(beach) {
	    d3_geom_voronoiDetachCircle(beach);
	    d3_geom_voronoiBeaches.remove(beach);
	    d3_geom_voronoiBeachPool.push(beach);
	    d3_geom_voronoiRedBlackNode(beach);
	  }
	  function d3_geom_voronoiRemoveBeach(beach) {
	    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
	      x: x,
	      y: y
	    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
	    d3_geom_voronoiDetachBeach(beach);
	    var lArc = previous;
	    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
	      previous = lArc.P;
	      disappearing.unshift(lArc);
	      d3_geom_voronoiDetachBeach(lArc);
	      lArc = previous;
	    }
	    disappearing.unshift(lArc);
	    d3_geom_voronoiDetachCircle(lArc);
	    var rArc = next;
	    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
	      next = rArc.N;
	      disappearing.push(rArc);
	      d3_geom_voronoiDetachBeach(rArc);
	      rArc = next;
	    }
	    disappearing.push(rArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var nArcs = disappearing.length, iArc;
	    for (iArc = 1; iArc < nArcs; ++iArc) {
	      rArc = disappearing[iArc];
	      lArc = disappearing[iArc - 1];
	      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	    }
	    lArc = disappearing[0];
	    rArc = disappearing[nArcs - 1];
	    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiAddBeach(site) {
	    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
	    while (node) {
	      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
	      if (dxl > ε) node = node.L; else {
	        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
	        if (dxr > ε) {
	          if (!node.R) {
	            lArc = node;
	            break;
	          }
	          node = node.R;
	        } else {
	          if (dxl > -ε) {
	            lArc = node.P;
	            rArc = node;
	          } else if (dxr > -ε) {
	            lArc = node;
	            rArc = node.N;
	          } else {
	            lArc = rArc = node;
	          }
	          break;
	        }
	      }
	    }
	    var newArc = d3_geom_voronoiCreateBeach(site);
	    d3_geom_voronoiBeaches.insert(lArc, newArc);
	    if (!lArc && !rArc) return;
	    if (lArc === rArc) {
	      d3_geom_voronoiDetachCircle(lArc);
	      rArc = d3_geom_voronoiCreateBeach(lArc.site);
	      d3_geom_voronoiBeaches.insert(newArc, rArc);
	      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      d3_geom_voronoiAttachCircle(lArc);
	      d3_geom_voronoiAttachCircle(rArc);
	      return;
	    }
	    if (!rArc) {
	      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      return;
	    }
	    d3_geom_voronoiDetachCircle(lArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
	      x: (cy * hb - by * hc) / d + ax,
	      y: (bx * hc - cx * hb) / d + ay
	    };
	    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
	    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
	    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
	    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
	    if (!pby2) return rfocx;
	    var lArc = arc.P;
	    if (!lArc) return -Infinity;
	    site = lArc.site;
	    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
	    if (!plby2) return lfocx;
	    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
	    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
	    return (rfocx + lfocx) / 2;
	  }
	  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
	    var rArc = arc.N;
	    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
	    var site = arc.site;
	    return site.y === directrix ? site.x : Infinity;
	  }
	  function d3_geom_voronoiCell(site) {
	    this.site = site;
	    this.edges = [];
	  }
	  d3_geom_voronoiCell.prototype.prepare = function() {
	    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
	    while (iHalfEdge--) {
	      edge = halfEdges[iHalfEdge].edge;
	      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
	    }
	    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
	    return halfEdges.length;
	  };
	  function d3_geom_voronoiCloseCells(extent) {
	    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
	    while (iCell--) {
	      cell = cells[iCell];
	      if (!cell || !cell.prepare()) continue;
	      halfEdges = cell.edges;
	      nHalfEdges = halfEdges.length;
	      iHalfEdge = 0;
	      while (iHalfEdge < nHalfEdges) {
	        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
	        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
	        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
	          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
	            x: x0,
	            y: abs(x2 - x0) < ε ? y2 : y1
	          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
	            x: abs(y2 - y1) < ε ? x2 : x1,
	            y: y1
	          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
	            x: x1,
	            y: abs(x2 - x1) < ε ? y2 : y0
	          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
	            x: abs(y2 - y0) < ε ? x2 : x0,
	            y: y0
	          } : null), cell.site, null));
	          ++nHalfEdges;
	        }
	      }
	    }
	  }
	  function d3_geom_voronoiHalfEdgeOrder(a, b) {
	    return b.angle - a.angle;
	  }
	  function d3_geom_voronoiCircle() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.x = this.y = this.arc = this.site = this.cy = null;
	  }
	  function d3_geom_voronoiAttachCircle(arc) {
	    var lArc = arc.P, rArc = arc.N;
	    if (!lArc || !rArc) return;
	    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
	    if (lSite === rSite) return;
	    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
	    var d = 2 * (ax * cy - ay * cx);
	    if (d >= -ε2) return;
	    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
	    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
	    circle.arc = arc;
	    circle.site = cSite;
	    circle.x = x + bx;
	    circle.y = cy + Math.sqrt(x * x + y * y);
	    circle.cy = cy;
	    arc.circle = circle;
	    var before = null, node = d3_geom_voronoiCircles._;
	    while (node) {
	      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
	        if (node.L) node = node.L; else {
	          before = node.P;
	          break;
	        }
	      } else {
	        if (node.R) node = node.R; else {
	          before = node;
	          break;
	        }
	      }
	    }
	    d3_geom_voronoiCircles.insert(before, circle);
	    if (!before) d3_geom_voronoiFirstCircle = circle;
	  }
	  function d3_geom_voronoiDetachCircle(arc) {
	    var circle = arc.circle;
	    if (circle) {
	      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
	      d3_geom_voronoiCircles.remove(circle);
	      d3_geom_voronoiCirclePool.push(circle);
	      d3_geom_voronoiRedBlackNode(circle);
	      arc.circle = null;
	    }
	  }
	  function d3_geom_voronoiClipEdges(extent) {
	    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
	    while (i--) {
	      e = edges[i];
	      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
	        e.a = e.b = null;
	        edges.splice(i, 1);
	      }
	    }
	  }
	  function d3_geom_voronoiConnectEdge(edge, extent) {
	    var vb = edge.b;
	    if (vb) return true;
	    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
	    if (ry === ly) {
	      if (fx < x0 || fx >= x1) return;
	      if (lx > rx) {
	        if (!va) va = {
	          x: fx,
	          y: y0
	        }; else if (va.y >= y1) return;
	        vb = {
	          x: fx,
	          y: y1
	        };
	      } else {
	        if (!va) va = {
	          x: fx,
	          y: y1
	        }; else if (va.y < y0) return;
	        vb = {
	          x: fx,
	          y: y0
	        };
	      }
	    } else {
	      fm = (lx - rx) / (ry - ly);
	      fb = fy - fm * fx;
	      if (fm < -1 || fm > 1) {
	        if (lx > rx) {
	          if (!va) va = {
	            x: (y0 - fb) / fm,
	            y: y0
	          }; else if (va.y >= y1) return;
	          vb = {
	            x: (y1 - fb) / fm,
	            y: y1
	          };
	        } else {
	          if (!va) va = {
	            x: (y1 - fb) / fm,
	            y: y1
	          }; else if (va.y < y0) return;
	          vb = {
	            x: (y0 - fb) / fm,
	            y: y0
	          };
	        }
	      } else {
	        if (ly < ry) {
	          if (!va) va = {
	            x: x0,
	            y: fm * x0 + fb
	          }; else if (va.x >= x1) return;
	          vb = {
	            x: x1,
	            y: fm * x1 + fb
	          };
	        } else {
	          if (!va) va = {
	            x: x1,
	            y: fm * x1 + fb
	          }; else if (va.x < x0) return;
	          vb = {
	            x: x0,
	            y: fm * x0 + fb
	          };
	        }
	      }
	    }
	    edge.a = va;
	    edge.b = vb;
	    return true;
	  }
	  function d3_geom_voronoiEdge(lSite, rSite) {
	    this.l = lSite;
	    this.r = rSite;
	    this.a = this.b = null;
	  }
	  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, rSite);
	    d3_geom_voronoiEdges.push(edge);
	    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
	    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
	    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
	    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
	    return edge;
	  }
	  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, null);
	    edge.a = va;
	    edge.b = vb;
	    d3_geom_voronoiEdges.push(edge);
	    return edge;
	  }
	  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
	    if (!edge.a && !edge.b) {
	      edge.a = vertex;
	      edge.l = lSite;
	      edge.r = rSite;
	    } else if (edge.l === rSite) {
	      edge.b = vertex;
	    } else {
	      edge.a = vertex;
	    }
	  }
	  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
	    var va = edge.a, vb = edge.b;
	    this.edge = edge;
	    this.site = lSite;
	    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
	  }
	  d3_geom_voronoiHalfEdge.prototype = {
	    start: function() {
	      return this.edge.l === this.site ? this.edge.a : this.edge.b;
	    },
	    end: function() {
	      return this.edge.l === this.site ? this.edge.b : this.edge.a;
	    }
	  };
	  function d3_geom_voronoiRedBlackTree() {
	    this._ = null;
	  }
	  function d3_geom_voronoiRedBlackNode(node) {
	    node.U = node.C = node.L = node.R = node.P = node.N = null;
	  }
	  d3_geom_voronoiRedBlackTree.prototype = {
	    insert: function(after, node) {
	      var parent, grandpa, uncle;
	      if (after) {
	        node.P = after;
	        node.N = after.N;
	        if (after.N) after.N.P = node;
	        after.N = node;
	        if (after.R) {
	          after = after.R;
	          while (after.L) after = after.L;
	          after.L = node;
	        } else {
	          after.R = node;
	        }
	        parent = after;
	      } else if (this._) {
	        after = d3_geom_voronoiRedBlackFirst(this._);
	        node.P = null;
	        node.N = after;
	        after.P = after.L = node;
	        parent = after;
	      } else {
	        node.P = node.N = null;
	        this._ = node;
	        parent = null;
	      }
	      node.L = node.R = null;
	      node.U = parent;
	      node.C = true;
	      after = node;
	      while (parent && parent.C) {
	        grandpa = parent.U;
	        if (parent === grandpa.L) {
	          uncle = grandpa.R;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.R) {
	              d3_geom_voronoiRedBlackRotateLeft(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
	          }
	        } else {
	          uncle = grandpa.L;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.L) {
	              d3_geom_voronoiRedBlackRotateRight(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
	          }
	        }
	        parent = after.U;
	      }
	      this._.C = false;
	    },
	    remove: function(node) {
	      if (node.N) node.N.P = node.P;
	      if (node.P) node.P.N = node.N;
	      node.N = node.P = null;
	      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
	      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
	      if (parent) {
	        if (parent.L === node) parent.L = next; else parent.R = next;
	      } else {
	        this._ = next;
	      }
	      if (left && right) {
	        red = next.C;
	        next.C = node.C;
	        next.L = left;
	        left.U = next;
	        if (next !== right) {
	          parent = next.U;
	          next.U = node.U;
	          node = next.R;
	          parent.L = node;
	          next.R = right;
	          right.U = next;
	        } else {
	          next.U = parent;
	          parent = next;
	          node = next.R;
	        }
	      } else {
	        red = node.C;
	        node = next;
	      }
	      if (node) node.U = parent;
	      if (red) return;
	      if (node && node.C) {
	        node.C = false;
	        return;
	      }
	      do {
	        if (node === this._) break;
	        if (node === parent.L) {
	          sibling = parent.R;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            sibling = parent.R;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.R || !sibling.R.C) {
	              sibling.L.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateRight(this, sibling);
	              sibling = parent.R;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.R.C = false;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            node = this._;
	            break;
	          }
	        } else {
	          sibling = parent.L;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            sibling = parent.L;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.L || !sibling.L.C) {
	              sibling.R.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
	              sibling = parent.L;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.L.C = false;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            node = this._;
	            break;
	          }
	        }
	        sibling.C = true;
	        node = parent;
	        parent = parent.U;
	      } while (!node.C);
	      if (node) node.C = false;
	    }
	  };
	  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
	    var p = node, q = node.R, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.R = q.L;
	    if (p.R) p.R.U = p;
	    q.L = p;
	  }
	  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
	    var p = node, q = node.L, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.L = q.R;
	    if (p.L) p.L.U = p;
	    q.R = p;
	  }
	  function d3_geom_voronoiRedBlackFirst(node) {
	    while (node.L) node = node.L;
	    return node;
	  }
	  function d3_geom_voronoi(sites, bbox) {
	    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
	    d3_geom_voronoiEdges = [];
	    d3_geom_voronoiCells = new Array(sites.length);
	    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
	    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
	    while (true) {
	      circle = d3_geom_voronoiFirstCircle;
	      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
	        if (site.x !== x0 || site.y !== y0) {
	          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
	          d3_geom_voronoiAddBeach(site);
	          x0 = site.x, y0 = site.y;
	        }
	        site = sites.pop();
	      } else if (circle) {
	        d3_geom_voronoiRemoveBeach(circle.arc);
	      } else {
	        break;
	      }
	    }
	    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
	    var diagram = {
	      cells: d3_geom_voronoiCells,
	      edges: d3_geom_voronoiEdges
	    };
	    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
	    return diagram;
	  }
	  function d3_geom_voronoiVertexOrder(a, b) {
	    return b.y - a.y || b.x - a.x;
	  }
	  d3.geom.voronoi = function(points) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
	    if (points) return voronoi(points);
	    function voronoi(data) {
	      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
	      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
	        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
	          var s = e.start();
	          return [ s.x, s.y ];
	        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
	        polygon.point = data[i];
	      });
	      return polygons;
	    }
	    function sites(data) {
	      return data.map(function(d, i) {
	        return {
	          x: Math.round(fx(d, i) / ε) * ε,
	          y: Math.round(fy(d, i) / ε) * ε,
	          i: i
	        };
	      });
	    }
	    voronoi.links = function(data) {
	      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
	        return edge.l && edge.r;
	      }).map(function(edge) {
	        return {
	          source: data[edge.l.i],
	          target: data[edge.r.i]
	        };
	      });
	    };
	    voronoi.triangles = function(data) {
	      var triangles = [];
	      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
	        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
	        while (++j < m) {
	          e0 = e1;
	          s0 = s1;
	          e1 = edges[j].edge;
	          s1 = e1.l === site ? e1.r : e1.l;
	          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
	            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
	          }
	        }
	      });
	      return triangles;
	    };
	    voronoi.x = function(_) {
	      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
	    };
	    voronoi.y = function(_) {
	      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
	    };
	    voronoi.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
	      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
	      return voronoi;
	    };
	    voronoi.size = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
	      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
	    };
	    return voronoi;
	  };
	  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
	  function d3_geom_voronoiTriangleArea(a, b, c) {
	    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
	  }
	  d3.geom.delaunay = function(vertices) {
	    return d3.geom.voronoi().triangles(vertices);
	  };
	  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
	    if (compat = arguments.length) {
	      x = d3_geom_quadtreeCompatX;
	      y = d3_geom_quadtreeCompatY;
	      if (compat === 3) {
	        y2 = y1;
	        x2 = x1;
	        y1 = x1 = 0;
	      }
	      return quadtree(points);
	    }
	    function quadtree(data) {
	      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
	      if (x1 != null) {
	        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
	      } else {
	        x2_ = y2_ = -(x1_ = y1_ = Infinity);
	        xs = [], ys = [];
	        n = data.length;
	        if (compat) for (i = 0; i < n; ++i) {
	          d = data[i];
	          if (d.x < x1_) x1_ = d.x;
	          if (d.y < y1_) y1_ = d.y;
	          if (d.x > x2_) x2_ = d.x;
	          if (d.y > y2_) y2_ = d.y;
	          xs.push(d.x);
	          ys.push(d.y);
	        } else for (i = 0; i < n; ++i) {
	          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
	          if (x_ < x1_) x1_ = x_;
	          if (y_ < y1_) y1_ = y_;
	          if (x_ > x2_) x2_ = x_;
	          if (y_ > y2_) y2_ = y_;
	          xs.push(x_);
	          ys.push(y_);
	        }
	      }
	      var dx = x2_ - x1_, dy = y2_ - y1_;
	      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
	      function insert(n, d, x, y, x1, y1, x2, y2) {
	        if (isNaN(x) || isNaN(y)) return;
	        if (n.leaf) {
	          var nx = n.x, ny = n.y;
	          if (nx != null) {
	            if (abs(nx - x) + abs(ny - y) < .01) {
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            } else {
	              var nPoint = n.point;
	              n.x = n.y = n.point = null;
	              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            }
	          } else {
	            n.x = x, n.y = y, n.point = d;
	          }
	        } else {
	          insertChild(n, d, x, y, x1, y1, x2, y2);
	        }
	      }
	      function insertChild(n, d, x, y, x1, y1, x2, y2) {
	        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
	        n.leaf = false;
	        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
	        if (right) x1 = xm; else x2 = xm;
	        if (below) y1 = ym; else y2 = ym;
	        insert(n, d, x, y, x1, y1, x2, y2);
	      }
	      var root = d3_geom_quadtreeNode();
	      root.add = function(d) {
	        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
	      };
	      root.visit = function(f) {
	        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
	      };
	      root.find = function(point) {
	        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
	      };
	      i = -1;
	      if (x1 == null) {
	        while (++i < n) {
	          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
	        }
	        --i;
	      } else data.forEach(root.add);
	      xs = ys = data = d = null;
	      return root;
	    }
	    quadtree.x = function(_) {
	      return arguments.length ? (x = _, quadtree) : x;
	    };
	    quadtree.y = function(_) {
	      return arguments.length ? (y = _, quadtree) : y;
	    };
	    quadtree.extent = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
	      y2 = +_[1][1];
	      return quadtree;
	    };
	    quadtree.size = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
	      return quadtree;
	    };
	    return quadtree;
	  };
	  function d3_geom_quadtreeCompatX(d) {
	    return d.x;
	  }
	  function d3_geom_quadtreeCompatY(d) {
	    return d.y;
	  }
	  function d3_geom_quadtreeNode() {
	    return {
	      leaf: true,
	      nodes: [],
	      point: null,
	      x: null,
	      y: null
	    };
	  }
	  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
	    if (!f(node, x1, y1, x2, y2)) {
	      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
	      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
	      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
	      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
	      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
	    }
	  }
	  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
	    var minDistance2 = Infinity, closestPoint;
	    (function find(node, x1, y1, x2, y2) {
	      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
	      if (point = node.point) {
	        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
	        if (distance2 < minDistance2) {
	          var distance = Math.sqrt(minDistance2 = distance2);
	          x0 = x - distance, y0 = y - distance;
	          x3 = x + distance, y3 = y + distance;
	          closestPoint = point;
	        }
	      }
	      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
	      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
	        if (node = children[i & 3]) switch (i & 3) {
	         case 0:
	          find(node, x1, y1, xm, ym);
	          break;

	         case 1:
	          find(node, xm, y1, x2, ym);
	          break;

	         case 2:
	          find(node, x1, ym, xm, y2);
	          break;

	         case 3:
	          find(node, xm, ym, x2, y2);
	          break;
	        }
	      }
	    })(root, x0, y0, x3, y3);
	    return closestPoint;
	  }
	  d3.interpolateRgb = d3_interpolateRgb;
	  function d3_interpolateRgb(a, b) {
	    a = d3.rgb(a);
	    b = d3.rgb(b);
	    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
	    return function(t) {
	      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
	    };
	  }
	  d3.interpolateObject = d3_interpolateObject;
	  function d3_interpolateObject(a, b) {
	    var i = {}, c = {}, k;
	    for (k in a) {
	      if (k in b) {
	        i[k] = d3_interpolate(a[k], b[k]);
	      } else {
	        c[k] = a[k];
	      }
	    }
	    for (k in b) {
	      if (!(k in a)) {
	        c[k] = b[k];
	      }
	    }
	    return function(t) {
	      for (k in i) c[k] = i[k](t);
	      return c;
	    };
	  }
	  d3.interpolateNumber = d3_interpolateNumber;
	  function d3_interpolateNumber(a, b) {
	    a = +a, b = +b;
	    return function(t) {
	      return a * (1 - t) + b * t;
	    };
	  }
	  d3.interpolateString = d3_interpolateString;
	  function d3_interpolateString(a, b) {
	    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
	    a = a + "", b = b + "";
	    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
	      if ((bs = bm.index) > bi) {
	        bs = b.slice(bi, bs);
	        if (s[i]) s[i] += bs; else s[++i] = bs;
	      }
	      if ((am = am[0]) === (bm = bm[0])) {
	        if (s[i]) s[i] += bm; else s[++i] = bm;
	      } else {
	        s[++i] = null;
	        q.push({
	          i: i,
	          x: d3_interpolateNumber(am, bm)
	        });
	      }
	      bi = d3_interpolate_numberB.lastIndex;
	    }
	    if (bi < b.length) {
	      bs = b.slice(bi);
	      if (s[i]) s[i] += bs; else s[++i] = bs;
	    }
	    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
	      return b(t) + "";
	    }) : function() {
	      return b;
	    } : (b = q.length, function(t) {
	      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    });
	  }
	  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
	  d3.interpolate = d3_interpolate;
	  function d3_interpolate(a, b) {
	    var i = d3.interpolators.length, f;
	    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
	    return f;
	  }
	  d3.interpolators = [ function(a, b) {
	    var t = typeof b;
	    return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
	  } ];
	  d3.interpolateArray = d3_interpolateArray;
	  function d3_interpolateArray(a, b) {
	    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
	    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
	    for (;i < na; ++i) c[i] = a[i];
	    for (;i < nb; ++i) c[i] = b[i];
	    return function(t) {
	      for (i = 0; i < n0; ++i) c[i] = x[i](t);
	      return c;
	    };
	  }
	  var d3_ease_default = function() {
	    return d3_identity;
	  };
	  var d3_ease = d3.map({
	    linear: d3_ease_default,
	    poly: d3_ease_poly,
	    quad: function() {
	      return d3_ease_quad;
	    },
	    cubic: function() {
	      return d3_ease_cubic;
	    },
	    sin: function() {
	      return d3_ease_sin;
	    },
	    exp: function() {
	      return d3_ease_exp;
	    },
	    circle: function() {
	      return d3_ease_circle;
	    },
	    elastic: d3_ease_elastic,
	    back: d3_ease_back,
	    bounce: function() {
	      return d3_ease_bounce;
	    }
	  });
	  var d3_ease_mode = d3.map({
	    "in": d3_identity,
	    out: d3_ease_reverse,
	    "in-out": d3_ease_reflect,
	    "out-in": function(f) {
	      return d3_ease_reflect(d3_ease_reverse(f));
	    }
	  });
	  d3.ease = function(name) {
	    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
	    t = d3_ease.get(t) || d3_ease_default;
	    m = d3_ease_mode.get(m) || d3_identity;
	    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
	  };
	  function d3_ease_clamp(f) {
	    return function(t) {
	      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
	    };
	  }
	  function d3_ease_reverse(f) {
	    return function(t) {
	      return 1 - f(1 - t);
	    };
	  }
	  function d3_ease_reflect(f) {
	    return function(t) {
	      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
	    };
	  }
	  function d3_ease_quad(t) {
	    return t * t;
	  }
	  function d3_ease_cubic(t) {
	    return t * t * t;
	  }
	  function d3_ease_cubicInOut(t) {
	    if (t <= 0) return 0;
	    if (t >= 1) return 1;
	    var t2 = t * t, t3 = t2 * t;
	    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
	  }
	  function d3_ease_poly(e) {
	    return function(t) {
	      return Math.pow(t, e);
	    };
	  }
	  function d3_ease_sin(t) {
	    return 1 - Math.cos(t * halfπ);
	  }
	  function d3_ease_exp(t) {
	    return Math.pow(2, 10 * (t - 1));
	  }
	  function d3_ease_circle(t) {
	    return 1 - Math.sqrt(1 - t * t);
	  }
	  function d3_ease_elastic(a, p) {
	    var s;
	    if (arguments.length < 2) p = .45;
	    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
	    return function(t) {
	      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
	    };
	  }
	  function d3_ease_back(s) {
	    if (!s) s = 1.70158;
	    return function(t) {
	      return t * t * ((s + 1) * t - s);
	    };
	  }
	  function d3_ease_bounce(t) {
	    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	  }
	  d3.interpolateHcl = d3_interpolateHcl;
	  function d3_interpolateHcl(a, b) {
	    a = d3.hcl(a);
	    b = d3.hcl(b);
	    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
	    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateHsl = d3_interpolateHsl;
	  function d3_interpolateHsl(a, b) {
	    a = d3.hsl(a);
	    b = d3.hsl(b);
	    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
	    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateLab = d3_interpolateLab;
	  function d3_interpolateLab(a, b) {
	    a = d3.lab(a);
	    b = d3.lab(b);
	    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
	    return function(t) {
	      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
	    };
	  }
	  d3.interpolateRound = d3_interpolateRound;
	  function d3_interpolateRound(a, b) {
	    b -= a;
	    return function(t) {
	      return Math.round(a + b * t);
	    };
	  }
	  d3.transform = function(string) {
	    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
	    return (d3.transform = function(string) {
	      if (string != null) {
	        g.setAttribute("transform", string);
	        var t = g.transform.baseVal.consolidate();
	      }
	      return new d3_transform(t ? t.matrix : d3_transformIdentity);
	    })(string);
	  };
	  function d3_transform(m) {
	    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
	    if (r0[0] * r1[1] < r1[0] * r0[1]) {
	      r0[0] *= -1;
	      r0[1] *= -1;
	      kx *= -1;
	      kz *= -1;
	    }
	    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
	    this.translate = [ m.e, m.f ];
	    this.scale = [ kx, ky ];
	    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
	  }
	  d3_transform.prototype.toString = function() {
	    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
	  };
	  function d3_transformDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	  }
	  function d3_transformNormalize(a) {
	    var k = Math.sqrt(d3_transformDot(a, a));
	    if (k) {
	      a[0] /= k;
	      a[1] /= k;
	    }
	    return k;
	  }
	  function d3_transformCombine(a, b, k) {
	    a[0] += k * b[0];
	    a[1] += k * b[1];
	    return a;
	  }
	  var d3_transformIdentity = {
	    a: 1,
	    b: 0,
	    c: 0,
	    d: 1,
	    e: 0,
	    f: 0
	  };
	  d3.interpolateTransform = d3_interpolateTransform;
	  function d3_interpolateTransform(a, b) {
	    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
	    if (ta[0] != tb[0] || ta[1] != tb[1]) {
	      s.push("translate(", null, ",", null, ")");
	      q.push({
	        i: 1,
	        x: d3_interpolateNumber(ta[0], tb[0])
	      }, {
	        i: 3,
	        x: d3_interpolateNumber(ta[1], tb[1])
	      });
	    } else if (tb[0] || tb[1]) {
	      s.push("translate(" + tb + ")");
	    } else {
	      s.push("");
	    }
	    if (ra != rb) {
	      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
	      q.push({
	        i: s.push(s.pop() + "rotate(", null, ")") - 2,
	        x: d3_interpolateNumber(ra, rb)
	      });
	    } else if (rb) {
	      s.push(s.pop() + "rotate(" + rb + ")");
	    }
	    if (wa != wb) {
	      q.push({
	        i: s.push(s.pop() + "skewX(", null, ")") - 2,
	        x: d3_interpolateNumber(wa, wb)
	      });
	    } else if (wb) {
	      s.push(s.pop() + "skewX(" + wb + ")");
	    }
	    if (ka[0] != kb[0] || ka[1] != kb[1]) {
	      n = s.push(s.pop() + "scale(", null, ",", null, ")");
	      q.push({
	        i: n - 4,
	        x: d3_interpolateNumber(ka[0], kb[0])
	      }, {
	        i: n - 2,
	        x: d3_interpolateNumber(ka[1], kb[1])
	      });
	    } else if (kb[0] != 1 || kb[1] != 1) {
	      s.push(s.pop() + "scale(" + kb + ")");
	    }
	    n = q.length;
	    return function(t) {
	      var i = -1, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  }
	  function d3_uninterpolateNumber(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return (x - a) / b;
	    };
	  }
	  function d3_uninterpolateClamp(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return Math.max(0, Math.min(1, (x - a) / b));
	    };
	  }
	  d3.layout = {};
	  d3.layout.bundle = function() {
	    return function(links) {
	      var paths = [], i = -1, n = links.length;
	      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
	      return paths;
	    };
	  };
	  function d3_layout_bundlePath(link) {
	    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
	    while (start !== lca) {
	      start = start.parent;
	      points.push(start);
	    }
	    var k = points.length;
	    while (end !== lca) {
	      points.splice(k, 0, end);
	      end = end.parent;
	    }
	    return points;
	  }
	  function d3_layout_bundleAncestors(node) {
	    var ancestors = [], parent = node.parent;
	    while (parent != null) {
	      ancestors.push(node);
	      node = parent;
	      parent = parent.parent;
	    }
	    ancestors.push(node);
	    return ancestors;
	  }
	  function d3_layout_bundleLeastCommonAncestor(a, b) {
	    if (a === b) return a;
	    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
	    while (aNode === bNode) {
	      sharedNode = aNode;
	      aNode = aNodes.pop();
	      bNode = bNodes.pop();
	    }
	    return sharedNode;
	  }
	  d3.layout.chord = function() {
	    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
	    function relayout() {
	      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
	      chords = [];
	      groups = [];
	      k = 0, i = -1;
	      while (++i < n) {
	        x = 0, j = -1;
	        while (++j < n) {
	          x += matrix[i][j];
	        }
	        groupSums.push(x);
	        subgroupIndex.push(d3.range(n));
	        k += x;
	      }
	      if (sortGroups) {
	        groupIndex.sort(function(a, b) {
	          return sortGroups(groupSums[a], groupSums[b]);
	        });
	      }
	      if (sortSubgroups) {
	        subgroupIndex.forEach(function(d, i) {
	          d.sort(function(a, b) {
	            return sortSubgroups(matrix[i][a], matrix[i][b]);
	          });
	        });
	      }
	      k = (τ - padding * n) / k;
	      x = 0, i = -1;
	      while (++i < n) {
	        x0 = x, j = -1;
	        while (++j < n) {
	          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
	          subgroups[di + "-" + dj] = {
	            index: di,
	            subindex: dj,
	            startAngle: a0,
	            endAngle: a1,
	            value: v
	          };
	        }
	        groups[di] = {
	          index: di,
	          startAngle: x0,
	          endAngle: x,
	          value: (x - x0) / k
	        };
	        x += padding;
	      }
	      i = -1;
	      while (++i < n) {
	        j = i - 1;
	        while (++j < n) {
	          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
	          if (source.value || target.value) {
	            chords.push(source.value < target.value ? {
	              source: target,
	              target: source
	            } : {
	              source: source,
	              target: target
	            });
	          }
	        }
	      }
	      if (sortChords) resort();
	    }
	    function resort() {
	      chords.sort(function(a, b) {
	        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
	      });
	    }
	    chord.matrix = function(x) {
	      if (!arguments.length) return matrix;
	      n = (matrix = x) && matrix.length;
	      chords = groups = null;
	      return chord;
	    };
	    chord.padding = function(x) {
	      if (!arguments.length) return padding;
	      padding = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortGroups = function(x) {
	      if (!arguments.length) return sortGroups;
	      sortGroups = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortSubgroups = function(x) {
	      if (!arguments.length) return sortSubgroups;
	      sortSubgroups = x;
	      chords = null;
	      return chord;
	    };
	    chord.sortChords = function(x) {
	      if (!arguments.length) return sortChords;
	      sortChords = x;
	      if (chords) resort();
	      return chord;
	    };
	    chord.chords = function() {
	      if (!chords) relayout();
	      return chords;
	    };
	    chord.groups = function() {
	      if (!groups) relayout();
	      return groups;
	    };
	    return chord;
	  };
	  d3.layout.force = function() {
	    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
	    function repulse(node) {
	      return function(quad, x1, _, x2) {
	        if (quad.point !== node) {
	          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
	          if (dw * dw / theta2 < dn) {
	            if (dn < chargeDistance2) {
	              var k = quad.charge / dn;
	              node.px -= dx * k;
	              node.py -= dy * k;
	            }
	            return true;
	          }
	          if (quad.point && dn && dn < chargeDistance2) {
	            var k = quad.pointCharge / dn;
	            node.px -= dx * k;
	            node.py -= dy * k;
	          }
	        }
	        return !quad.charge;
	      };
	    }
	    force.tick = function() {
	      if ((alpha *= .99) < .005) {
	        event.end({
	          type: "end",
	          alpha: alpha = 0
	        });
	        return true;
	      }
	      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        s = o.source;
	        t = o.target;
	        x = t.x - s.x;
	        y = t.y - s.y;
	        if (l = x * x + y * y) {
	          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
	          x *= l;
	          y *= l;
	          t.x -= x * (k = s.weight / (t.weight + s.weight));
	          t.y -= y * k;
	          s.x += x * (k = 1 - k);
	          s.y += y * k;
	        }
	      }
	      if (k = alpha * gravity) {
	        x = size[0] / 2;
	        y = size[1] / 2;
	        i = -1;
	        if (k) while (++i < n) {
	          o = nodes[i];
	          o.x += (x - o.x) * k;
	          o.y += (y - o.y) * k;
	        }
	      }
	      if (charge) {
	        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
	        i = -1;
	        while (++i < n) {
	          if (!(o = nodes[i]).fixed) {
	            q.visit(repulse(o));
	          }
	        }
	      }
	      i = -1;
	      while (++i < n) {
	        o = nodes[i];
	        if (o.fixed) {
	          o.x = o.px;
	          o.y = o.py;
	        } else {
	          o.x -= (o.px - (o.px = o.x)) * friction;
	          o.y -= (o.py - (o.py = o.y)) * friction;
	        }
	      }
	      event.tick({
	        type: "tick",
	        alpha: alpha
	      });
	    };
	    force.nodes = function(x) {
	      if (!arguments.length) return nodes;
	      nodes = x;
	      return force;
	    };
	    force.links = function(x) {
	      if (!arguments.length) return links;
	      links = x;
	      return force;
	    };
	    force.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return force;
	    };
	    force.linkDistance = function(x) {
	      if (!arguments.length) return linkDistance;
	      linkDistance = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.distance = force.linkDistance;
	    force.linkStrength = function(x) {
	      if (!arguments.length) return linkStrength;
	      linkStrength = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.friction = function(x) {
	      if (!arguments.length) return friction;
	      friction = +x;
	      return force;
	    };
	    force.charge = function(x) {
	      if (!arguments.length) return charge;
	      charge = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.chargeDistance = function(x) {
	      if (!arguments.length) return Math.sqrt(chargeDistance2);
	      chargeDistance2 = x * x;
	      return force;
	    };
	    force.gravity = function(x) {
	      if (!arguments.length) return gravity;
	      gravity = +x;
	      return force;
	    };
	    force.theta = function(x) {
	      if (!arguments.length) return Math.sqrt(theta2);
	      theta2 = x * x;
	      return force;
	    };
	    force.alpha = function(x) {
	      if (!arguments.length) return alpha;
	      x = +x;
	      if (alpha) {
	        if (x > 0) alpha = x; else alpha = 0;
	      } else if (x > 0) {
	        event.start({
	          type: "start",
	          alpha: alpha = x
	        });
	        d3.timer(force.tick);
	      }
	      return force;
	    };
	    force.start = function() {
	      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
	      for (i = 0; i < n; ++i) {
	        (o = nodes[i]).index = i;
	        o.weight = 0;
	      }
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        if (typeof o.source == "number") o.source = nodes[o.source];
	        if (typeof o.target == "number") o.target = nodes[o.target];
	        ++o.source.weight;
	        ++o.target.weight;
	      }
	      for (i = 0; i < n; ++i) {
	        o = nodes[i];
	        if (isNaN(o.x)) o.x = position("x", w);
	        if (isNaN(o.y)) o.y = position("y", h);
	        if (isNaN(o.px)) o.px = o.x;
	        if (isNaN(o.py)) o.py = o.y;
	      }
	      distances = [];
	      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
	      strengths = [];
	      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
	      charges = [];
	      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
	      function position(dimension, size) {
	        if (!neighbors) {
	          neighbors = new Array(n);
	          for (j = 0; j < n; ++j) {
	            neighbors[j] = [];
	          }
	          for (j = 0; j < m; ++j) {
	            var o = links[j];
	            neighbors[o.source.index].push(o.target);
	            neighbors[o.target.index].push(o.source);
	          }
	        }
	        var candidates = neighbors[i], j = -1, l = candidates.length, x;
	        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
	        return Math.random() * size;
	      }
	      return force.resume();
	    };
	    force.resume = function() {
	      return force.alpha(.1);
	    };
	    force.stop = function() {
	      return force.alpha(0);
	    };
	    force.drag = function() {
	      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
	      if (!arguments.length) return drag;
	      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
	    };
	    function dragmove(d) {
	      d.px = d3.event.x, d.py = d3.event.y;
	      force.resume();
	    }
	    return d3.rebind(force, event, "on");
	  };
	  function d3_layout_forceDragstart(d) {
	    d.fixed |= 2;
	  }
	  function d3_layout_forceDragend(d) {
	    d.fixed &= ~6;
	  }
	  function d3_layout_forceMouseover(d) {
	    d.fixed |= 4;
	    d.px = d.x, d.py = d.y;
	  }
	  function d3_layout_forceMouseout(d) {
	    d.fixed &= ~4;
	  }
	  function d3_layout_forceAccumulate(quad, alpha, charges) {
	    var cx = 0, cy = 0;
	    quad.charge = 0;
	    if (!quad.leaf) {
	      var nodes = quad.nodes, n = nodes.length, i = -1, c;
	      while (++i < n) {
	        c = nodes[i];
	        if (c == null) continue;
	        d3_layout_forceAccumulate(c, alpha, charges);
	        quad.charge += c.charge;
	        cx += c.charge * c.cx;
	        cy += c.charge * c.cy;
	      }
	    }
	    if (quad.point) {
	      if (!quad.leaf) {
	        quad.point.x += Math.random() - .5;
	        quad.point.y += Math.random() - .5;
	      }
	      var k = alpha * charges[quad.point.index];
	      quad.charge += quad.pointCharge = k;
	      cx += k * quad.point.x;
	      cy += k * quad.point.y;
	    }
	    quad.cx = cx / quad.charge;
	    quad.cy = cy / quad.charge;
	  }
	  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
	  d3.layout.hierarchy = function() {
	    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
	    function hierarchy(root) {
	      var stack = [ root ], nodes = [], node;
	      root.depth = 0;
	      while ((node = stack.pop()) != null) {
	        nodes.push(node);
	        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
	          var n, childs, child;
	          while (--n >= 0) {
	            stack.push(child = childs[n]);
	            child.parent = node;
	            child.depth = node.depth + 1;
	          }
	          if (value) node.value = 0;
	          node.children = childs;
	        } else {
	          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          delete node.children;
	        }
	      }
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var childs, parent;
	        if (sort && (childs = node.children)) childs.sort(sort);
	        if (value && (parent = node.parent)) parent.value += node.value;
	      });
	      return nodes;
	    }
	    hierarchy.sort = function(x) {
	      if (!arguments.length) return sort;
	      sort = x;
	      return hierarchy;
	    };
	    hierarchy.children = function(x) {
	      if (!arguments.length) return children;
	      children = x;
	      return hierarchy;
	    };
	    hierarchy.value = function(x) {
	      if (!arguments.length) return value;
	      value = x;
	      return hierarchy;
	    };
	    hierarchy.revalue = function(root) {
	      if (value) {
	        d3_layout_hierarchyVisitBefore(root, function(node) {
	          if (node.children) node.value = 0;
	        });
	        d3_layout_hierarchyVisitAfter(root, function(node) {
	          var parent;
	          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          if (parent = node.parent) parent.value += node.value;
	        });
	      }
	      return root;
	    };
	    return hierarchy;
	  };
	  function d3_layout_hierarchyRebind(object, hierarchy) {
	    d3.rebind(object, hierarchy, "sort", "children", "value");
	    object.nodes = object;
	    object.links = d3_layout_hierarchyLinks;
	    return object;
	  }
	  function d3_layout_hierarchyVisitBefore(node, callback) {
	    var nodes = [ node ];
	    while ((node = nodes.pop()) != null) {
	      callback(node);
	      if ((children = node.children) && (n = children.length)) {
	        var n, children;
	        while (--n >= 0) nodes.push(children[n]);
	      }
	    }
	  }
	  function d3_layout_hierarchyVisitAfter(node, callback) {
	    var nodes = [ node ], nodes2 = [];
	    while ((node = nodes.pop()) != null) {
	      nodes2.push(node);
	      if ((children = node.children) && (n = children.length)) {
	        var i = -1, n, children;
	        while (++i < n) nodes.push(children[i]);
	      }
	    }
	    while ((node = nodes2.pop()) != null) {
	      callback(node);
	    }
	  }
	  function d3_layout_hierarchyChildren(d) {
	    return d.children;
	  }
	  function d3_layout_hierarchyValue(d) {
	    return d.value;
	  }
	  function d3_layout_hierarchySort(a, b) {
	    return b.value - a.value;
	  }
	  function d3_layout_hierarchyLinks(nodes) {
	    return d3.merge(nodes.map(function(parent) {
	      return (parent.children || []).map(function(child) {
	        return {
	          source: parent,
	          target: child
	        };
	      });
	    }));
	  }
	  d3.layout.partition = function() {
	    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
	    function position(node, x, dx, dy) {
	      var children = node.children;
	      node.x = x;
	      node.y = node.depth * dy;
	      node.dx = dx;
	      node.dy = dy;
	      if (children && (n = children.length)) {
	        var i = -1, n, c, d;
	        dx = node.value ? dx / node.value : 0;
	        while (++i < n) {
	          position(c = children[i], x, d = c.value * dx, dy);
	          x += d;
	        }
	      }
	    }
	    function depth(node) {
	      var children = node.children, d = 0;
	      if (children && (n = children.length)) {
	        var i = -1, n;
	        while (++i < n) d = Math.max(d, depth(children[i]));
	      }
	      return 1 + d;
	    }
	    function partition(d, i) {
	      var nodes = hierarchy.call(this, d, i);
	      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
	      return nodes;
	    }
	    partition.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return partition;
	    };
	    return d3_layout_hierarchyRebind(partition, hierarchy);
	  };
	  d3.layout.pie = function() {
	    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
	    function pie(data) {
	      var n = data.length, values = data.map(function(d, i) {
	        return +value.call(pie, d, i);
	      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [], v;
	      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
	        return values[j] - values[i];
	      } : function(i, j) {
	        return sort(data[i], data[j]);
	      });
	      index.forEach(function(i) {
	        arcs[i] = {
	          data: data[i],
	          value: v = values[i],
	          startAngle: a,
	          endAngle: a += v * k + pa,
	          padAngle: p
	        };
	      });
	      return arcs;
	    }
	    pie.value = function(_) {
	      if (!arguments.length) return value;
	      value = _;
	      return pie;
	    };
	    pie.sort = function(_) {
	      if (!arguments.length) return sort;
	      sort = _;
	      return pie;
	    };
	    pie.startAngle = function(_) {
	      if (!arguments.length) return startAngle;
	      startAngle = _;
	      return pie;
	    };
	    pie.endAngle = function(_) {
	      if (!arguments.length) return endAngle;
	      endAngle = _;
	      return pie;
	    };
	    pie.padAngle = function(_) {
	      if (!arguments.length) return padAngle;
	      padAngle = _;
	      return pie;
	    };
	    return pie;
	  };
	  var d3_layout_pieSortByValue = {};
	  d3.layout.stack = function() {
	    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
	    function stack(data, index) {
	      if (!(n = data.length)) return data;
	      var series = data.map(function(d, i) {
	        return values.call(stack, d, i);
	      });
	      var points = series.map(function(d) {
	        return d.map(function(v, i) {
	          return [ x.call(stack, v, i), y.call(stack, v, i) ];
	        });
	      });
	      var orders = order.call(stack, points, index);
	      series = d3.permute(series, orders);
	      points = d3.permute(points, orders);
	      var offsets = offset.call(stack, points, index);
	      var m = series[0].length, n, i, j, o;
	      for (j = 0; j < m; ++j) {
	        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
	        for (i = 1; i < n; ++i) {
	          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
	        }
	      }
	      return data;
	    }
	    stack.values = function(x) {
	      if (!arguments.length) return values;
	      values = x;
	      return stack;
	    };
	    stack.order = function(x) {
	      if (!arguments.length) return order;
	      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
	      return stack;
	    };
	    stack.offset = function(x) {
	      if (!arguments.length) return offset;
	      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
	      return stack;
	    };
	    stack.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      return stack;
	    };
	    stack.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      return stack;
	    };
	    stack.out = function(z) {
	      if (!arguments.length) return out;
	      out = z;
	      return stack;
	    };
	    return stack;
	  };
	  function d3_layout_stackX(d) {
	    return d.x;
	  }
	  function d3_layout_stackY(d) {
	    return d.y;
	  }
	  function d3_layout_stackOut(d, y0, y) {
	    d.y0 = y0;
	    d.y = y;
	  }
	  var d3_layout_stackOrders = d3.map({
	    "inside-out": function(data) {
	      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
	        return max[a] - max[b];
	      }), top = 0, bottom = 0, tops = [], bottoms = [];
	      for (i = 0; i < n; ++i) {
	        j = index[i];
	        if (top < bottom) {
	          top += sums[j];
	          tops.push(j);
	        } else {
	          bottom += sums[j];
	          bottoms.push(j);
	        }
	      }
	      return bottoms.reverse().concat(tops);
	    },
	    reverse: function(data) {
	      return d3.range(data.length).reverse();
	    },
	    "default": d3_layout_stackOrderDefault
	  });
	  var d3_layout_stackOffsets = d3.map({
	    silhouette: function(data) {
	      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o > max) max = o;
	        sums.push(o);
	      }
	      for (j = 0; j < m; ++j) {
	        y0[j] = (max - sums[j]) / 2;
	      }
	      return y0;
	    },
	    wiggle: function(data) {
	      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
	      y0[0] = o = o0 = 0;
	      for (j = 1; j < m; ++j) {
	        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
	        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
	          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
	            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
	          }
	          s2 += s3 * data[i][j][1];
	        }
	        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
	        if (o < o0) o0 = o;
	      }
	      for (j = 0; j < m; ++j) y0[j] -= o0;
	      return y0;
	    },
	    expand: function(data) {
	      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
	      }
	      for (j = 0; j < m; ++j) y0[j] = 0;
	      return y0;
	    },
	    zero: d3_layout_stackOffsetZero
	  });
	  function d3_layout_stackOrderDefault(data) {
	    return d3.range(data.length);
	  }
	  function d3_layout_stackOffsetZero(data) {
	    var j = -1, m = data[0].length, y0 = [];
	    while (++j < m) y0[j] = 0;
	    return y0;
	  }
	  function d3_layout_stackMaxIndex(array) {
	    var i = 1, j = 0, v = array[0][1], k, n = array.length;
	    for (;i < n; ++i) {
	      if ((k = array[i][1]) > v) {
	        j = i;
	        v = k;
	      }
	    }
	    return j;
	  }
	  function d3_layout_stackReduceSum(d) {
	    return d.reduce(d3_layout_stackSum, 0);
	  }
	  function d3_layout_stackSum(p, d) {
	    return p + d[1];
	  }
	  d3.layout.histogram = function() {
	    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
	    function histogram(data, i) {
	      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
	      while (++i < m) {
	        bin = bins[i] = [];
	        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
	        bin.y = 0;
	      }
	      if (m > 0) {
	        i = -1;
	        while (++i < n) {
	          x = values[i];
	          if (x >= range[0] && x <= range[1]) {
	            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
	            bin.y += k;
	            bin.push(data[i]);
	          }
	        }
	      }
	      return bins;
	    }
	    histogram.value = function(x) {
	      if (!arguments.length) return valuer;
	      valuer = x;
	      return histogram;
	    };
	    histogram.range = function(x) {
	      if (!arguments.length) return ranger;
	      ranger = d3_functor(x);
	      return histogram;
	    };
	    histogram.bins = function(x) {
	      if (!arguments.length) return binner;
	      binner = typeof x === "number" ? function(range) {
	        return d3_layout_histogramBinFixed(range, x);
	      } : d3_functor(x);
	      return histogram;
	    };
	    histogram.frequency = function(x) {
	      if (!arguments.length) return frequency;
	      frequency = !!x;
	      return histogram;
	    };
	    return histogram;
	  };
	  function d3_layout_histogramBinSturges(range, values) {
	    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
	  }
	  function d3_layout_histogramBinFixed(range, n) {
	    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
	    while (++x <= n) f[x] = m * x + b;
	    return f;
	  }
	  function d3_layout_histogramRange(values) {
	    return [ d3.min(values), d3.max(values) ];
	  }
	  d3.layout.pack = function() {
	    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
	    function pack(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
	        return radius;
	      };
	      root.x = root.y = 0;
	      d3_layout_hierarchyVisitAfter(root, function(d) {
	        d.r = +r(d.value);
	      });
	      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	      if (padding) {
	        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r += dr;
	        });
	        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r -= dr;
	        });
	      }
	      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
	      return nodes;
	    }
	    pack.size = function(_) {
	      if (!arguments.length) return size;
	      size = _;
	      return pack;
	    };
	    pack.radius = function(_) {
	      if (!arguments.length) return radius;
	      radius = _ == null || typeof _ === "function" ? _ : +_;
	      return pack;
	    };
	    pack.padding = function(_) {
	      if (!arguments.length) return padding;
	      padding = +_;
	      return pack;
	    };
	    return d3_layout_hierarchyRebind(pack, hierarchy);
	  };
	  function d3_layout_packSort(a, b) {
	    return a.value - b.value;
	  }
	  function d3_layout_packInsert(a, b) {
	    var c = a._pack_next;
	    a._pack_next = b;
	    b._pack_prev = a;
	    b._pack_next = c;
	    c._pack_prev = b;
	  }
	  function d3_layout_packSplice(a, b) {
	    a._pack_next = b;
	    b._pack_prev = a;
	  }
	  function d3_layout_packIntersects(a, b) {
	    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
	    return .999 * dr * dr > dx * dx + dy * dy;
	  }
	  function d3_layout_packSiblings(node) {
	    if (!(nodes = node.children) || !(n = nodes.length)) return;
	    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
	    function bound(node) {
	      xMin = Math.min(node.x - node.r, xMin);
	      xMax = Math.max(node.x + node.r, xMax);
	      yMin = Math.min(node.y - node.r, yMin);
	      yMax = Math.max(node.y + node.r, yMax);
	    }
	    nodes.forEach(d3_layout_packLink);
	    a = nodes[0];
	    a.x = -a.r;
	    a.y = 0;
	    bound(a);
	    if (n > 1) {
	      b = nodes[1];
	      b.x = b.r;
	      b.y = 0;
	      bound(b);
	      if (n > 2) {
	        c = nodes[2];
	        d3_layout_packPlace(a, b, c);
	        bound(c);
	        d3_layout_packInsert(a, c);
	        a._pack_prev = c;
	        d3_layout_packInsert(c, b);
	        b = a._pack_next;
	        for (i = 3; i < n; i++) {
	          d3_layout_packPlace(a, b, c = nodes[i]);
	          var isect = 0, s1 = 1, s2 = 1;
	          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
	            if (d3_layout_packIntersects(j, c)) {
	              isect = 1;
	              break;
	            }
	          }
	          if (isect == 1) {
	            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
	              if (d3_layout_packIntersects(k, c)) {
	                break;
	              }
	            }
	          }
	          if (isect) {
	            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
	            i--;
	          } else {
	            d3_layout_packInsert(a, c);
	            b = c;
	            bound(c);
	          }
	        }
	      }
	    }
	    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
	    for (i = 0; i < n; i++) {
	      c = nodes[i];
	      c.x -= cx;
	      c.y -= cy;
	      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
	    }
	    node.r = cr;
	    nodes.forEach(d3_layout_packUnlink);
	  }
	  function d3_layout_packLink(node) {
	    node._pack_next = node._pack_prev = node;
	  }
	  function d3_layout_packUnlink(node) {
	    delete node._pack_next;
	    delete node._pack_prev;
	  }
	  function d3_layout_packTransform(node, x, y, k) {
	    var children = node.children;
	    node.x = x += k * node.x;
	    node.y = y += k * node.y;
	    node.r *= k;
	    if (children) {
	      var i = -1, n = children.length;
	      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
	    }
	  }
	  function d3_layout_packPlace(a, b, c) {
	    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
	    if (db && (dx || dy)) {
	      var da = b.r + c.r, dc = dx * dx + dy * dy;
	      da *= da;
	      db *= db;
	      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
	      c.x = a.x + x * dx + y * dy;
	      c.y = a.y + x * dy - y * dx;
	    } else {
	      c.x = a.x + db;
	      c.y = a.y;
	    }
	  }
	  d3.layout.tree = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
	    function tree(d, i) {
	      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
	      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
	      d3_layout_hierarchyVisitBefore(root1, secondWalk);
	      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
	        var left = root0, right = root0, bottom = root0;
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          if (node.x < left.x) left = node;
	          if (node.x > right.x) right = node;
	          if (node.depth > bottom.depth) bottom = node;
	        });
	        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          node.x = (node.x + tx) * kx;
	          node.y = node.depth * ky;
	        });
	      }
	      return nodes;
	    }
	    function wrapTree(root0) {
	      var root1 = {
	        A: null,
	        children: [ root0 ]
	      }, queue = [ root1 ], node1;
	      while ((node1 = queue.pop()) != null) {
	        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
	          queue.push((children[i] = child = {
	            _: children[i],
	            parent: node1,
	            children: (child = children[i].children) && child.slice() || [],
	            A: null,
	            a: null,
	            z: 0,
	            m: 0,
	            c: 0,
	            s: 0,
	            t: null,
	            i: i
	          }).a = child);
	        }
	      }
	      return root1.children[0];
	    }
	    function firstWalk(v) {
	      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
	      if (children.length) {
	        d3_layout_treeShift(v);
	        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	        if (w) {
	          v.z = w.z + separation(v._, w._);
	          v.m = v.z - midpoint;
	        } else {
	          v.z = midpoint;
	        }
	      } else if (w) {
	        v.z = w.z + separation(v._, w._);
	      }
	      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	    }
	    function secondWalk(v) {
	      v._.x = v.z + v.parent.m;
	      v.m += v.parent.m;
	    }
	    function apportion(v, w, ancestor) {
	      if (w) {
	        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
	        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
	          vom = d3_layout_treeLeft(vom);
	          vop = d3_layout_treeRight(vop);
	          vop.a = v;
	          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	          if (shift > 0) {
	            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
	            sip += shift;
	            sop += shift;
	          }
	          sim += vim.m;
	          sip += vip.m;
	          som += vom.m;
	          sop += vop.m;
	        }
	        if (vim && !d3_layout_treeRight(vop)) {
	          vop.t = vim;
	          vop.m += sim - sop;
	        }
	        if (vip && !d3_layout_treeLeft(vom)) {
	          vom.t = vip;
	          vom.m += sip - som;
	          ancestor = v;
	        }
	      }
	      return ancestor;
	    }
	    function sizeNode(node) {
	      node.x *= size[0];
	      node.y = node.depth * size[1];
	    }
	    tree.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return tree;
	    };
	    tree.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null ? sizeNode : null;
	      return tree;
	    };
	    tree.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) == null ? null : sizeNode;
	      return tree;
	    };
	    return d3_layout_hierarchyRebind(tree, hierarchy);
	  };
	  function d3_layout_treeSeparation(a, b) {
	    return a.parent == b.parent ? 1 : 2;
	  }
	  function d3_layout_treeLeft(v) {
	    var children = v.children;
	    return children.length ? children[0] : v.t;
	  }
	  function d3_layout_treeRight(v) {
	    var children = v.children, n;
	    return (n = children.length) ? children[n - 1] : v.t;
	  }
	  function d3_layout_treeMove(wm, wp, shift) {
	    var change = shift / (wp.i - wm.i);
	    wp.c -= change;
	    wp.s += shift;
	    wm.c += change;
	    wp.z += shift;
	    wp.m += shift;
	  }
	  function d3_layout_treeShift(v) {
	    var shift = 0, change = 0, children = v.children, i = children.length, w;
	    while (--i >= 0) {
	      w = children[i];
	      w.z += shift;
	      w.m += shift;
	      shift += w.s + (change += w.c);
	    }
	  }
	  function d3_layout_treeAncestor(vim, v, ancestor) {
	    return vim.a.parent === v.parent ? vim.a : ancestor;
	  }
	  d3.layout.cluster = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
	    function cluster(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var children = node.children;
	        if (children && children.length) {
	          node.x = d3_layout_clusterX(children);
	          node.y = d3_layout_clusterY(children);
	        } else {
	          node.x = previousNode ? x += separation(node, previousNode) : 0;
	          node.y = 0;
	          previousNode = node;
	        }
	      });
	      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
	      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
	        node.x = (node.x - root.x) * size[0];
	        node.y = (root.y - node.y) * size[1];
	      } : function(node) {
	        node.x = (node.x - x0) / (x1 - x0) * size[0];
	        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
	      });
	      return nodes;
	    }
	    cluster.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return cluster;
	    };
	    cluster.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null;
	      return cluster;
	    };
	    cluster.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) != null;
	      return cluster;
	    };
	    return d3_layout_hierarchyRebind(cluster, hierarchy);
	  };
	  function d3_layout_clusterY(children) {
	    return 1 + d3.max(children, function(child) {
	      return child.y;
	    });
	  }
	  function d3_layout_clusterX(children) {
	    return children.reduce(function(x, child) {
	      return x + child.x;
	    }, 0) / children.length;
	  }
	  function d3_layout_clusterLeft(node) {
	    var children = node.children;
	    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
	  }
	  function d3_layout_clusterRight(node) {
	    var children = node.children, n;
	    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
	  }
	  d3.layout.treemap = function() {
	    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
	    function scale(children, k) {
	      var i = -1, n = children.length, child, area;
	      while (++i < n) {
	        area = (child = children[i]).value * (k < 0 ? 0 : k);
	        child.area = isNaN(area) || area <= 0 ? 0 : area;
	      }
	    }
	    function squarify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while ((n = remaining.length) > 0) {
	          row.push(child = remaining[n - 1]);
	          row.area += child.area;
	          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
	            remaining.pop();
	            best = score;
	          } else {
	            row.area -= row.pop().area;
	            position(row, u, rect, false);
	            u = Math.min(rect.dx, rect.dy);
	            row.length = row.area = 0;
	            best = Infinity;
	          }
	        }
	        if (row.length) {
	          position(row, u, rect, true);
	          row.length = row.area = 0;
	        }
	        children.forEach(squarify);
	      }
	    }
	    function stickify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), remaining = children.slice(), child, row = [];
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while (child = remaining.pop()) {
	          row.push(child);
	          row.area += child.area;
	          if (child.z != null) {
	            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
	            row.length = row.area = 0;
	          }
	        }
	        children.forEach(stickify);
	      }
	    }
	    function worst(row, u) {
	      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
	      while (++i < n) {
	        if (!(r = row[i].area)) continue;
	        if (r < rmin) rmin = r;
	        if (r > rmax) rmax = r;
	      }
	      s *= s;
	      u *= u;
	      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
	    }
	    function position(row, u, rect, flush) {
	      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
	      if (u == rect.dx) {
	        if (flush || v > rect.dy) v = rect.dy;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dy = v;
	          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
	        }
	        o.z = true;
	        o.dx += rect.x + rect.dx - x;
	        rect.y += v;
	        rect.dy -= v;
	      } else {
	        if (flush || v > rect.dx) v = rect.dx;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dx = v;
	          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
	        }
	        o.z = false;
	        o.dy += rect.y + rect.dy - y;
	        rect.x += v;
	        rect.dx -= v;
	      }
	    }
	    function treemap(d) {
	      var nodes = stickies || hierarchy(d), root = nodes[0];
	      root.x = 0;
	      root.y = 0;
	      root.dx = size[0];
	      root.dy = size[1];
	      if (stickies) hierarchy.revalue(root);
	      scale([ root ], root.dx * root.dy / root.value);
	      (stickies ? stickify : squarify)(root);
	      if (sticky) stickies = nodes;
	      return nodes;
	    }
	    treemap.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return treemap;
	    };
	    treemap.padding = function(x) {
	      if (!arguments.length) return padding;
	      function padFunction(node) {
	        var p = x.call(treemap, node, node.depth);
	        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
	      }
	      function padConstant(node) {
	        return d3_layout_treemapPad(node, x);
	      }
	      var type;
	      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
	      padConstant) : padConstant;
	      return treemap;
	    };
	    treemap.round = function(x) {
	      if (!arguments.length) return round != Number;
	      round = x ? Math.round : Number;
	      return treemap;
	    };
	    treemap.sticky = function(x) {
	      if (!arguments.length) return sticky;
	      sticky = x;
	      stickies = null;
	      return treemap;
	    };
	    treemap.ratio = function(x) {
	      if (!arguments.length) return ratio;
	      ratio = x;
	      return treemap;
	    };
	    treemap.mode = function(x) {
	      if (!arguments.length) return mode;
	      mode = x + "";
	      return treemap;
	    };
	    return d3_layout_hierarchyRebind(treemap, hierarchy);
	  };
	  function d3_layout_treemapPadNull(node) {
	    return {
	      x: node.x,
	      y: node.y,
	      dx: node.dx,
	      dy: node.dy
	    };
	  }
	  function d3_layout_treemapPad(node, padding) {
	    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
	    if (dx < 0) {
	      x += dx / 2;
	      dx = 0;
	    }
	    if (dy < 0) {
	      y += dy / 2;
	      dy = 0;
	    }
	    return {
	      x: x,
	      y: y,
	      dx: dx,
	      dy: dy
	    };
	  }
	  d3.random = {
	    normal: function(µ, σ) {
	      var n = arguments.length;
	      if (n < 2) σ = 1;
	      if (n < 1) µ = 0;
	      return function() {
	        var x, y, r;
	        do {
	          x = Math.random() * 2 - 1;
	          y = Math.random() * 2 - 1;
	          r = x * x + y * y;
	        } while (!r || r > 1);
	        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
	      };
	    },
	    logNormal: function() {
	      var random = d3.random.normal.apply(d3, arguments);
	      return function() {
	        return Math.exp(random());
	      };
	    },
	    bates: function(m) {
	      var random = d3.random.irwinHall(m);
	      return function() {
	        return random() / m;
	      };
	    },
	    irwinHall: function(m) {
	      return function() {
	        for (var s = 0, j = 0; j < m; j++) s += Math.random();
	        return s;
	      };
	    }
	  };
	  d3.scale = {};
	  function d3_scaleExtent(domain) {
	    var start = domain[0], stop = domain[domain.length - 1];
	    return start < stop ? [ start, stop ] : [ stop, start ];
	  }
	  function d3_scaleRange(scale) {
	    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
	  }
	  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
	    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
	    return function(x) {
	      return i(u(x));
	    };
	  }
	  function d3_scale_nice(domain, nice) {
	    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
	    if (x1 < x0) {
	      dx = i0, i0 = i1, i1 = dx;
	      dx = x0, x0 = x1, x1 = dx;
	    }
	    domain[i0] = nice.floor(x0);
	    domain[i1] = nice.ceil(x1);
	    return domain;
	  }
	  function d3_scale_niceStep(step) {
	    return step ? {
	      floor: function(x) {
	        return Math.floor(x / step) * step;
	      },
	      ceil: function(x) {
	        return Math.ceil(x / step) * step;
	      }
	    } : d3_scale_niceIdentity;
	  }
	  var d3_scale_niceIdentity = {
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
	    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
	    if (domain[k] < domain[0]) {
	      domain = domain.slice().reverse();
	      range = range.slice().reverse();
	    }
	    while (++j <= k) {
	      u.push(uninterpolate(domain[j - 1], domain[j]));
	      i.push(interpolate(range[j - 1], range[j]));
	    }
	    return function(x) {
	      var j = d3.bisect(domain, x, 1, k) - 1;
	      return i[j](u[j](x));
	    };
	  }
	  d3.scale.linear = function() {
	    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
	  };
	  function d3_scale_linear(domain, range, interpolate, clamp) {
	    var output, input;
	    function rescale() {
	      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
	      output = linear(domain, range, uninterpolate, interpolate);
	      input = linear(range, domain, uninterpolate, d3_interpolate);
	      return scale;
	    }
	    function scale(x) {
	      return output(x);
	    }
	    scale.invert = function(y) {
	      return input(y);
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(Number);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.rangeRound = function(x) {
	      return scale.range(x).interpolate(d3_interpolateRound);
	    };
	    scale.clamp = function(x) {
	      if (!arguments.length) return clamp;
	      clamp = x;
	      return rescale();
	    };
	    scale.interpolate = function(x) {
	      if (!arguments.length) return interpolate;
	      interpolate = x;
	      return rescale();
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      d3_scale_linearNice(domain, m);
	      return rescale();
	    };
	    scale.copy = function() {
	      return d3_scale_linear(domain, range, interpolate, clamp);
	    };
	    return rescale();
	  }
	  function d3_scale_linearRebind(scale, linear) {
	    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
	  }
	  function d3_scale_linearNice(domain, m) {
	    return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	  }
	  function d3_scale_linearTickRange(domain, m) {
	    if (m == null) m = 10;
	    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
	    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
	    extent[0] = Math.ceil(extent[0] / step) * step;
	    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
	    extent[2] = step;
	    return extent;
	  }
	  function d3_scale_linearTicks(domain, m) {
	    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
	  }
	  function d3_scale_linearTickFormat(domain, m, format) {
	    var range = d3_scale_linearTickRange(domain, m);
	    if (format) {
	      var match = d3_format_re.exec(format);
	      match.shift();
	      if (match[8] === "s") {
	        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
	        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
	        match[8] = "f";
	        format = d3.format(match.join(""));
	        return function(d) {
	          return format(prefix.scale(d)) + prefix.symbol;
	        };
	      }
	      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
	      format = match.join("");
	    } else {
	      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
	    }
	    return d3.format(format);
	  }
	  var d3_scale_linearFormatSignificant = {
	    s: 1,
	    g: 1,
	    p: 1,
	    r: 1,
	    e: 1
	  };
	  function d3_scale_linearPrecision(value) {
	    return -Math.floor(Math.log(value) / Math.LN10 + .01);
	  }
	  function d3_scale_linearFormatPrecision(type, range) {
	    var p = d3_scale_linearPrecision(range[2]);
	    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
	  }
	  d3.scale.log = function() {
	    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
	  };
	  function d3_scale_log(linear, base, positive, domain) {
	    function log(x) {
	      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
	    }
	    function pow(x) {
	      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
	    }
	    function scale(x) {
	      return linear(log(x));
	    }
	    scale.invert = function(x) {
	      return pow(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      positive = x[0] >= 0;
	      linear.domain((domain = x.map(Number)).map(log));
	      return scale;
	    };
	    scale.base = function(_) {
	      if (!arguments.length) return base;
	      base = +_;
	      linear.domain(domain.map(log));
	      return scale;
	    };
	    scale.nice = function() {
	      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
	      linear.domain(niced);
	      domain = niced.map(pow);
	      return scale;
	    };
	    scale.ticks = function() {
	      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
	      if (isFinite(j - i)) {
	        if (positive) {
	          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
	          ticks.push(pow(i));
	        } else {
	          ticks.push(pow(i));
	          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
	        }
	        for (i = 0; ticks[i] < u; i++) {}
	        for (j = ticks.length; ticks[j - 1] > v; j--) {}
	        ticks = ticks.slice(i, j);
	      }
	      return ticks;
	    };
	    scale.tickFormat = function(n, format) {
	      if (!arguments.length) return d3_scale_logFormat;
	      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
	      var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
	      Math.floor), e;
	      return function(d) {
	        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
	      };
	    };
	    scale.copy = function() {
	      return d3_scale_log(linear.copy(), base, positive, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
	    floor: function(x) {
	      return -Math.ceil(-x);
	    },
	    ceil: function(x) {
	      return -Math.floor(-x);
	    }
	  };
	  d3.scale.pow = function() {
	    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
	  };
	  function d3_scale_pow(linear, exponent, domain) {
	    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
	    function scale(x) {
	      return linear(powp(x));
	    }
	    scale.invert = function(x) {
	      return powb(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      linear.domain((domain = x.map(Number)).map(powp));
	      return scale;
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      return scale.domain(d3_scale_linearNice(domain, m));
	    };
	    scale.exponent = function(x) {
	      if (!arguments.length) return exponent;
	      powp = d3_scale_powPow(exponent = x);
	      powb = d3_scale_powPow(1 / exponent);
	      linear.domain(domain.map(powp));
	      return scale;
	    };
	    scale.copy = function() {
	      return d3_scale_pow(linear.copy(), exponent, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_scale_powPow(e) {
	    return function(x) {
	      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
	    };
	  }
	  d3.scale.sqrt = function() {
	    return d3.scale.pow().exponent(.5);
	  };
	  d3.scale.ordinal = function() {
	    return d3_scale_ordinal([], {
	      t: "range",
	      a: [ [] ]
	    });
	  };
	  function d3_scale_ordinal(domain, ranger) {
	    var index, range, rangeBand;
	    function scale(x) {
	      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
	    }
	    function steps(start, step) {
	      return d3.range(domain.length).map(function(i) {
	        return start + step * i;
	      });
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = [];
	      index = new d3_Map();
	      var i = -1, n = x.length, xi;
	      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
	      return scale[ranger.t].apply(scale, ranger.a);
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      rangeBand = 0;
	      ranger = {
	        t: "range",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangePoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
	      0) : (stop - start) / (domain.length - 1 + padding);
	      range = steps(start + step * padding / 2, step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangePoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundPoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
	      0) : (stop - start) / (domain.length - 1 + padding) | 0;
	      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangeRoundPoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
	      range = steps(start + step * outerPadding, step);
	      if (reverse) range.reverse();
	      rangeBand = step * (1 - padding);
	      ranger = {
	        t: "rangeBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
	      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
	      if (reverse) range.reverse();
	      rangeBand = Math.round(step * (1 - padding));
	      ranger = {
	        t: "rangeRoundBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBand = function() {
	      return rangeBand;
	    };
	    scale.rangeExtent = function() {
	      return d3_scaleExtent(ranger.a[0]);
	    };
	    scale.copy = function() {
	      return d3_scale_ordinal(domain, ranger);
	    };
	    return scale.domain(domain);
	  }
	  d3.scale.category10 = function() {
	    return d3.scale.ordinal().range(d3_category10);
	  };
	  d3.scale.category20 = function() {
	    return d3.scale.ordinal().range(d3_category20);
	  };
	  d3.scale.category20b = function() {
	    return d3.scale.ordinal().range(d3_category20b);
	  };
	  d3.scale.category20c = function() {
	    return d3.scale.ordinal().range(d3_category20c);
	  };
	  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
	  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
	  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
	  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
	  d3.scale.quantile = function() {
	    return d3_scale_quantile([], []);
	  };
	  function d3_scale_quantile(domain, range) {
	    var thresholds;
	    function rescale() {
	      var k = 0, q = range.length;
	      thresholds = [];
	      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
	      return scale;
	    }
	    function scale(x) {
	      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.quantiles = function() {
	      return thresholds;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantile(domain, range);
	    };
	    return rescale();
	  }
	  d3.scale.quantize = function() {
	    return d3_scale_quantize(0, 1, [ 0, 1 ]);
	  };
	  function d3_scale_quantize(x0, x1, range) {
	    var kx, i;
	    function scale(x) {
	      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
	    }
	    function rescale() {
	      kx = range.length / (x1 - x0);
	      i = range.length - 1;
	      return scale;
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return [ x0, x1 ];
	      x0 = +x[0];
	      x1 = +x[x.length - 1];
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      y = y < 0 ? NaN : y / kx + x0;
	      return [ y, y + 1 / kx ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantize(x0, x1, range);
	    };
	    return rescale();
	  }
	  d3.scale.threshold = function() {
	    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
	  };
	  function d3_scale_threshold(domain, range) {
	    function scale(x) {
	      if (x <= x) return range[d3.bisect(domain, x)];
	    }
	    scale.domain = function(_) {
	      if (!arguments.length) return domain;
	      domain = _;
	      return scale;
	    };
	    scale.range = function(_) {
	      if (!arguments.length) return range;
	      range = _;
	      return scale;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return [ domain[y - 1], domain[y] ];
	    };
	    scale.copy = function() {
	      return d3_scale_threshold(domain, range);
	    };
	    return scale;
	  }
	  d3.scale.identity = function() {
	    return d3_scale_identity([ 0, 1 ]);
	  };
	  function d3_scale_identity(domain) {
	    function identity(x) {
	      return +x;
	    }
	    identity.invert = identity;
	    identity.domain = identity.range = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(identity);
	      return identity;
	    };
	    identity.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    identity.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    identity.copy = function() {
	      return d3_scale_identity(domain);
	    };
	    return identity;
	  }
	  d3.svg = {};
	  function d3_zero() {
	    return 0;
	  }
	  d3.svg.arc = function() {
	    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
	    function arc() {
	      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
	      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
	      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
	      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
	      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
	        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
	        if (!cw) p1 *= -1;
	        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
	        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
	      }
	      if (r1) {
	        x0 = r1 * Math.cos(a0 + p1);
	        y0 = r1 * Math.sin(a0 + p1);
	        x1 = r1 * Math.cos(a1 - p1);
	        y1 = r1 * Math.sin(a1 - p1);
	        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
	        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
	          var h1 = (a0 + a1) / 2;
	          x0 = r1 * Math.cos(h1);
	          y0 = r1 * Math.sin(h1);
	          x1 = y1 = null;
	        }
	      } else {
	        x0 = y0 = 0;
	      }
	      if (r0) {
	        x2 = r0 * Math.cos(a1 - p0);
	        y2 = r0 * Math.sin(a1 - p0);
	        x3 = r0 * Math.cos(a0 + p0);
	        y3 = r0 * Math.sin(a0 + p0);
	        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
	        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
	          var h0 = (a0 + a1) / 2;
	          x2 = r0 * Math.cos(h0);
	          y2 = r0 * Math.sin(h0);
	          x3 = y3 = null;
	        }
	      } else {
	        x2 = y2 = 0;
	      }
	      if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
	        cr = r0 < r1 ^ cw ? 0 : 1;
	        var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	        if (x1 != null) {
	          var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
	          if (rc === rc1) {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
	          } else {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
	          }
	        } else {
	          path.push("M", x0, ",", y0);
	        }
	        if (x3 != null) {
	          var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
	          if (rc === rc0) {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          } else {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          }
	        } else {
	          path.push("L", x2, ",", y2);
	        }
	      } else {
	        path.push("M", x0, ",", y0);
	        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
	        path.push("L", x2, ",", y2);
	        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
	      }
	      path.push("Z");
	      return path.join("");
	    }
	    function circleSegment(r1, cw) {
	      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
	    }
	    arc.innerRadius = function(v) {
	      if (!arguments.length) return innerRadius;
	      innerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.outerRadius = function(v) {
	      if (!arguments.length) return outerRadius;
	      outerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.cornerRadius = function(v) {
	      if (!arguments.length) return cornerRadius;
	      cornerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.padRadius = function(v) {
	      if (!arguments.length) return padRadius;
	      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
	      return arc;
	    };
	    arc.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return arc;
	    };
	    arc.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return arc;
	    };
	    arc.padAngle = function(v) {
	      if (!arguments.length) return padAngle;
	      padAngle = d3_functor(v);
	      return arc;
	    };
	    arc.centroid = function() {
	      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
	      return [ Math.cos(a) * r, Math.sin(a) * r ];
	    };
	    return arc;
	  };
	  var d3_svg_arcAuto = "auto";
	  function d3_svg_arcInnerRadius(d) {
	    return d.innerRadius;
	  }
	  function d3_svg_arcOuterRadius(d) {
	    return d.outerRadius;
	  }
	  function d3_svg_arcStartAngle(d) {
	    return d.startAngle;
	  }
	  function d3_svg_arcEndAngle(d) {
	    return d.endAngle;
	  }
	  function d3_svg_arcPadAngle(d) {
	    return d && d.padAngle;
	  }
	  function d3_svg_arcSweep(x0, y0, x1, y1) {
	    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
	  }
	  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
	    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
	    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
	    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
	  }
	  function d3_svg_line(projection) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
	    function line(data) {
	      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
	      function segment() {
	        segments.push("M", interpolate(projection(points), tension));
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
	        } else if (points.length) {
	          segment();
	          points = [];
	        }
	      }
	      if (points.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    line.x = function(_) {
	      if (!arguments.length) return x;
	      x = _;
	      return line;
	    };
	    line.y = function(_) {
	      if (!arguments.length) return y;
	      y = _;
	      return line;
	    };
	    line.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return line;
	    };
	    line.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      return line;
	    };
	    line.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return line;
	    };
	    return line;
	  }
	  d3.svg.line = function() {
	    return d3_svg_line(d3_identity);
	  };
	  var d3_svg_lineInterpolators = d3.map({
	    linear: d3_svg_lineLinear,
	    "linear-closed": d3_svg_lineLinearClosed,
	    step: d3_svg_lineStep,
	    "step-before": d3_svg_lineStepBefore,
	    "step-after": d3_svg_lineStepAfter,
	    basis: d3_svg_lineBasis,
	    "basis-open": d3_svg_lineBasisOpen,
	    "basis-closed": d3_svg_lineBasisClosed,
	    bundle: d3_svg_lineBundle,
	    cardinal: d3_svg_lineCardinal,
	    "cardinal-open": d3_svg_lineCardinalOpen,
	    "cardinal-closed": d3_svg_lineCardinalClosed,
	    monotone: d3_svg_lineMonotone
	  });
	  d3_svg_lineInterpolators.forEach(function(key, value) {
	    value.key = key;
	    value.closed = /-closed$/.test(key);
	  });
	  function d3_svg_lineLinear(points) {
	    return points.join("L");
	  }
	  function d3_svg_lineLinearClosed(points) {
	    return d3_svg_lineLinear(points) + "Z";
	  }
	  function d3_svg_lineStep(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
	    if (n > 1) path.push("H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepBefore(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepAfter(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
	    return path.join("");
	  }
	  function d3_svg_lineCardinalOpen(points, tension) {
	    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineCardinalClosed(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
	    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
	  }
	  function d3_svg_lineCardinal(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineHermite(points, tangents) {
	    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
	      return d3_svg_lineLinear(points);
	    }
	    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
	    if (quad) {
	      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
	      p0 = points[1];
	      pi = 2;
	    }
	    if (tangents.length > 1) {
	      t = tangents[1];
	      p = points[pi];
	      pi++;
	      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      for (var i = 2; i < tangents.length; i++, pi++) {
	        p = points[pi];
	        t = tangents[i];
	        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      }
	    }
	    if (quad) {
	      var lp = points[pi];
	      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
	    }
	    return path;
	  }
	  function d3_svg_lineCardinalTangents(points, tension) {
	    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
	    while (++i < n) {
	      p0 = p1;
	      p1 = p2;
	      p2 = points[i];
	      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineBasis(points) {
	    if (points.length < 3) return d3_svg_lineLinear(points);
	    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    points.push(points[n - 1]);
	    while (++i <= n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    points.pop();
	    path.push("L", pi);
	    return path.join("");
	  }
	  function d3_svg_lineBasisOpen(points) {
	    if (points.length < 4) return d3_svg_lineLinear(points);
	    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
	    while (++i < 3) {
	      pi = points[i];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
	    --i;
	    while (++i < n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBasisClosed(points) {
	    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
	    while (++i < 4) {
	      pi = points[i % n];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    --i;
	    while (++i < m) {
	      pi = points[i % n];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBundle(points, tension) {
	    var n = points.length - 1;
	    if (n) {
	      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
	      while (++i <= n) {
	        p = points[i];
	        t = i / n;
	        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
	        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
	      }
	    }
	    return d3_svg_lineBasis(points);
	  }
	  function d3_svg_lineDot4(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	  }
	  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
	  function d3_svg_lineBasisBezier(path, x, y) {
	    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
	  }
	  function d3_svg_lineSlope(p0, p1) {
	    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
	  }
	  function d3_svg_lineFiniteDifferences(points) {
	    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
	    while (++i < j) {
	      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
	    }
	    m[i] = d;
	    return m;
	  }
	  function d3_svg_lineMonotoneTangents(points) {
	    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
	    while (++i < j) {
	      d = d3_svg_lineSlope(points[i], points[i + 1]);
	      if (abs(d) < ε) {
	        m[i] = m[i + 1] = 0;
	      } else {
	        a = m[i] / d;
	        b = m[i + 1] / d;
	        s = a * a + b * b;
	        if (s > 9) {
	          s = d * 3 / Math.sqrt(s);
	          m[i] = s * a;
	          m[i + 1] = s * b;
	        }
	      }
	    }
	    i = -1;
	    while (++i <= j) {
	      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
	      tangents.push([ s || 0, m[i] * s || 0 ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineMonotone(points) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
	  }
	  d3.svg.line.radial = function() {
	    var line = d3_svg_line(d3_svg_lineRadial);
	    line.radius = line.x, delete line.x;
	    line.angle = line.y, delete line.y;
	    return line;
	  };
	  function d3_svg_lineRadial(points) {
	    var point, i = -1, n = points.length, r, a;
	    while (++i < n) {
	      point = points[i];
	      r = point[0];
	      a = point[1] - halfπ;
	      point[0] = r * Math.cos(a);
	      point[1] = r * Math.sin(a);
	    }
	    return points;
	  }
	  function d3_svg_area(projection) {
	    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
	    function area(data) {
	      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
	        return x;
	      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
	        return y;
	      } : d3_functor(y1), x, y;
	      function segment() {
	        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
	          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
	        } else if (points0.length) {
	          segment();
	          points0 = [];
	          points1 = [];
	        }
	      }
	      if (points0.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    area.x = function(_) {
	      if (!arguments.length) return x1;
	      x0 = x1 = _;
	      return area;
	    };
	    area.x0 = function(_) {
	      if (!arguments.length) return x0;
	      x0 = _;
	      return area;
	    };
	    area.x1 = function(_) {
	      if (!arguments.length) return x1;
	      x1 = _;
	      return area;
	    };
	    area.y = function(_) {
	      if (!arguments.length) return y1;
	      y0 = y1 = _;
	      return area;
	    };
	    area.y0 = function(_) {
	      if (!arguments.length) return y0;
	      y0 = _;
	      return area;
	    };
	    area.y1 = function(_) {
	      if (!arguments.length) return y1;
	      y1 = _;
	      return area;
	    };
	    area.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return area;
	    };
	    area.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      interpolateReverse = interpolate.reverse || interpolate;
	      L = interpolate.closed ? "M" : "L";
	      return area;
	    };
	    area.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return area;
	    };
	    return area;
	  }
	  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
	  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
	  d3.svg.area = function() {
	    return d3_svg_area(d3_identity);
	  };
	  d3.svg.area.radial = function() {
	    var area = d3_svg_area(d3_svg_lineRadial);
	    area.radius = area.x, delete area.x;
	    area.innerRadius = area.x0, delete area.x0;
	    area.outerRadius = area.x1, delete area.x1;
	    area.angle = area.y, delete area.y;
	    area.startAngle = area.y0, delete area.y0;
	    area.endAngle = area.y1, delete area.y1;
	    return area;
	  };
	  d3.svg.chord = function() {
	    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
	    function chord(d, i) {
	      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
	      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
	    }
	    function subgroup(self, f, d, i) {
	      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
	      return {
	        r: r,
	        a0: a0,
	        a1: a1,
	        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
	        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
	      };
	    }
	    function equals(a, b) {
	      return a.a0 == b.a0 && a.a1 == b.a1;
	    }
	    function arc(r, p, a) {
	      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
	    }
	    function curve(r0, p0, r1, p1) {
	      return "Q 0,0 " + p1;
	    }
	    chord.radius = function(v) {
	      if (!arguments.length) return radius;
	      radius = d3_functor(v);
	      return chord;
	    };
	    chord.source = function(v) {
	      if (!arguments.length) return source;
	      source = d3_functor(v);
	      return chord;
	    };
	    chord.target = function(v) {
	      if (!arguments.length) return target;
	      target = d3_functor(v);
	      return chord;
	    };
	    chord.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return chord;
	    };
	    chord.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return chord;
	    };
	    return chord;
	  };
	  function d3_svg_chordRadius(d) {
	    return d.radius;
	  }
	  d3.svg.diagonal = function() {
	    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
	    function diagonal(d, i) {
	      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
	        x: p0.x,
	        y: m
	      }, {
	        x: p3.x,
	        y: m
	      }, p3 ];
	      p = p.map(projection);
	      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
	    }
	    diagonal.source = function(x) {
	      if (!arguments.length) return source;
	      source = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.target = function(x) {
	      if (!arguments.length) return target;
	      target = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.projection = function(x) {
	      if (!arguments.length) return projection;
	      projection = x;
	      return diagonal;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalProjection(d) {
	    return [ d.x, d.y ];
	  }
	  d3.svg.diagonal.radial = function() {
	    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
	    diagonal.projection = function(x) {
	      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalRadialProjection(projection) {
	    return function() {
	      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
	      return [ r * Math.cos(a), r * Math.sin(a) ];
	    };
	  }
	  d3.svg.symbol = function() {
	    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
	    function symbol(d, i) {
	      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
	    }
	    symbol.type = function(x) {
	      if (!arguments.length) return type;
	      type = d3_functor(x);
	      return symbol;
	    };
	    symbol.size = function(x) {
	      if (!arguments.length) return size;
	      size = d3_functor(x);
	      return symbol;
	    };
	    return symbol;
	  };
	  function d3_svg_symbolSize() {
	    return 64;
	  }
	  function d3_svg_symbolType() {
	    return "circle";
	  }
	  function d3_svg_symbolCircle(size) {
	    var r = Math.sqrt(size / π);
	    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
	  }
	  var d3_svg_symbols = d3.map({
	    circle: d3_svg_symbolCircle,
	    cross: function(size) {
	      var r = Math.sqrt(size / 5) / 2;
	      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
	    },
	    diamond: function(size) {
	      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
	      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
	    },
	    square: function(size) {
	      var r = Math.sqrt(size) / 2;
	      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
	    },
	    "triangle-down": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
	    },
	    "triangle-up": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
	    }
	  });
	  d3.svg.symbolTypes = d3_svg_symbols.keys();
	  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
	  d3_selectionPrototype.transition = function(name) {
	    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
	      time: Date.now(),
	      ease: d3_ease_cubicInOut,
	      delay: 0,
	      duration: 250
	    };
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_selectionPrototype.interrupt = function(name) {
	    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
	  };
	  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
	  function d3_selection_interruptNS(ns) {
	    return function() {
	      var lock, active;
	      if ((lock = this[ns]) && (active = lock[lock.active])) {
	        if (--lock.count) delete lock[lock.active]; else delete this[ns];
	        lock.active += .5;
	        active.event && active.event.interrupt.call(this, this.__data__, active.index);
	      }
	    };
	  }
	  function d3_transition(groups, ns, id) {
	    d3_subclass(groups, d3_transitionPrototype);
	    groups.namespace = ns;
	    groups.id = id;
	    return groups;
	  }
	  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
	  d3_transitionPrototype.call = d3_selectionPrototype.call;
	  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
	  d3_transitionPrototype.node = d3_selectionPrototype.node;
	  d3_transitionPrototype.size = d3_selectionPrototype.size;
	  d3.transition = function(selection, name) {
	    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
	  };
	  d3.transition.prototype = d3_transitionPrototype;
	  d3_transitionPrototype.select = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
	          if ("__data__" in node) subnode.__data__ = node.__data__;
	          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
	          subgroup.push(subnode);
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.selectAll = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          transition = node[ns][id];
	          subnodes = selector.call(node, node.__data__, i, j);
	          subgroups.push(subgroup = []);
	          for (var k = -1, o = subnodes.length; ++k < o; ) {
	            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
	            subgroup.push(subnode);
	          }
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_transition(subgroups, this.namespace, this.id);
	  };
	  d3_transitionPrototype.tween = function(name, tween) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
	    return d3_selection_each(this, tween == null ? function(node) {
	      node[ns][id].tween.remove(name);
	    } : function(node) {
	      node[ns][id].tween.set(name, tween);
	    });
	  };
	  function d3_transition_tween(groups, name, value, tween) {
	    var id = groups.id, ns = groups.namespace;
	    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
	    } : (value = tween(value), function(node) {
	      node[ns][id].tween.set(name, value);
	    }));
	  }
	  d3_transitionPrototype.attr = function(nameNS, value) {
	    if (arguments.length < 2) {
	      for (value in nameNS) this.attr(value, nameNS[value]);
	      return this;
	    }
	    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrTween(b) {
	      return b == null ? attrNull : (b += "", function() {
	        var a = this.getAttribute(name), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttribute(name, i(t));
	        });
	      });
	    }
	    function attrTweenNS(b) {
	      return b == null ? attrNullNS : (b += "", function() {
	        var a = this.getAttributeNS(name.space, name.local), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttributeNS(name.space, name.local, i(t));
	        });
	      });
	    }
	    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.attrTween = function(nameNS, tween) {
	    var name = d3.ns.qualify(nameNS);
	    function attrTween(d, i) {
	      var f = tween.call(this, d, i, this.getAttribute(name));
	      return f && function(t) {
	        this.setAttribute(name, f(t));
	      };
	    }
	    function attrTweenNS(d, i) {
	      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
	      return f && function(t) {
	        this.setAttributeNS(name.space, name.local, f(t));
	      };
	    }
	    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.style(priority, name[priority], value);
	        return this;
	      }
	      priority = "";
	    }
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleString(b) {
	      return b == null ? styleNull : (b += "", function() {
	        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
	        return a !== b && (i = d3_interpolate(a, b), function(t) {
	          this.style.setProperty(name, i(t), priority);
	        });
	      });
	    }
	    return d3_transition_tween(this, "style." + name, value, styleString);
	  };
	  d3_transitionPrototype.styleTween = function(name, tween, priority) {
	    if (arguments.length < 3) priority = "";
	    function styleTween(d, i) {
	      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
	      return f && function(t) {
	        this.style.setProperty(name, f(t), priority);
	      };
	    }
	    return this.tween("style." + name, styleTween);
	  };
	  d3_transitionPrototype.text = function(value) {
	    return d3_transition_tween(this, "text", value, d3_transition_text);
	  };
	  function d3_transition_text(b) {
	    if (b == null) b = "";
	    return function() {
	      this.textContent = b;
	    };
	  }
	  d3_transitionPrototype.remove = function() {
	    var ns = this.namespace;
	    return this.each("end.transition", function() {
	      var p;
	      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
	    });
	  };
	  d3_transitionPrototype.ease = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].ease;
	    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
	    return d3_selection_each(this, function(node) {
	      node[ns][id].ease = value;
	    });
	  };
	  d3_transitionPrototype.delay = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].delay;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].delay = +value.call(node, node.__data__, i, j);
	    } : (value = +value, function(node) {
	      node[ns][id].delay = value;
	    }));
	  };
	  d3_transitionPrototype.duration = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].duration;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
	    } : (value = Math.max(1, value), function(node) {
	      node[ns][id].duration = value;
	    }));
	  };
	  d3_transitionPrototype.each = function(type, listener) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) {
	      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
	      try {
	        d3_transitionInheritId = id;
	        d3_selection_each(this, function(node, i, j) {
	          d3_transitionInherit = node[ns][id];
	          type.call(node, node.__data__, i, j);
	        });
	      } finally {
	        d3_transitionInherit = inherit;
	        d3_transitionInheritId = inheritId;
	      }
	    } else {
	      d3_selection_each(this, function(node) {
	        var transition = node[ns][id];
	        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
	      });
	    }
	    return this;
	  };
	  d3_transitionPrototype.transition = function() {
	    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if (node = group[i]) {
	          transition = node[ns][id0];
	          d3_transitionNode(node, i, ns, id1, {
	            time: transition.time,
	            ease: transition.ease,
	            delay: transition.delay + transition.duration,
	            duration: transition.duration
	          });
	        }
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id1);
	  };
	  function d3_transitionNamespace(name) {
	    return name == null ? "__transition__" : "__transition_" + name + "__";
	  }
	  function d3_transitionNode(node, i, ns, id, inherit) {
	    var lock = node[ns] || (node[ns] = {
	      active: 0,
	      count: 0
	    }), transition = lock[id];
	    if (!transition) {
	      var time = inherit.time;
	      transition = lock[id] = {
	        tween: new d3_Map(),
	        time: time,
	        delay: inherit.delay,
	        duration: inherit.duration,
	        ease: inherit.ease,
	        index: i
	      };
	      inherit = null;
	      ++lock.count;
	      d3.timer(function(elapsed) {
	        var delay = transition.delay, duration, ease, timer = d3_timer_active, tweened = [];
	        timer.t = delay + time;
	        if (delay <= elapsed) return start(elapsed - delay);
	        timer.c = start;
	        function start(elapsed) {
	          if (lock.active > id) return stop();
	          var active = lock[lock.active];
	          if (active) {
	            --lock.count;
	            delete lock[lock.active];
	            active.event && active.event.interrupt.call(node, node.__data__, active.index);
	          }
	          lock.active = id;
	          transition.event && transition.event.start.call(node, node.__data__, i);
	          transition.tween.forEach(function(key, value) {
	            if (value = value.call(node, node.__data__, i)) {
	              tweened.push(value);
	            }
	          });
	          ease = transition.ease;
	          duration = transition.duration;
	          d3.timer(function() {
	            timer.c = tick(elapsed || 1) ? d3_true : tick;
	            return 1;
	          }, 0, time);
	        }
	        function tick(elapsed) {
	          if (lock.active !== id) return 1;
	          var t = elapsed / duration, e = ease(t), n = tweened.length;
	          while (n > 0) {
	            tweened[--n].call(node, e);
	          }
	          if (t >= 1) {
	            transition.event && transition.event.end.call(node, node.__data__, i);
	            return stop();
	          }
	        }
	        function stop() {
	          if (--lock.count) delete lock[id]; else delete node[ns];
	          return 1;
	        }
	      }, 0, time);
	    }
	  }
	  d3.svg.axis = function() {
	    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
	    function axis(g) {
	      g.each(function() {
	        var g = d3.select(this);
	        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
	        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
	        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
	        d3.transition(path));
	        tickEnter.append("line");
	        tickEnter.append("text");
	        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
	        if (orient === "bottom" || orient === "top") {
	          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
	          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
	          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
	        } else {
	          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
	          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
	          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
	        }
	        lineEnter.attr(y2, sign * innerTickSize);
	        textEnter.attr(y1, sign * tickSpacing);
	        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
	        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
	        if (scale1.rangeBand) {
	          var x = scale1, dx = x.rangeBand() / 2;
	          scale0 = scale1 = function(d) {
	            return x(d) + dx;
	          };
	        } else if (scale0.rangeBand) {
	          scale0 = scale1;
	        } else {
	          tickExit.call(tickTransform, scale1, scale0);
	        }
	        tickEnter.call(tickTransform, scale0, scale1);
	        tickUpdate.call(tickTransform, scale1, scale1);
	      });
	    }
	    axis.scale = function(x) {
	      if (!arguments.length) return scale;
	      scale = x;
	      return axis;
	    };
	    axis.orient = function(x) {
	      if (!arguments.length) return orient;
	      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
	      return axis;
	    };
	    axis.ticks = function() {
	      if (!arguments.length) return tickArguments_;
	      tickArguments_ = arguments;
	      return axis;
	    };
	    axis.tickValues = function(x) {
	      if (!arguments.length) return tickValues;
	      tickValues = x;
	      return axis;
	    };
	    axis.tickFormat = function(x) {
	      if (!arguments.length) return tickFormat_;
	      tickFormat_ = x;
	      return axis;
	    };
	    axis.tickSize = function(x) {
	      var n = arguments.length;
	      if (!n) return innerTickSize;
	      innerTickSize = +x;
	      outerTickSize = +arguments[n - 1];
	      return axis;
	    };
	    axis.innerTickSize = function(x) {
	      if (!arguments.length) return innerTickSize;
	      innerTickSize = +x;
	      return axis;
	    };
	    axis.outerTickSize = function(x) {
	      if (!arguments.length) return outerTickSize;
	      outerTickSize = +x;
	      return axis;
	    };
	    axis.tickPadding = function(x) {
	      if (!arguments.length) return tickPadding;
	      tickPadding = +x;
	      return axis;
	    };
	    axis.tickSubdivide = function() {
	      return arguments.length && axis;
	    };
	    return axis;
	  };
	  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
	    top: 1,
	    right: 1,
	    bottom: 1,
	    left: 1
	  };
	  function d3_svg_axisX(selection, x0, x1) {
	    selection.attr("transform", function(d) {
	      var v0 = x0(d);
	      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
	    });
	  }
	  function d3_svg_axisY(selection, y0, y1) {
	    selection.attr("transform", function(d) {
	      var v0 = y0(d);
	      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
	    });
	  }
	  d3.svg.brush = function() {
	    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
	    function brush(g) {
	      g.each(function() {
	        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
	        var background = g.selectAll(".background").data([ 0 ]);
	        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
	        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
	        var resize = g.selectAll(".resize").data(resizes, d3_identity);
	        resize.exit().remove();
	        resize.enter().append("g").attr("class", function(d) {
	          return "resize " + d;
	        }).style("cursor", function(d) {
	          return d3_svg_brushCursor[d];
	        }).append("rect").attr("x", function(d) {
	          return /[ew]$/.test(d) ? -3 : null;
	        }).attr("y", function(d) {
	          return /^[ns]/.test(d) ? -3 : null;
	        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
	        resize.style("display", brush.empty() ? "none" : null);
	        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
	        if (x) {
	          range = d3_scaleRange(x);
	          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
	          redrawX(gUpdate);
	        }
	        if (y) {
	          range = d3_scaleRange(y);
	          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
	          redrawY(gUpdate);
	        }
	        redraw(gUpdate);
	      });
	    }
	    brush.event = function(g) {
	      g.each(function() {
	        var event_ = event.of(this, arguments), extent1 = {
	          x: xExtent,
	          y: yExtent,
	          i: xExtentDomain,
	          j: yExtentDomain
	        }, extent0 = this.__chart__ || extent1;
	        this.__chart__ = extent1;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.brush", function() {
	            xExtentDomain = extent0.i;
	            yExtentDomain = extent0.j;
	            xExtent = extent0.x;
	            yExtent = extent0.y;
	            event_({
	              type: "brushstart"
	            });
	          }).tween("brush:brush", function() {
	            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
	            xExtentDomain = yExtentDomain = null;
	            return function(t) {
	              xExtent = extent1.x = xi(t);
	              yExtent = extent1.y = yi(t);
	              event_({
	                type: "brush",
	                mode: "resize"
	              });
	            };
	          }).each("end.brush", function() {
	            xExtentDomain = extent1.i;
	            yExtentDomain = extent1.j;
	            event_({
	              type: "brush",
	              mode: "resize"
	            });
	            event_({
	              type: "brushend"
	            });
	          });
	        } else {
	          event_({
	            type: "brushstart"
	          });
	          event_({
	            type: "brush",
	            mode: "resize"
	          });
	          event_({
	            type: "brushend"
	          });
	        }
	      });
	    };
	    function redraw(g) {
	      g.selectAll(".resize").attr("transform", function(d) {
	        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
	      });
	    }
	    function redrawX(g) {
	      g.select(".extent").attr("x", xExtent[0]);
	      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
	    }
	    function redrawY(g) {
	      g.select(".extent").attr("y", yExtent[0]);
	      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
	    }
	    function brushstart() {
	      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
	      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
	      if (d3.event.changedTouches) {
	        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
	      } else {
	        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
	      }
	      g.interrupt().selectAll("*").interrupt();
	      if (dragging) {
	        origin[0] = xExtent[0] - origin[0];
	        origin[1] = yExtent[0] - origin[1];
	      } else if (resizing) {
	        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
	        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
	        origin[0] = xExtent[ex];
	        origin[1] = yExtent[ey];
	      } else if (d3.event.altKey) center = origin.slice();
	      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
	      d3.select("body").style("cursor", eventTarget.style("cursor"));
	      event_({
	        type: "brushstart"
	      });
	      brushmove();
	      function keydown() {
	        if (d3.event.keyCode == 32) {
	          if (!dragging) {
	            center = null;
	            origin[0] -= xExtent[1];
	            origin[1] -= yExtent[1];
	            dragging = 2;
	          }
	          d3_eventPreventDefault();
	        }
	      }
	      function keyup() {
	        if (d3.event.keyCode == 32 && dragging == 2) {
	          origin[0] += xExtent[1];
	          origin[1] += yExtent[1];
	          dragging = 0;
	          d3_eventPreventDefault();
	        }
	      }
	      function brushmove() {
	        var point = d3.mouse(target), moved = false;
	        if (offset) {
	          point[0] += offset[0];
	          point[1] += offset[1];
	        }
	        if (!dragging) {
	          if (d3.event.altKey) {
	            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
	            origin[0] = xExtent[+(point[0] < center[0])];
	            origin[1] = yExtent[+(point[1] < center[1])];
	          } else center = null;
	        }
	        if (resizingX && move1(point, x, 0)) {
	          redrawX(g);
	          moved = true;
	        }
	        if (resizingY && move1(point, y, 1)) {
	          redrawY(g);
	          moved = true;
	        }
	        if (moved) {
	          redraw(g);
	          event_({
	            type: "brush",
	            mode: dragging ? "move" : "resize"
	          });
	        }
	      }
	      function move1(point, scale, i) {
	        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
	        if (dragging) {
	          r0 -= position;
	          r1 -= size + position;
	        }
	        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
	        if (dragging) {
	          max = (min += position) + size;
	        } else {
	          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
	          if (position < min) {
	            max = min;
	            min = position;
	          } else {
	            max = position;
	          }
	        }
	        if (extent[0] != min || extent[1] != max) {
	          if (i) yExtentDomain = null; else xExtentDomain = null;
	          extent[0] = min;
	          extent[1] = max;
	          return true;
	        }
	      }
	      function brushend() {
	        brushmove();
	        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
	        d3.select("body").style("cursor", null);
	        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
	        dragRestore();
	        event_({
	          type: "brushend"
	        });
	      }
	    }
	    brush.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.clamp = function(z) {
	      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
	      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
	      return brush;
	    };
	    brush.extent = function(z) {
	      var x0, x1, y0, y1, t;
	      if (!arguments.length) {
	        if (x) {
	          if (xExtentDomain) {
	            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
	          } else {
	            x0 = xExtent[0], x1 = xExtent[1];
	            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
	            if (x1 < x0) t = x0, x0 = x1, x1 = t;
	          }
	        }
	        if (y) {
	          if (yExtentDomain) {
	            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
	          } else {
	            y0 = yExtent[0], y1 = yExtent[1];
	            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
	            if (y1 < y0) t = y0, y0 = y1, y1 = t;
	          }
	        }
	        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
	      }
	      if (x) {
	        x0 = z[0], x1 = z[1];
	        if (y) x0 = x0[0], x1 = x1[0];
	        xExtentDomain = [ x0, x1 ];
	        if (x.invert) x0 = x(x0), x1 = x(x1);
	        if (x1 < x0) t = x0, x0 = x1, x1 = t;
	        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
	      }
	      if (y) {
	        y0 = z[0], y1 = z[1];
	        if (x) y0 = y0[1], y1 = y1[1];
	        yExtentDomain = [ y0, y1 ];
	        if (y.invert) y0 = y(y0), y1 = y(y1);
	        if (y1 < y0) t = y0, y0 = y1, y1 = t;
	        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
	      }
	      return brush;
	    };
	    brush.clear = function() {
	      if (!brush.empty()) {
	        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
	        xExtentDomain = yExtentDomain = null;
	      }
	      return brush;
	    };
	    brush.empty = function() {
	      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
	    };
	    return d3.rebind(brush, event, "on");
	  };
	  var d3_svg_brushCursor = {
	    n: "ns-resize",
	    e: "ew-resize",
	    s: "ns-resize",
	    w: "ew-resize",
	    nw: "nwse-resize",
	    ne: "nesw-resize",
	    se: "nwse-resize",
	    sw: "nesw-resize"
	  };
	  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
	  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
	  var d3_time_formatUtc = d3_time_format.utc;
	  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
	  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
	  function d3_time_formatIsoNative(date) {
	    return date.toISOString();
	  }
	  d3_time_formatIsoNative.parse = function(string) {
	    var date = new Date(string);
	    return isNaN(date) ? null : date;
	  };
	  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
	  d3_time.second = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 1e3) * 1e3);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
	  }, function(date) {
	    return date.getSeconds();
	  });
	  d3_time.seconds = d3_time.second.range;
	  d3_time.seconds.utc = d3_time.second.utc.range;
	  d3_time.minute = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 6e4) * 6e4);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
	  }, function(date) {
	    return date.getMinutes();
	  });
	  d3_time.minutes = d3_time.minute.range;
	  d3_time.minutes.utc = d3_time.minute.utc.range;
	  d3_time.hour = d3_time_interval(function(date) {
	    var timezone = date.getTimezoneOffset() / 60;
	    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
	  }, function(date) {
	    return date.getHours();
	  });
	  d3_time.hours = d3_time.hour.range;
	  d3_time.hours.utc = d3_time.hour.utc.range;
	  d3_time.month = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setDate(1);
	    return date;
	  }, function(date, offset) {
	    date.setMonth(date.getMonth() + offset);
	  }, function(date) {
	    return date.getMonth();
	  });
	  d3_time.months = d3_time.month.range;
	  d3_time.months.utc = d3_time.month.utc.range;
	  function d3_time_scale(linear, methods, format) {
	    function scale(x) {
	      return linear(x);
	    }
	    scale.invert = function(x) {
	      return d3_time_scaleDate(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
	      linear.domain(x);
	      return scale;
	    };
	    function tickMethod(extent, count) {
	      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
	      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
	        return d / 31536e6;
	      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
	    }
	    scale.nice = function(interval, skip) {
	      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
	      if (method) interval = method[0], skip = method[1];
	      function skipped(date) {
	        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
	      }
	      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
	        floor: function(date) {
	          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
	          return date;
	        },
	        ceil: function(date) {
	          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
	          return date;
	        }
	      } : interval));
	    };
	    scale.ticks = function(interval, skip) {
	      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
	        range: interval
	      }, skip ];
	      if (method) interval = method[0], skip = method[1];
	      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
	    };
	    scale.tickFormat = function() {
	      return format;
	    };
	    scale.copy = function() {
	      return d3_time_scale(linear.copy(), methods, format);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_time_scaleDate(t) {
	    return new Date(t);
	  }
	  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
	  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
	  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
	    return d.getMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getHours();
	  } ], [ "%a %d", function(d) {
	    return d.getDay() && d.getDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getMonth();
	  } ], [ "%Y", d3_true ] ]);
	  var d3_time_scaleMilliseconds = {
	    range: function(start, stop, step) {
	      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
	    },
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  d3_time_scaleLocalMethods.year = d3_time.year;
	  d3_time.scale = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
	  };
	  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
	    return [ m[0].utc, m[1] ];
	  });
	  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
	    return d.getUTCMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getUTCSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getUTCMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getUTCHours();
	  } ], [ "%a %d", function(d) {
	    return d.getUTCDay() && d.getUTCDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getUTCDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getUTCMonth();
	  } ], [ "%Y", d3_true ] ]);
	  d3_time_scaleUtcMethods.year = d3_time.year.utc;
	  d3_time.scale.utc = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
	  };
	  d3.text = d3_xhrType(function(request) {
	    return request.responseText;
	  });
	  d3.json = function(url, callback) {
	    return d3_xhr(url, "application/json", d3_json, callback);
	  };
	  function d3_json(request) {
	    return JSON.parse(request.responseText);
	  }
	  d3.html = function(url, callback) {
	    return d3_xhr(url, "text/html", d3_html, callback);
	  };
	  function d3_html(request) {
	    var range = d3_document.createRange();
	    range.selectNode(d3_document.body);
	    return range.createContextualFragment(request.responseText);
	  }
	  d3.xml = d3_xhrType(function(request) {
	    return request.responseXML;
	  });
	  if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3;
	  this.d3 = d3;
	}();

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var Handlebars = __webpack_require__(18);

	function msToTimestamp(milliseconds) {
	    var totalSeconds = Math.round(milliseconds / 1000);
	    var minutes = Math.floor(totalSeconds / 60);
	    var seconds = totalSeconds - minutes * 60;

	    if(isNaN(minutes)) {
	        minutes = '';
	    }

	    if(isNaN(seconds)) {
	        return '';
	    }

	    if(seconds < 10) {
	        seconds = '0' + seconds;
	    }

	    return minutes + ':' + seconds;
	}

	Handlebars.registerHelper('msToTimestamp', msToTimestamp);

	module.exports = msToTimestamp;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	// Create a simple path alias to allow browserify to resolve
	// the runtime on a supported path.
	module.exports = __webpack_require__(19)['default'];


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

	exports.__esModule = true;

	var _import = __webpack_require__(21);

	var base = _interopRequireWildcard(_import);

	// Each of these augment the Handlebars object. No need to setup here.
	// (This is done to easily share code between commonjs and browse envs)

	var _SafeString = __webpack_require__(23);

	var _SafeString2 = _interopRequireWildcard(_SafeString);

	var _Exception = __webpack_require__(22);

	var _Exception2 = _interopRequireWildcard(_Exception);

	var _import2 = __webpack_require__(20);

	var Utils = _interopRequireWildcard(_import2);

	var _import3 = __webpack_require__(24);

	var runtime = _interopRequireWildcard(_import3);

	var _noConflict = __webpack_require__(25);

	var _noConflict2 = _interopRequireWildcard(_noConflict);

	// For compatibility and usage outside of module systems, make the Handlebars object a namespace
	function create() {
	  var hb = new base.HandlebarsEnvironment();

	  Utils.extend(hb, base);
	  hb.SafeString = _SafeString2['default'];
	  hb.Exception = _Exception2['default'];
	  hb.Utils = Utils;
	  hb.escapeExpression = Utils.escapeExpression;

	  hb.VM = runtime;
	  hb.template = function (spec) {
	    return runtime.template(spec, hb);
	  };

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_noConflict2['default'](inst);

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

/***/ },
/* 20 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.extend = extend;

	// Older IE versions do not directly support indexOf so we must implement our own, sadly.
	exports.indexOf = indexOf;
	exports.escapeExpression = escapeExpression;
	exports.isEmpty = isEmpty;
	exports.blockParams = blockParams;
	exports.appendContextPath = appendContextPath;
	var escape = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  '\'': '&#x27;',
	  '`': '&#x60;'
	};

	var badChars = /[&<>"'`]/g,
	    possible = /[&<>"'`]/;

	function escapeChar(chr) {
	  return escape[chr];
	}

	function extend(obj /* , ...source */) {
	  for (var i = 1; i < arguments.length; i++) {
	    for (var key in arguments[i]) {
	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
	        obj[key] = arguments[i][key];
	      }
	    }
	  }

	  return obj;
	}

	var toString = Object.prototype.toString;

	exports.toString = toString;
	// Sourced from lodash
	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
	/*eslint-disable func-style, no-var */
	var isFunction = function isFunction(value) {
	  return typeof value === 'function';
	};
	// fallback for older versions of Chrome and Safari
	/* istanbul ignore next */
	if (isFunction(/x/)) {
	  exports.isFunction = isFunction = function (value) {
	    return typeof value === 'function' && toString.call(value) === '[object Function]';
	  };
	}
	var isFunction;
	exports.isFunction = isFunction;
	/*eslint-enable func-style, no-var */

	/* istanbul ignore next */
	var isArray = Array.isArray || function (value) {
	  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
	};exports.isArray = isArray;

	function indexOf(array, value) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}

	function escapeExpression(string) {
	  if (typeof string !== 'string') {
	    // don't escape SafeStrings, since they're already safe
	    if (string && string.toHTML) {
	      return string.toHTML();
	    } else if (string == null) {
	      return '';
	    } else if (!string) {
	      return string + '';
	    }

	    // Force a string conversion as this will be done by the append regardless and
	    // the regex test will do this transparently behind the scenes, causing issues if
	    // an object's to string has escaped characters in it.
	    string = '' + string;
	  }

	  if (!possible.test(string)) {
	    return string;
	  }
	  return string.replace(badChars, escapeChar);
	}

	function isEmpty(value) {
	  if (!value && value !== 0) {
	    return true;
	  } else if (isArray(value) && value.length === 0) {
	    return true;
	  } else {
	    return false;
	  }
	}

	function blockParams(params, ids) {
	  params.path = ids;
	  return params;
	}

	function appendContextPath(contextPath, id) {
	  return (contextPath ? contextPath + '.' : '') + id;
	}

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

	exports.__esModule = true;
	exports.HandlebarsEnvironment = HandlebarsEnvironment;
	exports.createFrame = createFrame;

	var _import = __webpack_require__(20);

	var Utils = _interopRequireWildcard(_import);

	var _Exception = __webpack_require__(22);

	var _Exception2 = _interopRequireWildcard(_Exception);

	var VERSION = '3.0.1';
	exports.VERSION = VERSION;
	var COMPILER_REVISION = 6;

	exports.COMPILER_REVISION = COMPILER_REVISION;
	var REVISION_CHANGES = {
	  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
	  2: '== 1.0.0-rc.3',
	  3: '== 1.0.0-rc.4',
	  4: '== 1.x.x',
	  5: '== 2.0.0-alpha.x',
	  6: '>= 2.0.0-beta.1'
	};

	exports.REVISION_CHANGES = REVISION_CHANGES;
	var isArray = Utils.isArray,
	    isFunction = Utils.isFunction,
	    toString = Utils.toString,
	    objectType = '[object Object]';

	function HandlebarsEnvironment(helpers, partials) {
	  this.helpers = helpers || {};
	  this.partials = partials || {};

	  registerDefaultHelpers(this);
	}

	HandlebarsEnvironment.prototype = {
	  constructor: HandlebarsEnvironment,

	  logger: logger,
	  log: log,

	  registerHelper: function registerHelper(name, fn) {
	    if (toString.call(name) === objectType) {
	      if (fn) {
	        throw new _Exception2['default']('Arg not supported with multiple helpers');
	      }
	      Utils.extend(this.helpers, name);
	    } else {
	      this.helpers[name] = fn;
	    }
	  },
	  unregisterHelper: function unregisterHelper(name) {
	    delete this.helpers[name];
	  },

	  registerPartial: function registerPartial(name, partial) {
	    if (toString.call(name) === objectType) {
	      Utils.extend(this.partials, name);
	    } else {
	      if (typeof partial === 'undefined') {
	        throw new _Exception2['default']('Attempting to register a partial as undefined');
	      }
	      this.partials[name] = partial;
	    }
	  },
	  unregisterPartial: function unregisterPartial(name) {
	    delete this.partials[name];
	  }
	};

	function registerDefaultHelpers(instance) {
	  instance.registerHelper('helperMissing', function () {
	    if (arguments.length === 1) {
	      // A missing field in a {{foo}} constuct.
	      return undefined;
	    } else {
	      // Someone is actually trying to call something, blow up.
	      throw new _Exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
	    }
	  });

	  instance.registerHelper('blockHelperMissing', function (context, options) {
	    var inverse = options.inverse,
	        fn = options.fn;

	    if (context === true) {
	      return fn(this);
	    } else if (context === false || context == null) {
	      return inverse(this);
	    } else if (isArray(context)) {
	      if (context.length > 0) {
	        if (options.ids) {
	          options.ids = [options.name];
	        }

	        return instance.helpers.each(context, options);
	      } else {
	        return inverse(this);
	      }
	    } else {
	      if (options.data && options.ids) {
	        var data = createFrame(options.data);
	        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);
	        options = { data: data };
	      }

	      return fn(context, options);
	    }
	  });

	  instance.registerHelper('each', function (context, options) {
	    if (!options) {
	      throw new _Exception2['default']('Must pass iterator to #each');
	    }

	    var fn = options.fn,
	        inverse = options.inverse,
	        i = 0,
	        ret = '',
	        data = undefined,
	        contextPath = undefined;

	    if (options.data && options.ids) {
	      contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
	    }

	    if (isFunction(context)) {
	      context = context.call(this);
	    }

	    if (options.data) {
	      data = createFrame(options.data);
	    }

	    function execIteration(field, index, last) {
	      if (data) {
	        data.key = field;
	        data.index = index;
	        data.first = index === 0;
	        data.last = !!last;

	        if (contextPath) {
	          data.contextPath = contextPath + field;
	        }
	      }

	      ret = ret + fn(context[field], {
	        data: data,
	        blockParams: Utils.blockParams([context[field], field], [contextPath + field, null])
	      });
	    }

	    if (context && typeof context === 'object') {
	      if (isArray(context)) {
	        for (var j = context.length; i < j; i++) {
	          execIteration(i, i, i === context.length - 1);
	        }
	      } else {
	        var priorKey = undefined;

	        for (var key in context) {
	          if (context.hasOwnProperty(key)) {
	            // We're running the iterations one step out of sync so we can detect
	            // the last iteration without have to scan the object twice and create
	            // an itermediate keys array.
	            if (priorKey) {
	              execIteration(priorKey, i - 1);
	            }
	            priorKey = key;
	            i++;
	          }
	        }
	        if (priorKey) {
	          execIteration(priorKey, i - 1, true);
	        }
	      }
	    }

	    if (i === 0) {
	      ret = inverse(this);
	    }

	    return ret;
	  });

	  instance.registerHelper('if', function (conditional, options) {
	    if (isFunction(conditional)) {
	      conditional = conditional.call(this);
	    }

	    // Default behavior is to render the positive path if the value is truthy and not empty.
	    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
	    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
	    if (!options.hash.includeZero && !conditional || Utils.isEmpty(conditional)) {
	      return options.inverse(this);
	    } else {
	      return options.fn(this);
	    }
	  });

	  instance.registerHelper('unless', function (conditional, options) {
	    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
	  });

	  instance.registerHelper('with', function (context, options) {
	    if (isFunction(context)) {
	      context = context.call(this);
	    }

	    var fn = options.fn;

	    if (!Utils.isEmpty(context)) {
	      if (options.data && options.ids) {
	        var data = createFrame(options.data);
	        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);
	        options = { data: data };
	      }

	      return fn(context, options);
	    } else {
	      return options.inverse(this);
	    }
	  });

	  instance.registerHelper('log', function (message, options) {
	    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
	    instance.log(level, message);
	  });

	  instance.registerHelper('lookup', function (obj, field) {
	    return obj && obj[field];
	  });
	}

	var logger = {
	  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

	  // State enum
	  DEBUG: 0,
	  INFO: 1,
	  WARN: 2,
	  ERROR: 3,
	  level: 1,

	  // Can be overridden in the host environment
	  log: function log(level, message) {
	    if (typeof console !== 'undefined' && logger.level <= level) {
	      var method = logger.methodMap[level];
	      (console[method] || console.log).call(console, message); // eslint-disable-line no-console
	    }
	  }
	};

	exports.logger = logger;
	var log = logger.log;

	exports.log = log;

	function createFrame(object) {
	  var frame = Utils.extend({}, object);
	  frame._parent = object;
	  return frame;
	}

	/* [args, ]options */

/***/ },
/* 22 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

	function Exception(message, node) {
	  var loc = node && node.loc,
	      line = undefined,
	      column = undefined;
	  if (loc) {
	    line = loc.start.line;
	    column = loc.start.column;

	    message += ' - ' + line + ':' + column;
	  }

	  var tmp = Error.prototype.constructor.call(this, message);

	  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
	  for (var idx = 0; idx < errorProps.length; idx++) {
	    this[errorProps[idx]] = tmp[errorProps[idx]];
	  }

	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, Exception);
	  }

	  if (loc) {
	    this.lineNumber = line;
	    this.column = column;
	  }
	}

	Exception.prototype = new Error();

	exports['default'] = Exception;
	module.exports = exports['default'];

/***/ },
/* 23 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	// Build out our basic SafeString type
	function SafeString(string) {
	  this.string = string;
	}

	SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
	  return '' + this.string;
	};

	exports['default'] = SafeString;
	module.exports = exports['default'];

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

	exports.__esModule = true;
	exports.checkRevision = checkRevision;

	// TODO: Remove this line and break up compilePartial

	exports.template = template;
	exports.wrapProgram = wrapProgram;
	exports.resolvePartial = resolvePartial;
	exports.invokePartial = invokePartial;
	exports.noop = noop;

	var _import = __webpack_require__(20);

	var Utils = _interopRequireWildcard(_import);

	var _Exception = __webpack_require__(22);

	var _Exception2 = _interopRequireWildcard(_Exception);

	var _COMPILER_REVISION$REVISION_CHANGES$createFrame = __webpack_require__(21);

	function checkRevision(compilerInfo) {
	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
	      currentRevision = _COMPILER_REVISION$REVISION_CHANGES$createFrame.COMPILER_REVISION;

	  if (compilerRevision !== currentRevision) {
	    if (compilerRevision < currentRevision) {
	      var runtimeVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[currentRevision],
	          compilerVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[compilerRevision];
	      throw new _Exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
	    } else {
	      // Use the embedded version info since the runtime doesn't know about this revision yet
	      throw new _Exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
	    }
	  }
	}

	function template(templateSpec, env) {
	  /* istanbul ignore next */
	  if (!env) {
	    throw new _Exception2['default']('No environment passed to template');
	  }
	  if (!templateSpec || !templateSpec.main) {
	    throw new _Exception2['default']('Unknown template object: ' + typeof templateSpec);
	  }

	  // Note: Using env.VM references rather than local var references throughout this section to allow
	  // for external users to override these as psuedo-supported APIs.
	  env.VM.checkRevision(templateSpec.compiler);

	  function invokePartialWrapper(partial, context, options) {
	    if (options.hash) {
	      context = Utils.extend({}, context, options.hash);
	    }

	    partial = env.VM.resolvePartial.call(this, partial, context, options);
	    var result = env.VM.invokePartial.call(this, partial, context, options);

	    if (result == null && env.compile) {
	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
	      result = options.partials[options.name](context, options);
	    }
	    if (result != null) {
	      if (options.indent) {
	        var lines = result.split('\n');
	        for (var i = 0, l = lines.length; i < l; i++) {
	          if (!lines[i] && i + 1 === l) {
	            break;
	          }

	          lines[i] = options.indent + lines[i];
	        }
	        result = lines.join('\n');
	      }
	      return result;
	    } else {
	      throw new _Exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
	    }
	  }

	  // Just add water
	  var container = {
	    strict: function strict(obj, name) {
	      if (!(name in obj)) {
	        throw new _Exception2['default']('"' + name + '" not defined in ' + obj);
	      }
	      return obj[name];
	    },
	    lookup: function lookup(depths, name) {
	      var len = depths.length;
	      for (var i = 0; i < len; i++) {
	        if (depths[i] && depths[i][name] != null) {
	          return depths[i][name];
	        }
	      }
	    },
	    lambda: function lambda(current, context) {
	      return typeof current === 'function' ? current.call(context) : current;
	    },

	    escapeExpression: Utils.escapeExpression,
	    invokePartial: invokePartialWrapper,

	    fn: function fn(i) {
	      return templateSpec[i];
	    },

	    programs: [],
	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
	      var programWrapper = this.programs[i],
	          fn = this.fn(i);
	      if (data || depths || blockParams || declaredBlockParams) {
	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
	      } else if (!programWrapper) {
	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
	      }
	      return programWrapper;
	    },

	    data: function data(value, depth) {
	      while (value && depth--) {
	        value = value._parent;
	      }
	      return value;
	    },
	    merge: function merge(param, common) {
	      var obj = param || common;

	      if (param && common && param !== common) {
	        obj = Utils.extend({}, common, param);
	      }

	      return obj;
	    },

	    noop: env.VM.noop,
	    compilerInfo: templateSpec.compiler
	  };

	  function ret(context) {
	    var options = arguments[1] === undefined ? {} : arguments[1];

	    var data = options.data;

	    ret._setup(options);
	    if (!options.partial && templateSpec.useData) {
	      data = initData(context, data);
	    }
	    var depths = undefined,
	        blockParams = templateSpec.useBlockParams ? [] : undefined;
	    if (templateSpec.useDepths) {
	      depths = options.depths ? [context].concat(options.depths) : [context];
	    }

	    return templateSpec.main.call(container, context, container.helpers, container.partials, data, blockParams, depths);
	  }
	  ret.isTop = true;

	  ret._setup = function (options) {
	    if (!options.partial) {
	      container.helpers = container.merge(options.helpers, env.helpers);

	      if (templateSpec.usePartial) {
	        container.partials = container.merge(options.partials, env.partials);
	      }
	    } else {
	      container.helpers = options.helpers;
	      container.partials = options.partials;
	    }
	  };

	  ret._child = function (i, data, blockParams, depths) {
	    if (templateSpec.useBlockParams && !blockParams) {
	      throw new _Exception2['default']('must pass block params');
	    }
	    if (templateSpec.useDepths && !depths) {
	      throw new _Exception2['default']('must pass parent depths');
	    }

	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
	  };
	  return ret;
	}

	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
	  function prog(context) {
	    var options = arguments[1] === undefined ? {} : arguments[1];

	    return fn.call(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), depths && [context].concat(depths));
	  }
	  prog.program = i;
	  prog.depth = depths ? depths.length : 0;
	  prog.blockParams = declaredBlockParams || 0;
	  return prog;
	}

	function resolvePartial(partial, context, options) {
	  if (!partial) {
	    partial = options.partials[options.name];
	  } else if (!partial.call && !options.name) {
	    // This is a dynamic partial that returned a string
	    options.name = partial;
	    partial = options.partials[partial];
	  }
	  return partial;
	}

	function invokePartial(partial, context, options) {
	  options.partial = true;

	  if (partial === undefined) {
	    throw new _Exception2['default']('The partial ' + options.name + ' could not be found');
	  } else if (partial instanceof Function) {
	    return partial(context, options);
	  }
	}

	function noop() {
	  return '';
	}

	function initData(context, data) {
	  if (!data || !('root' in data)) {
	    data = data ? _COMPILER_REVISION$REVISION_CHANGES$createFrame.createFrame(data) : {};
	    data.root = context;
	  }
	  return data;
	}

/***/ },
/* 25 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	exports.__esModule = true;
	/*global window */

	exports['default'] = function (Handlebars) {
	  /* istanbul ignore next */
	  var root = typeof global !== 'undefined' ? global : window,
	      $Handlebars = root.Handlebars;
	  /* istanbul ignore next */
	  Handlebars.noConflict = function () {
	    if (root.Handlebars === Handlebars) {
	      root.Handlebars = $Handlebars;
	    }
	  };
	};

	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 jQuery Simple Slider

	 Copyright (c) 2012 James Smith (http://loopj.com)

	 Licensed under the MIT license (http://mit-license.org/)
	*/

	var __slice = [].slice,
	  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	  var $ = __webpack_require__(15);
	  var SimpleSlider;
	  SimpleSlider = (function() {

	    function SimpleSlider(input, options) {
	      var ratio,
	        _this = this;
	      this.input = input;
	      this.defaultOptions = {
	        animate: true,
	        snapMid: false,
	        classPrefix: null,
	        classSuffix: null,
	        theme: null,
	        highlight: false
	      };
	      this.settings = $.extend({}, this.defaultOptions, options);
	      if (this.settings.theme) {
	        this.settings.classSuffix = "-" + this.settings.theme;
	      }
	      this.input.hide();
	      this.slider = $("<div>").addClass("slider" + (this.settings.classSuffix || "")).css({
	        position: "relative",
	        userSelect: "none",
	        boxSizing: "border-box"
	      }).insertBefore(this.input);
	      if (this.input.attr("id")) {
	        this.slider.attr("id", this.input.attr("id") + "-slider");
	      }
	      this.track = this.createDivElement("track").css({
	        width: "100%"
	      });
	      if (this.settings.highlight) {
	        this.highlightTrack = this.createDivElement("highlight-track").css({
	          width: "0"
	        });
	      }
	      this.dragger = this.createDivElement("dragger");
	      this.slider.css({
	        minHeight: this.dragger.outerHeight(),
	        marginLeft: this.dragger.outerWidth() / 2,
	        marginRight: this.dragger.outerWidth() / 2
	      });
	      this.track.css({
	        marginTop: this.track.outerHeight() / -2
	      });
	      if (this.settings.highlight) {
	        this.highlightTrack.css({
	          marginTop: this.track.outerHeight() / -2
	        });
	      }
	      this.dragger.css({
	        marginTop: this.dragger.outerHeight() / -2,
	        marginLeft: this.dragger.outerWidth() / -2
	      });
	      this.track.mousedown(function(e) {
	        return _this.trackEvent(e);
	      });
	      if (this.settings.highlight) {
	        this.highlightTrack.mousedown(function(e) {
	          return _this.trackEvent(e);
	        });
	      }
	      this.dragger.mousedown(function(e) {
	        if (e.which !== 1) {
	          return;
	        }
	        _this.dragging = true;
	        _this.dragger.addClass("dragging");
	        _this.domDrag(e.pageX, e.pageY);
	        return false;
	      });
	      $("body").mousemove(function(e) {
	        if (_this.dragging) {
	          _this.domDrag(e.pageX, e.pageY);
	          return $("body").css({
	            cursor: "pointer"
	          });
	        }
	      }).mouseup(function(e) {
	        if (_this.dragging) {
	          _this.dragging = false;
	          _this.dragger.removeClass("dragging");
	          return $("body").css({
	            cursor: "auto"
	          });
	        }
	      });
	      this.pagePos = 0;
	      if (this.input.val() === "") {
	        this.value = this.getRange().min;
	        this.input.val(this.value);
	      } else {
	        this.value = this.nearestValidValue(this.input.val());
	      }
	      this.setSliderPositionFromValue(this.value);
	      ratio = this.valueToRatio(this.value);
	      this.input.trigger("slider:ready", {
	        value: this.value,
	        ratio: ratio,
	        position: ratio * this.slider.outerWidth(),
	        el: this.slider
	      });
	    }

	    SimpleSlider.prototype.createDivElement = function(classname) {
	      var item;
	      item = $("<div>").addClass(classname).css({
	        position: "absolute",
	        top: "50%",
	        userSelect: "none",
	        cursor: "pointer"
	      }).appendTo(this.slider);
	      return item;
	    };

	    SimpleSlider.prototype.setRatio = function(ratio, silent) {
	      var value;
	      ratio = Math.min(1, ratio);
	      ratio = Math.max(0, ratio);
	      value = this.ratioToValue(ratio);
	      this.setSliderPositionFromValue(value);
	      return this.valueChanged(value, ratio, "setRatio", silent);
	    };

	    SimpleSlider.prototype.setValue = function(value, silent) {
	      var ratio;
	      value = this.nearestValidValue(value);
	      ratio = this.valueToRatio(value);
	      this.setSliderPositionFromValue(value);
	      return this.valueChanged(value, ratio, "setValue", silent);
	    };

	    SimpleSlider.prototype.trackEvent = function(e) {
	      if (e.which !== 1) {
	        return;
	      }
	      this.domDrag(e.pageX, e.pageY, true);
	      this.dragging = true;
	      return false;
	    };

	    SimpleSlider.prototype.domDrag = function(pageX, pageY, animate) {
	      var pagePos, ratio, value;
	      if (animate == null) {
	        animate = false;
	      }
	      pagePos = pageX - this.slider.offset().left;
	      pagePos = Math.min(this.slider.outerWidth(), pagePos);
	      pagePos = Math.max(0, pagePos);
	      if (this.pagePos !== pagePos) {
	        this.pagePos = pagePos;
	        ratio = pagePos / this.slider.outerWidth();
	        value = this.ratioToValue(ratio);
	        this.valueChanged(value, ratio, "domDrag");
	        if (this.settings.snap) {
	          return this.setSliderPositionFromValue(value, animate);
	        } else {
	          return this.setSliderPosition(pagePos, animate);
	        }
	      }
	    };

	    SimpleSlider.prototype.setSliderPosition = function(position, animate) {
	      if (animate == null) {
	        animate = false;
	      }
	      if (animate && this.settings.animate) {
	        this.dragger.animate({
	          left: position
	        }, 200);
	        if (this.settings.highlight) {
	          return this.highlightTrack.animate({
	            width: position
	          }, 200);
	        }
	      } else {
	        this.dragger.css({
	          left: position
	        });
	        if (this.settings.highlight) {
	          return this.highlightTrack.css({
	            width: position
	          });
	        }
	      }
	    };

	    SimpleSlider.prototype.setSliderPositionFromValue = function(value, animate) {
	      var ratio;
	      if (animate == null) {
	        animate = false;
	      }
	      ratio = this.valueToRatio(value);
	      return this.setSliderPosition(ratio * this.slider.outerWidth(), animate);
	    };

	    SimpleSlider.prototype.getRange = function() {
	      if (this.settings.allowedValues) {
	        return {
	          min: Math.min.apply(Math, this.settings.allowedValues),
	          max: Math.max.apply(Math, this.settings.allowedValues)
	        };
	      } else if (this.settings.range) {
	        return {
	          min: parseFloat(this.settings.range[0]),
	          max: parseFloat(this.settings.range[1])
	        };
	      } else {
	        return {
	          min: 0,
	          max: 1
	        };
	      }
	    };

	    SimpleSlider.prototype.nearestValidValue = function(rawValue) {
	      var closest, maxSteps, range, steps;
	      range = this.getRange();
	      rawValue = Math.min(range.max, rawValue);
	      rawValue = Math.max(range.min, rawValue);
	      if (this.settings.allowedValues) {
	        closest = null;
	        $.each(this.settings.allowedValues, function() {
	          if (closest === null || Math.abs(this - rawValue) < Math.abs(closest - rawValue)) {
	            return closest = this;
	          }
	        });
	        return closest;
	      } else if (this.settings.step) {
	        maxSteps = (range.max - range.min) / this.settings.step;
	        steps = Math.floor((rawValue - range.min) / this.settings.step);
	        if ((rawValue - range.min) % this.settings.step > this.settings.step / 2 && steps < maxSteps) {
	          steps += 1;
	        }
	        return steps * this.settings.step + range.min;
	      } else {
	        return rawValue;
	      }
	    };

	    SimpleSlider.prototype.valueToRatio = function(value) {
	      var allowedVal, closest, closestIdx, idx, range, _i, _len, _ref;
	      if (this.settings.equalSteps) {
	        _ref = this.settings.allowedValues;
	        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
	          allowedVal = _ref[idx];
	          if (!(typeof closest !== "undefined" && closest !== null) || Math.abs(allowedVal - value) < Math.abs(closest - value)) {
	            closest = allowedVal;
	            closestIdx = idx;
	          }
	        }
	        if (this.settings.snapMid) {
	          return (closestIdx + 0.5) / this.settings.allowedValues.length;
	        } else {
	          return closestIdx / (this.settings.allowedValues.length - 1);
	        }
	      } else {
	        range = this.getRange();
	        return (value - range.min) / (range.max - range.min);
	      }
	    };

	    SimpleSlider.prototype.ratioToValue = function(ratio) {
	      var idx, range, rawValue, step, steps;
	      if (this.settings.equalSteps) {
	        steps = this.settings.allowedValues.length;
	        step = Math.round(ratio * steps - 0.5);
	        idx = Math.min(step, this.settings.allowedValues.length - 1);
	        return this.settings.allowedValues[idx];
	      } else {
	        range = this.getRange();
	        rawValue = ratio * (range.max - range.min) + range.min;
	        return this.nearestValidValue(rawValue);
	      }
	    };

	    SimpleSlider.prototype.valueChanged = function(value, ratio, trigger, silent) {
	      var eventData;
	      if (value.toString() === this.value.toString()) {
	        return;
	      }
	      this.value = value;
	      eventData = {
	        value: value,
	        ratio: ratio,
	        position: ratio * this.slider.outerWidth(),
	        trigger: trigger,
	        el: this.slider
	      };
	      if(!silent) {
	        return this.input.val(value).trigger($.Event("change", eventData)).trigger("slider:changed", eventData);
	      } else {
	        return this.input.val(value).trigger($.Event("change", eventData));
	      }
	    };

	    return SimpleSlider;

	  })();
	  $.extend($.fn, {
	    simpleSlider: function() {
	      var params, publicMethods, settingsOrMethod;
	      settingsOrMethod = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
	      publicMethods = ["setRatio", "setValue"];
	      return $(this).each(function() {
	        var obj, settings;
	        if (settingsOrMethod && __indexOf.call(publicMethods, settingsOrMethod) >= 0) {
	          obj = $(this).data("slider-object");
	          return obj[settingsOrMethod].apply(obj, params);
	        } else {
	          settings = settingsOrMethod;
	          return $(this).data("slider-object", new SimpleSlider($(this), settings));
	        }
	      });
	    }
	  });
	  module.exports = $(function() {
	    return $("[data-slider]").each(function() {
	      var $el, allowedValues, settings, x;
	      $el = $(this);
	      settings = {};
	      allowedValues = $el.data("slider-values");
	      if (allowedValues) {
	        settings.allowedValues = (function() {
	          var _i, _len, _ref, _results;
	          _ref = allowedValues.split(",");
	          _results = [];
	          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	            x = _ref[_i];
	            _results.push(parseFloat(x));
	          }
	          return _results;
	        })();
	      }
	      if ($el.data("slider-range")) {
	        settings.range = $el.data("slider-range").split(",");
	      }
	      if ($el.data("slider-step")) {
	        settings.step = $el.data("slider-step");
	      }
	      settings.snap = $el.data("slider-snap");
	      settings.equalSteps = $el.data("slider-equal-steps");
	      if ($el.data("slider-theme")) {
	        settings.theme = $el.data("slider-theme");
	      }
	      if ($el.attr("data-slider-highlight")) {
	        settings.highlight = $el.data("slider-highlight");
	      }
	      if ($el.data("slider-animate") != null) {
	        settings.animate = $el.data("slider-animate");
	      }
	      return $el.simpleSlider(settings);
	    });
	  });


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var Handlebars = __webpack_require__(18);
	module.exports = (Handlebars["default"] || Handlebars).template({"1":function(depth0,helpers,partials,data) {
	    return "        <div class=\"tdspinner\">\n            <div class=\"rect1\"></div>\n            <div class=\"rect2\"></div>\n            <div class=\"rect3\"></div>\n            <div class=\"rect4\"></div>\n            <div class=\"rect5\"></div>\n        </div>\n";
	},"3":function(depth0,helpers,partials,data,blockParams,depths) {
	    var stack1, alias1=this.lambda, alias2=this.escapeExpression;

	  return "            <div class=\"header tdrow\">\n                <div class=\"cover tdlarge-12 tdsmall-12 tdcolumns\">\n                    <div class=\"cover-img\">\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.artwork_url : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0, blockParams, depths),"inverse":this.program(6, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
	    + "                    </div>\n                </div>\n                <div class=\"waveform tdlarge-12 tdsmall-6 tdcolumns\">\n                </div>\n            </div>\n            <div class=\"tdrow info \">\n                <div class=\"song-name tdlarge-12 tdsmall-12 tdcolumns\">\n                    <a href=\""
	    + alias2(alias1((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\" target=\"_blank\">"
	    + alias2(alias1((depth0 != null ? depth0.title : depth0), depth0))
	    + "</a>\n                </div>\n                <div class=\"artist-name tdlarge-12 tdsmall-12 tdcolumns\">\n                    <a href=\""
	    + alias2(alias1(((stack1 = (depth0 != null ? depth0.user : depth0)) != null ? stack1.permalink_url : stack1), depth0))
	    + "\" target=\"_blank\">"
	    + alias2(alias1(((stack1 = (depth0 != null ? depth0.user : depth0)) != null ? stack1.username : stack1), depth0))
	    + "</a>\n                </div>\n            </div>\n            <div class=\"tdrow social\">\n"
	    + ((stack1 = __webpack_require__(28).call(depth0,(depth0 != null ? depth0.purchase_url : depth0),(depth0 != null ? depth0.download_url : depth0),{"name":"ifCond","hash":{},"fn":this.program(8, data, 0, blockParams, depths),"inverse":this.program(10, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
	    + "                <div class=\"current-song-info tdlarge-6 tdcolumns tdsmall-12\">\n                    <div class=\"track-info-plays tdlarge-6 tdsmall-6 tdcolumns\">\n                        <i class=\"tdicon-play-circle-fill current-song-social-icon\"></i>\n                        "
	    + alias2(__webpack_require__(29).call(depth0,(depth0 != null ? depth0.playback_count : depth0),{"name":"commanator","hash":{},"data":data}))
	    + "\n                    </div>\n                    <div class=\"track-info-favorites tdlarge-6 tdsmall-6 tdcolumns\">\n                        <i class=\"tdicon-heart current-song-social-icon\"></i>\n                        "
	    + alias2(__webpack_require__(29).call(depth0,(depth0 != null ? depth0.favoritings_count : depth0),{"name":"commanator","hash":{},"data":data}))
	    + "\n                    </div>\n                </div>\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.purchase_url : depth0),{"name":"if","hash":{},"fn":this.program(12, data, 0, blockParams, depths),"inverse":this.program(17, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
	    + "            </div>\n            <div class=\"tdrow controls\">\n                <div class=\"buttons tdlarge-12 tdsmall-12 tdcolumns\">\n                    <div class=\"tdlarge-3 tdsmall-12 tdcolumns\">\n"
	    + ((stack1 = helpers['if'].call(depth0,(depths[1] != null ? depths[1].repeat : depths[1]),{"name":"if","hash":{},"fn":this.program(20, data, 0, blockParams, depths),"inverse":this.program(22, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
	    + "                    </div>\n                    <div class=\"tdlarge-6 tdsmall-12 tdcolumns button-controls\">\n                        <i class=\"tdicon-angle-double-left player-prev prev\"></i>\n                        <i class=\"tdicon-play-circle-outline player-play play\"></i>\n                        <i class=\"tdicon-angle-double-right player-next next\"></i>\n                    </div>\n                    <div class=\"volume-controls tdlarge-3 tdsmall-12 tdcolumns\">\n                        <i class=\"tdicon-volume-up volume-init\"></i>\n                        <div class=\"tdlarge-12 tdmsall-12 tdcolumns tdlarge-centered tdmsall-centered volume-select\" style=\"display:none;\">\n                            <i class=\"tdicon-volume-off volume-off\" data-class=\"tdicon-volume-off\"></i>\n                            <i class=\"tdicon-volume-down volume-med\" data-class=\"tdicon-volume-down\"></i>\n                            <i class=\"tdicon-volume-up volume-max volume-active\" data-class=\"tdicon-volume-up \"></i>\n                        </div>\n                    </div>\n                </div>\n            </div>\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.error : depth0),{"name":"if","hash":{},"fn":this.program(24, data, 0, blockParams, depths),"inverse":this.program(26, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "");
	},"4":function(depth0,helpers,partials,data) {
	    return "                            <img src=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.artwork_url : depth0), depth0))
	    + "\" />\n";
	},"6":function(depth0,helpers,partials,data) {
	    var stack1;

	  return "                            <img src=\""
	    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.user : depth0)) != null ? stack1.avatar_url : stack1), depth0))
	    + "\" />\n";
	},"8":function(depth0,helpers,partials,data) {
	    return "                    <div class=\"follow tdlarge-3 tdsmall-12 tdcolumns\">\n                        <a class=\"tdbutton expand follow-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\"  target=\"_blank\">\n                            <i class=\"tdicon-soundcloud playlist-social-icon\"></i>\n                        </a>\n                    </div>\n";
	},"10":function(depth0,helpers,partials,data) {
	    return "                    <div class=\"follow tdlarge-6 tdsmall-12 tdcolumns\">\n                        <a class=\"tdbutton expand follow-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\"  target=\"_blank\">\n                            <i class=\"tdicon-soundcloud playlist-social-icon\"></i>\n                        </a>\n                    </div>\n";
	},"12":function(depth0,helpers,partials,data) {
	    var stack1;

	  return "                    <div class=\"buy tdlarge-3 tdsmall-12 tdcolumns\">\n                        <a class=\"tdbutton expand  buy-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.purchase_url : depth0), depth0))
	    + "\" target=\"_blank\">\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.useCustomPurchaseTitle : depth0),{"name":"if","hash":{},"fn":this.program(13, data, 0),"inverse":this.program(15, data, 0),"data":data})) != null ? stack1 : "")
	    + "                        </a>\n                    </div>\n";
	},"13":function(depth0,helpers,partials,data) {
	    return "                                "
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.purchase_title : depth0), depth0))
	    + "\n";
	},"15":function(depth0,helpers,partials,data) {
	    return "                                BUY\n";
	},"17":function(depth0,helpers,partials,data) {
	    var stack1;

	  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.download_url : depth0),{"name":"if","hash":{},"fn":this.program(18, data, 0),"inverse":this.noop,"data":data})) != null ? stack1 : "");
	},"18":function(depth0,helpers,partials,data) {
	    return "                        <div class=\"buy tdlarge-3 tdsmall-12 tdcolumns\">\n                            <a class=\"tdbutton expand buy-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.download_url : depth0), depth0))
	    + "\" target=\"_blank\">\n                                DOWNLOAD\n                            </a>\n                        </div>\n";
	},"20":function(depth0,helpers,partials,data) {
	    return "                            <i class=\"tdicon-repeat repeat-on repeat-init\"></i>\n";
	},"22":function(depth0,helpers,partials,data) {
	    return "                            <i class=\"tdicon-repeat repeat-init\"></i>\n";
	},"24":function(depth0,helpers,partials,data) {
	    return "                <div class=\"tdrow\">\n                    <div class=\"tdlarge-12 tdsmall-12 tdcolumns\">\n                        <div class=\"tdlarge-12 tdsmall-12 tdcolumns track-error-box\">\n                            <span class=\"track-error-box-span\"><i class=\"tdicon-warning\"></i> "
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.errorMessage : depth0), depth0))
	    + " </span>\n                        </div>\n                    </div>\n                </div>\n";
	},"26":function(depth0,helpers,partials,data) {
	    var stack1;

	  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.streamable : depth0),{"name":"if","hash":{},"fn":this.program(27, data, 0),"inverse":this.program(29, data, 0),"data":data})) != null ? stack1 : "");
	},"27":function(depth0,helpers,partials,data) {
	    var stack1;

	  return "                    <div class=\"tdrow scrubber\">\n                        <div class=\"tdlarge-12 tdsmall-12 tdcolumns scrubber-box\">\n                            <div class=\"tdlarge-2 tdsmall-2 tdcolumns start-time\">0:00</div>\n                            <div class=\"tdlarge-8 tdsmall-8 tdcolumns scrub-bar-box\">\n                                <input type=\"text\" class=\"scrubber-slider\">\n                            </div>\n                            <div class=\"tdlarge-2 tdsmall-2 tdcolumns stop-time\">\n                                "
	    + this.escapeExpression(__webpack_require__(17).call(depth0,((stack1 = (depth0 != null ? depth0.nowPlaying : depth0)) != null ? stack1.duration : stack1),{"name":"msToTimestamp","hash":{},"data":data}))
	    + "\n                                <i class=\"tdicon-circle-o-notch spin tdloader\"></i>\n                            </div>\n                        </div>\n                    </div>\n";
	},"29":function(depth0,helpers,partials,data) {
	    return "                    <div class=\"tdrow\">\n                        <div class=\"tdlarge-12 tdsmall-12 tdcolumns\">\n                            <div class=\"tdlarge-12 tdsmall-12 tdcolumns track-error-box\">\n                                <span class=\"track-error-box-span\"><i class=\"tdicon-warning\"></i> This track is not streamable.</span>\n                            </div>\n                        </div>\n                    </div>\n";
	},"31":function(depth0,helpers,partials,data) {
	    var stack1, alias1=this.escapeExpression;

	  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.playing : depth0),{"name":"if","hash":{},"fn":this.program(32, data, 0),"inverse":this.program(34, data, 0),"data":data})) != null ? stack1 : "")
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.playing : depth0),{"name":"if","hash":{},"fn":this.program(36, data, 0),"inverse":this.program(38, data, 0),"data":data})) != null ? stack1 : "")
	    + "                            <td>\n                                <div class=\"track-info-name tdlarge-12 tdsmall-12 tdcolumns\">\n                                    "
	    + alias1(this.lambda((depth0 != null ? depth0.title : depth0), depth0))
	    + "\n                                </div>\n                            </td>\n                            <td class=\"track-info-stats\" style=\"width:40%\">\n                                <div class=\"track-info-social tdlarge-12 tdsmall-12 tdcolumns\">\n                                    <div class=\"track-info-plays tdsmall-4 tdlarge-4 tdcolumns\">\n                                        <i class=\"tdicon-play-circle-fill playlist-social-icon\"></i>\n                                        "
	    + alias1(__webpack_require__(29).call(depth0,(depth0 != null ? depth0.playback_count : depth0),{"name":"commanator","hash":{},"data":data}))
	    + "\n                                    </div>\n                                    <div class=\"track-info-favorites tdsmall-4 tdlarge-4 tdcolumns\">\n                                        <i class=\"tdicon-heart playlist-social-icon\"></i>\n                                        "
	    + alias1(__webpack_require__(29).call(depth0,(depth0 != null ? depth0.favoritings_count : depth0),{"name":"commanator","hash":{},"data":data}))
	    + "\n                                    </div>\n                                </div>\n                            </td>\n                    </tr>\n";
	},"32":function(depth0,helpers,partials,data) {
	    return "                        <tr class=\"playing\">\n";
	},"34":function(depth0,helpers,partials,data) {
	    return "                        <tr class=\"track-info\" data-index="
	    + this.escapeExpression(this.lambda((data && data.index), depth0))
	    + ">\n";
	},"36":function(depth0,helpers,partials,data) {
	    return "                            <td width=\"20\"><i class=\"tdicon-play-circle-fill current-play-icon\" data-index="
	    + this.escapeExpression(this.lambda((data && data.index), depth0))
	    + "></i></td>\n";
	},"38":function(depth0,helpers,partials,data) {
	    return "                            <td><div class=\"track-info\" data-index="
	    + this.escapeExpression(this.lambda((data && data.index), depth0))
	    + "></td>\n";
	},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data,blockParams,depths) {
	    var stack1;

	  return "<div class=\"td tdrow player "
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.skin : depth0), depth0))
	    + "\">\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.loading : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0, blockParams, depths),"inverse":this.noop,"data":data})) != null ? stack1 : "")
	    + "    <div class=\"tdbody tdlarge-12 tdsmall-12 tdcolumns tdlarge-centered\">\n        <a href=\"https://www.toneden.io\" target=\"_blank\" class=\"tdicon-td_logo-link\"><i class=\"tdicon-td_logo\"></i></a>\n"
	    + ((stack1 = helpers['with'].call(depth0,(depth0 != null ? depth0.nowPlaying : depth0),{"name":"with","hash":{},"fn":this.program(3, data, 0, blockParams, depths),"inverse":this.noop,"data":data})) != null ? stack1 : "")
	    + "        <div class=\"tdrow playlist\">\n            <table class=\"playlist-table\" border=1>\n"
	    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.tracks : depth0),{"name":"each","hash":{},"fn":this.program(31, data, 0, blockParams, depths),"inverse":this.noop,"data":data})) != null ? stack1 : "")
	    + "            </div>\n        </div>\n    </div>\n</div>\n";
	},"useData":true,"useDepths":true});

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var Handlebars = __webpack_require__(18);

	function ifCond(v1, v2, options) {
	    if(v1 || v2) {
	        return options.fn(this);
	    }
	    return options.inverse(this);
	}

	Handlebars.registerHelper('ifCond', ifCond);

	module.exports = ifCond;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var Handlebars = __webpack_require__(18);

	function commanator(num) {
	    if(num) {
	        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
	    } else {
	        return '-';
	    }
	}

	Handlebars.registerHelper('commanator', commanator);

	module.exports = commanator;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var Handlebars = __webpack_require__(18);
	module.exports = (Handlebars["default"] || Handlebars).template({"1":function(depth0,helpers,partials,data) {
	    return "    <div class=\"tdspinner\">\n        <div class=\"rect1\"></div>\n        <div class=\"rect2\"></div>\n        <div class=\"rect3\"></div>\n        <div class=\"rect4\"></div>\n        <div class=\"rect5\"></div>\n    </div>\n";
	},"3":function(depth0,helpers,partials,data,blockParams,depths) {
	    var stack1, alias1=this.lambda, alias2=this.escapeExpression;

	  return "            <div class=\"header tdlarge-4 tdsmall-12 tdcolumns\">\n                <div class=\"cover tdlarge-12 tdsmall-12 tdcolumns\">\n                    <div class=\"solo-cover\">\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.artwork_url : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0, blockParams, depths),"inverse":this.program(6, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
	    + "                    </div>\n                    <div class=\"controls\">\n                        <div class=\"buttons tdlarge-12 tdsmall-12 tdcolumns\">\n                            <i class=\"tdicon-angle-double-left player-prev prev\"></i> \n                            <i class=\"tdicon-play-circle-outline player-play play\"></i>\n                            <i class=\"tdicon-angle-double-right player-next next\"></i>\n                        </div>\n                    </div>\n                </div>\n                <div class=\"waveform tdlarge-12 tdsmall-12 tdcolumns\">\n                </div>\n                <div class=\"solo-buttons tdlarge-12 tdsmall-12 tdcolumns\">\n"
	    + ((stack1 = __webpack_require__(28).call(depth0,(depth0 != null ? depth0.purchase_url : depth0),(depth0 != null ? depth0.download_url : depth0),{"name":"ifCond","hash":{},"fn":this.program(8, data, 0, blockParams, depths),"inverse":this.program(10, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.purchase_url : depth0),{"name":"if","hash":{},"fn":this.program(12, data, 0, blockParams, depths),"inverse":this.program(17, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
	    + "                </div>\n            </div>\n            <div class=\"solo-container tdlarge-8 tdsmall-12 tdcolumns\">\n                <div class=\"tdrow info-solo\">\n                    <div class=\"tdlarge-2 tdsmall-12 tdcolumns repeat-column\">\n"
	    + ((stack1 = helpers['if'].call(depth0,(depths[1] != null ? depths[1].repeat : depths[1]),{"name":"if","hash":{},"fn":this.program(20, data, 0, blockParams, depths),"inverse":this.program(22, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
	    + "                    </div>\n                    <div class=\"tdlarge-8 tdsmall-12 tdcolumns info\">\n                        <div class=\"song-name tdlarge-12 tdsmall-12 tdcolumns\">\n                            <a href=\""
	    + alias2(alias1((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\" target=\"_blank\">"
	    + alias2(alias1((depth0 != null ? depth0.title : depth0), depth0))
	    + "</a>\n                        </div>\n                        <div class=\"artist-name tdlarge-12 tdsmall-12 tdcolumns\">\n                            <a href=\""
	    + alias2(alias1(((stack1 = (depth0 != null ? depth0.user : depth0)) != null ? stack1.permalink_url : stack1), depth0))
	    + "\" target=\"_blank\">"
	    + alias2(alias1(((stack1 = (depth0 != null ? depth0.user : depth0)) != null ? stack1.username : stack1), depth0))
	    + "</a>\n                        </div>\n                    </div>\n                    <div class=\"volume-controls tdlarge-2 tdsmall-12 tdcolumns\">\n                        <i class=\"tdicon-volume-up volume-init\"></i>\n                        <div class=\"tdlarge-12 tdmsall-12 tdcolumns tdlarge-centered tdmsall-centered volume-select\" style=\"display:none;\">\n                            <i class=\"tdicon-volume-off volume-off\" data-class=\"tdicon-volume-off\"></i>\n                            <i class=\"tdicon-volume-down volume-med\" data-class=\"tdicon-volume-down\"></i>\n                            <i class=\"tdicon-volume-up volume-max volume-active\" data-class=\"tdicon-volume-up\"></i>\n                        </div>\n                    </div>\n                </div>\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.error : depth0),{"name":"if","hash":{},"fn":this.program(24, data, 0, blockParams, depths),"inverse":this.program(26, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
	    + "                <div class=\"tdrow social\">\n                    <div class=\"current-song-info tdlarge-12 tdcolumns tdsmall-12\">\n                        <div class=\"track-info-plays tdlarge-6 tdsmall-6 tdcolumns\">\n                            <i class=\"tdicon-play-circle-fill current-song-social-icon\"></i>\n                            "
	    + alias2(__webpack_require__(29).call(depth0,(depth0 != null ? depth0.playback_count : depth0),{"name":"commanator","hash":{},"data":data}))
	    + "\n                        </div>\n                        <div class=\"track-info-favorites tdlarge-6 tdsmall-6 tdcolumns\">\n                            <i class=\"tdicon-heart current-song-social-icon\"></i>\n                            "
	    + alias2(__webpack_require__(29).call(depth0,(depth0 != null ? depth0.favoritings_count : depth0),{"name":"commanator","hash":{},"data":data}))
	    + "\n                        </div>\n                    </div>\n                </div>\n";
	},"4":function(depth0,helpers,partials,data) {
	    return "                            <img src=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.artwork_url : depth0), depth0))
	    + "\" />\n";
	},"6":function(depth0,helpers,partials,data) {
	    var stack1;

	  return "                            <img src=\""
	    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.user : depth0)) != null ? stack1.avatar_url : stack1), depth0))
	    + "\" />\n";
	},"8":function(depth0,helpers,partials,data) {
	    return "                        <div class=\"follow tdlarge-6 tdsmall-12 tdcolumns\">\n                            <a class=\"tdbutton expand follow-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\"  target=\"_blank\">\n                                <i class=\"tdicon-soundcloud playlist-social-icon\"></i>\n                            </a>\n                        </div>\n";
	},"10":function(depth0,helpers,partials,data) {
	    return "                        <div class=\"follow tdlarge-12 tdsmall-12 tdcolumns\">\n                            <a class=\"tdbutton expand follow-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\"  target=\"_blank\">\n                                <i class=\"tdicon-soundcloud playlist-social-icon\"></i>\n                            </a>\n                        </div>\n";
	},"12":function(depth0,helpers,partials,data) {
	    var stack1;

	  return "                        <div class=\"buy tdlarge-6 tdsmall-12 tdcolumns\">\n                            <a class=\"tdbutton expand buy-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.purchase_url : depth0), depth0))
	    + "\" target=\"_blank\">\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.useCustomPurchaseTitle : depth0),{"name":"if","hash":{},"fn":this.program(13, data, 0),"inverse":this.program(15, data, 0),"data":data})) != null ? stack1 : "")
	    + "                            </a>\n                        </div>\n";
	},"13":function(depth0,helpers,partials,data) {
	    return "                                    "
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.purchase_title : depth0), depth0))
	    + "\n";
	},"15":function(depth0,helpers,partials,data) {
	    return "                                    BUY\n";
	},"17":function(depth0,helpers,partials,data) {
	    var stack1;

	  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.download_url : depth0),{"name":"if","hash":{},"fn":this.program(18, data, 0),"inverse":this.noop,"data":data})) != null ? stack1 : "");
	},"18":function(depth0,helpers,partials,data) {
	    return "                            <div class=\"buy tdlarge-6 tdsmall-12 tdcolumns\">\n                                <a class=\"tdbutton expand buy-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.download_url : depth0), depth0))
	    + "\" target=\"_blank\">\n                                    DOWNLOAD\n                                </a>\n                            </div>\n";
	},"20":function(depth0,helpers,partials,data) {
	    return "                            <i class=\"tdicon-repeat repeat-on repeat-init\"></i>\n";
	},"22":function(depth0,helpers,partials,data) {
	    return "                            <i class=\"tdicon-repeat repeat-init\"></i>\n";
	},"24":function(depth0,helpers,partials,data) {
	    return "                    <div class=\"tdrow\">\n                        <div class=\"tdlarge-12 tdsmall-12 tdcolumns\">\n                            <div class=\"tdlarge-12 tdsmall-12 tdcolumns track-error-box\">\n                                <span class=\"track-error-box-span\"><i class=\"tdicon-warning\"></i> "
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.errorMessage : depth0), depth0))
	    + " </span>\n                            </div>\n                        </div>\n                    </div>\n";
	},"26":function(depth0,helpers,partials,data) {
	    var stack1;

	  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.streamable : depth0),{"name":"if","hash":{},"fn":this.program(27, data, 0),"inverse":this.program(29, data, 0),"data":data})) != null ? stack1 : "");
	},"27":function(depth0,helpers,partials,data) {
	    var stack1;

	  return "                        <div class=\"tdrow scrubber\">\n                            <div class=\"tdlarge-12 tdsmall-12 tdcolumns scrubber-box\">\n                                <div class=\"tdlarge-2 tdsmall-2 tdcolumns start-time\">0:00</div>\n                                <div class=\"tdlarge-8 tdsmall-8 tdcolumns scrub-bar-box\">\n                                    <input type=\"text\" class=\"scrubber-slider\">\n                                </div>\n                                <div class=\"tdlarge-2 tdsmall-2 tdcolumns stop-time\">\n                                    "
	    + this.escapeExpression(__webpack_require__(17).call(depth0,((stack1 = (depth0 != null ? depth0.nowPlaying : depth0)) != null ? stack1.duration : stack1),{"name":"msToTimestamp","hash":{},"data":data}))
	    + "\n                                    <i class=\"tdicon-circle-o-notch spin tdloader\"></i>\n                                </div>\n                            </div>\n                        </div>\n";
	},"29":function(depth0,helpers,partials,data) {
	    return "                        <div class=\"tdrow\">\n                            <div class=\"tdlarge-12 tdsmall-12 tdcolumns\">\n                                <div class=\"tdlarge-12 tdsmall-12 tdcolumns track-error-box\">\n                                    <span class=\"track-error-box-span\"><i class=\"tdicon-warning\"></i> This track is not streamable.</span>\n                                </div>\n                            </div>\n                        </div>\n";
	},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data,blockParams,depths) {
	    var stack1;

	  return "<div class=\"td tdrow player "
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.skin : depth0), depth0))
	    + " solo\">\n"
	    + ((stack1 = helpers.unless.call(depth0,(depth0 != null ? depth0.nowPlaying : depth0),{"name":"unless","hash":{},"fn":this.program(1, data, 0, blockParams, depths),"inverse":this.noop,"data":data})) != null ? stack1 : "")
	    + "    <div class=\"tdlarge-12 tdsmall-12 tdcolumns tdlarge-centered tdsmall-centered\">\n        <a href=\"https://www.toneden.io\" target=\"_blank\" class=\"tdicon-td_logo-link\"><i class=\"tdicon-td_logo\"></i></a>\n"
	    + ((stack1 = helpers['with'].call(depth0,(depth0 != null ? depth0.nowPlaying : depth0),{"name":"with","hash":{},"fn":this.program(3, data, 0, blockParams, depths),"inverse":this.noop,"data":data})) != null ? stack1 : "")
	    + "        </div>\n    </div>\n</div>\n";
	},"useData":true,"useDepths":true});

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var Handlebars = __webpack_require__(18);
	module.exports = (Handlebars["default"] || Handlebars).template({"1":function(depth0,helpers,partials,data) {
	    return "    <div class=\"tdspinner\">\n        <div class=\"rect1\"></div>\n        <div class=\"rect2\"></div>\n        <div class=\"rect3\"></div>\n        <div class=\"rect4\"></div>\n        <div class=\"rect5\"></div>\n    </div>\n";
	},"3":function(depth0,helpers,partials,data) {
	    var stack1, alias1=this.lambda, alias2=this.escapeExpression;

	  return "        <div class=\"tdlarge-1 tdsmall-12 tdcolumns controls mini-controls\">\n            <div class=\"buttons mini-buttons tdlarge-12 tdsmall-12 tdcolumns\">\n                <i class=\"tdicon-angle-double-left player-prev prev\"></i>\n                <i class=\"tdicon-play-circle-outline player-play play\"></i>\n                <i class=\"tdicon-angle-double-right player-next next\"></i>\n            </div>\n        </div>\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.error : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0),"data":data})) != null ? stack1 : "")
	    + "        <div class=\"tdlarge-4 tdsmall-12 tdcolumns mini-info\">\n            <div class=\"mini-song-info tdlarge-12 tdsmall-12 tdcolumns\">\n                <div class=\"tdlarge-12 tdsmall-12 columns song-name\">\n                    <a href=\""
	    + alias2(alias1((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\" target=\"_blank\">"
	    + alias2(alias1((depth0 != null ? depth0.title : depth0), depth0))
	    + "</a>\n                </div>\n                <div class=\"tdlarge-12 tdsmall-12 columns artist-name\">\n                    <a href=\""
	    + alias2(alias1(((stack1 = (depth0 != null ? depth0.user : depth0)) != null ? stack1.permalink_url : stack1), depth0))
	    + "\" target=\"_blank\">"
	    + alias2(alias1(((stack1 = (depth0 != null ? depth0.user : depth0)) != null ? stack1.username : stack1), depth0))
	    + "</a>\n                </div>\n            </div>\n        </div>\n        <ul class=\"tdlarge-3 tdsmall-12 tdcolumns mini-social\">\n            <li class=\"track-info-plays\">\n                <i class=\"tdicon-play-circle-fill current-song-social-icon\"></i>\n                "
	    + alias2(__webpack_require__(29).call(depth0,(depth0 != null ? depth0.playback_count : depth0),{"name":"commanator","hash":{},"data":data}))
	    + "\n            </li>\n            <li class=\"track-info-favorites\">\n                <i class=\"tdicon-heart current-song-social-icon\"></i>\n                "
	    + alias2(__webpack_require__(29).call(depth0,(depth0 != null ? depth0.favoritings_count : depth0),{"name":"commanator","hash":{},"data":data}))
	    + "\n            </li>\n        </ul>\n        <div class=\"tdlarge-1 tdsmall-12 tdcolumns mini-connect\">\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.purchase_url : depth0),{"name":"if","hash":{},"fn":this.program(11, data, 0),"inverse":this.program(16, data, 0),"data":data})) != null ? stack1 : "")
	    + ((stack1 = __webpack_require__(28).call(depth0,(depth0 != null ? depth0.purchase_url : depth0),(depth0 != null ? depth0.download_url : depth0),{"name":"ifCond","hash":{},"fn":this.program(18, data, 0),"inverse":this.program(18, data, 0),"data":data})) != null ? stack1 : "")
	    + "        </div\n";
	},"4":function(depth0,helpers,partials,data) {
	    return "            <div class=\"tdlarge-3 tdsmall-12 tdcolumns\">\n                <div class=\"tdlarge-12 tdsmall-12 tdcolumns track-error-box\">\n                    <span class=\"track-error-box-span\"><i class=\"tdicon-warning\"></i> "
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.errorMessage : depth0), depth0))
	    + " </span>\n                </div>\n            </div>\n";
	},"6":function(depth0,helpers,partials,data) {
	    var stack1;

	  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.streamable : depth0),{"name":"if","hash":{},"fn":this.program(7, data, 0),"inverse":this.program(9, data, 0),"data":data})) != null ? stack1 : "");
	},"7":function(depth0,helpers,partials,data) {
	    var stack1;

	  return "                <div class=\"tdlarge-3 tdsmall-12 tdcolumns mini-scrubber\">\n                    <div class=\"tdlarge-12 tdsmall-12 tdcolumns scrubber-box\">\n                        <div class=\"tdlarge-2 tdsmall-2 tdcolumns start-time\">0:00</div>\n                        <div class=\"tdlarge-8 tdsmall-8 tdcolumns scrub-bar-box\">\n                            <input type=\"text\" class=\"scrubber-slider\">\n                        </div>\n                        <div class=\"tdlarge-2 tdsmall-2 tdcolumns stop-time\">\n                            "
	    + this.escapeExpression(__webpack_require__(17).call(depth0,((stack1 = (depth0 != null ? depth0.nowPlaying : depth0)) != null ? stack1.duration : stack1),{"name":"msToTimestamp","hash":{},"data":data}))
	    + "\n                            <i class=\"tdicon-circle-o-notch spin tdloader\"></i>\n                        </div>\n                    </div>\n                </div>\n";
	},"9":function(depth0,helpers,partials,data) {
	    return "                <div class=\"tdlarge-3 tdsmall-12 tdcolumns\">\n                    <div class=\"tdlarge-12 tdsmall-12 tdcolumns track-error-box\">\n                        <span class=\"track-error-box-span\"><i class=\"tdicon-warning\"></i> This track is not streamable.</span>\n                    </div>\n                </div>\n";
	},"11":function(depth0,helpers,partials,data) {
	    var stack1;

	  return "                <div class=\"tdlarge-8 tdsmall-6 tdcolumns buy\">\n                    <a class=\"button expand buy-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\"  target=\"_blank\">\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.useCustomPurchaseTitle : depth0),{"name":"if","hash":{},"fn":this.program(12, data, 0),"inverse":this.program(14, data, 0),"data":data})) != null ? stack1 : "")
	    + "                    </a>\n                </div>\n";
	},"12":function(depth0,helpers,partials,data) {
	    return "                            "
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.purchase_title : depth0), depth0))
	    + "\n";
	},"14":function(depth0,helpers,partials,data) {
	    return "                            BUY\n";
	},"16":function(depth0,helpers,partials,data) {
	    return "                <div class=\"tdlarge-8 tdsmall-6 tdcolumns buy\">\n                    <a class=\"button expand buy-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.download_url : depth0), depth0))
	    + "\"  target=\"_blank\">\n                        DOWNLOAD\n                    </a>\n                </div>\n";
	},"18":function(depth0,helpers,partials,data) {
	    return "                <div class=\"tdlarge-4 tdsmall-6 tdcolumns follow\">\n                    <a class=\"button expand follow-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\"  target=\"_blank\">\n                        <i class=\"tdicon-soundcloud playlist-social-icon\"></i>\n                    </a>\n                </div>\n";
	},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
	    var stack1;

	  return "<div class=\"td tdrow player "
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.skin : depth0), depth0))
	    + " mini\">\n"
	    + ((stack1 = helpers.unless.call(depth0,(depth0 != null ? depth0.nowPlaying : depth0),{"name":"unless","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop,"data":data})) != null ? stack1 : "")
	    + ((stack1 = helpers['with'].call(depth0,(depth0 != null ? depth0.nowPlaying : depth0),{"name":"with","hash":{},"fn":this.program(3, data, 0),"inverse":this.noop,"data":data})) != null ? stack1 : "")
	    + "</div>\n";
	},"useData":true});

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var Handlebars = __webpack_require__(18);
	module.exports = (Handlebars["default"] || Handlebars).template({"1":function(depth0,helpers,partials,data) {
	    return "    <div class=\"tdspinner\">\n        <div class=\"rect1\"></div>\n        <div class=\"rect2\"></div>\n        <div class=\"rect3\"></div>\n        <div class=\"rect4\"></div>\n        <div class=\"rect5\"></div>\n    </div>\n";
	},"3":function(depth0,helpers,partials,data) {
	    var stack1, alias1=this.lambda, alias2=this.escapeExpression;

	  return "            <div class=\"header tdlarge-2 tdsmall-12 tdcolumns\">\n                <div class=\"cover tdlarge-12 tdsmall-12 tdcolumns\">\n                    <div class=\"feed-cover\">\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.artwork_url : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0),"data":data})) != null ? stack1 : "")
	    + "                    </div>\n                    <div class=\"controls\">\n                        <div class=\"buttons tdlarge-12 tdsmall-12 tdcolumns\">\n                            <i class=\"tdicon-play-circle-outline player-play play\"></i>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            <div class=\"feed-container tdlarge-10 tdsmall-12 tdcolumns\">\n                <div class=\"tdrow info-feed\">\n                    <div class=\"tdlarge-12 tdsmall-12 tdcolumns info\">\n                        <div class=\"song-name tdlarge-12 tdsmall-12 tdcolumns\">\n                            <a href=\""
	    + alias2(alias1((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\" target=\"_blank\">"
	    + alias2(alias1((depth0 != null ? depth0.title : depth0), depth0))
	    + "</a>\n                        </div>\n                        <div class=\"artist-name tdlarge-12 tdsmall-12 tdcolumns\">\n                            <a href=\""
	    + alias2(alias1(((stack1 = (depth0 != null ? depth0.user : depth0)) != null ? stack1.permalink_url : stack1), depth0))
	    + "\" target=\"_blank\">"
	    + alias2(alias1(((stack1 = (depth0 != null ? depth0.user : depth0)) != null ? stack1.username : stack1), depth0))
	    + "</a>\n                        </div>\n                    </div>\n                </div>\n"
	    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.error : depth0),{"name":"if","hash":{},"fn":this.program(8, data, 0),"inverse":this.program(10, data, 0),"data":data})) != null ? stack1 : "")
	    + "                <div class=\"tdrow social\">\n                    <div class=\"current-song-info tdlarge-12 tdcolumns tdsmall-12\">\n                        <div class=\"track-info-plays tdlarge-10 tdsmall-10 tdcolumns\">\n                            <i class=\"tdicon-play-circle-fill current-song-social-icon\"></i>\n                            "
	    + alias2(__webpack_require__(29).call(depth0,(depth0 != null ? depth0.playback_count : depth0),{"name":"commanator","hash":{},"data":data}))
	    + "\n                        </div>\n                        <div class=\"feed-buttons tdlarge-2 tdsmall-2 tdcolumns\">\n"
	    + ((stack1 = __webpack_require__(28).call(depth0,(depth0 != null ? depth0.purchase_url : depth0),(depth0 != null ? depth0.download_url : depth0),{"name":"ifCond","hash":{},"fn":this.program(15, data, 0),"inverse":this.program(17, data, 0),"data":data})) != null ? stack1 : "")
	    + ((stack1 = __webpack_require__(28).call(depth0,(depth0 != null ? depth0.purchase_url : depth0),(depth0 != null ? depth0.download_url : depth0),{"name":"ifCond","hash":{},"fn":this.program(19, data, 0),"inverse":this.program(21, data, 0),"data":data})) != null ? stack1 : "")
	    + "                        </div>\n                    </div>\n                </div>\n";
	},"4":function(depth0,helpers,partials,data) {
	    return "                            <img src=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.artwork_url : depth0), depth0))
	    + "\" />\n";
	},"6":function(depth0,helpers,partials,data) {
	    var stack1;

	  return "                            <img src=\""
	    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.user : depth0)) != null ? stack1.avatar_url : stack1), depth0))
	    + "\" />\n";
	},"8":function(depth0,helpers,partials,data) {
	    return "                    <div class=\"tdrow\">\n                        <div class=\"tdlarge-12 tdsmall-12 tdcolumns\">\n                            <div class=\"tdlarge-12 tdsmall-12 tdcolumns track-error-box\">\n                                <span class=\"track-error-box-span\"><i class=\"tdicon-warning\"></i> "
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.errorMessage : depth0), depth0))
	    + " </span>\n                            </div>\n                        </div>\n                    </div>\n";
	},"10":function(depth0,helpers,partials,data) {
	    var stack1;

	  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.streamable : depth0),{"name":"if","hash":{},"fn":this.program(11, data, 0),"inverse":this.program(13, data, 0),"data":data})) != null ? stack1 : "");
	},"11":function(depth0,helpers,partials,data) {
	    return "                        <div class=\"tdrow\"></div>\n";
	},"13":function(depth0,helpers,partials,data) {
	    return "                        <div class=\"tdrow\">\n                            <div class=\"tdlarge-12 tdsmall-12 tdcolumns\">\n                                <div class=\"tdlarge-12 tdsmall-12 tdcolumns track-error-box\">\n                                    <span class=\"track-error-box-span\"><i class=\"tdicon-warning\"></i> This track is not streamable.</span>\n                                </div>\n                            </div>\n                        </div>\n";
	},"15":function(depth0,helpers,partials,data) {
	    return "                                <div class=\"follow tdlarge-6 tdsmall-12 tdcolumns\">\n                                    <a class=\"tdbutton expand follow-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\"  target=\"_blank\">\n                                        <i class=\"tdicon-soundcloud playlist-social-icon\"></i>\n                                    </a>\n                                </div>\n";
	},"17":function(depth0,helpers,partials,data) {
	    return "                                <div class=\"follow tdlarge-12 tdsmall-12 tdcolumns\">\n                                    <a class=\"tdbutton expand follow-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.permalink_url : depth0), depth0))
	    + "\"  target=\"_blank\">\n                                        <i class=\"tdicon-soundcloud playlist-social-icon\"></i>\n                                    </a>\n                                </div>\n";
	},"19":function(depth0,helpers,partials,data) {
	    return "                                <div class=\"buy tdlarge-6 tdsmall-12 tdcolumns\">\n                                    <a class=\"tdbutton expand buy-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.purchase_url : depth0), depth0))
	    + "\" target=\"_blank\">\n                                        <i class=\"tdicon-file-download playlist-social-icon\"></i>\n                                    </a>\n                                </div>\n";
	},"21":function(depth0,helpers,partials,data) {
	    var stack1;

	  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.download_url : depth0),{"name":"if","hash":{},"fn":this.program(22, data, 0),"inverse":this.noop,"data":data})) != null ? stack1 : "");
	},"22":function(depth0,helpers,partials,data) {
	    return "                                    <div class=\"buy tdlarge-6 tdsmall-12 tdcolumns\">\n                                        <a class=\"tdbutton expand buy-link\" href=\""
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.download_url : depth0), depth0))
	    + "\" target=\"_blank\">\n                                            <i class=\"tdicon-file-download playlist-social-icon\"></i>\n                                        </a>\n                                    </div>\n";
	},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
	    var stack1;

	  return "<div class=\"td tdrow player "
	    + this.escapeExpression(this.lambda((depth0 != null ? depth0.skin : depth0), depth0))
	    + " feed\">\n"
	    + ((stack1 = helpers.unless.call(depth0,(depth0 != null ? depth0.nowPlaying : depth0),{"name":"unless","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop,"data":data})) != null ? stack1 : "")
	    + "    <div class=\"tdlarge-12 tdsmall-12 tdcolumns tdlarge-centered tdsmall-centered\">\n"
	    + ((stack1 = helpers['with'].call(depth0,(depth0 != null ? depth0.nowPlaying : depth0),{"name":"with","hash":{},"fn":this.program(3, data, 0),"inverse":this.noop,"data":data})) != null ? stack1 : "")
	    + "        </div>\n    </div>\n</div>\n";
	},"useData":true});

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var Handlebars = __webpack_require__(18);
	module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
	    var helper;

	  return "<div class=\"td tdrow player "
	    + this.escapeExpression(((helper = (helper = helpers.skin || (depth0 != null ? depth0.skin : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"skin","hash":{},"data":data}) : helper)))
	    + "\">\n    <div class=\"tdempty tdlarge-12 tdsmall-12 tdsmall-centered tdlarge-centered\">\n        <a href=\"https://www.toneden.io\" target=\"_blank\" class=\"icon-td_logo-link\"><i class=\"icon-td_logo\"></i></a>\n        There are no tracks to play.\n    </div>\n</div>\n";
	},"useData":true});

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Refactored from: https://github.com/kilokeith/soundcloud-soundmanager-player
	 */

	var $ = __webpack_require__(15);
	var async = __webpack_require__(35);
	var d3 = __webpack_require__(16);

	var constants = __webpack_require__(12);
	var soundManager = __webpack_require__(38);

	//define('./jquery-jsonp', ], function(jqueryjsonp) {
	var isSafari = (Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0) == true;
	//object slice
	__slice = [].slice;

	// Setup soundmanager2.
	if(typeof soundManager !== 'undefined') {
	    soundManager.setup({
	        debugMode: false,
	        flashVersion: 9,
	        url: 'swf',
	        useFlashBlock: false,
	        useHighPerformance: false,
	        waitForWindowLoad: true,
	        useConsole: true,
	        useHTML5Audio: true,
	        wmode: 'transparent'
	    });
	}

	/* tdplayer EVENTS */
	/*
	    tdplayer.init
	    tdplayer.play
	    tdplayer.pause
	    tdplayer.stop
	    tdplayer.mute
	    tdplayer.position
	    tdplayer.volume
	    tdplayer.changing_track
	    tdplayer.loop_changed

	*/
	/* tdplayer PLAYLIST EVENTS */
	/*
	    tdplayer.playlist.next
	    tdplayer.playlist.looped
	    tdplayer.playlist.trackLooped
	    tdplayer.playlist.ended
	    tdplayer.playlist.prev
	    tdplayer.playlist.looped
	    tdplayer.playlist.restarted
	    tdplayer.playlist.goto
	    tdplayer.playlist.preloaded
	*/
	/* tdplayer TRACK EVENTS */
	/*
	    tdplayer.track.info_loaded
	    tdplayer.track.bindable
	    tdplayer.track.ready
	    tdplayer.track.finished
	    tdplayer.track.whileloading
	    tdplayer.track.whileplaying
	    tdplayer.track.played
	    tdplayer.track.paused
	    tdplayer.track.resumed
	    tdplayer.track.stopped
	*/

	//SoundCloud Player class
	//v0.9.6
	var SoundCloudPlayer = function(tracks, config) {
	    var defaults = {
	        autoplay: false,
	        autoswitch: true, // For playlists
	        cache: true, // Caches the SC track lookup. Browser should handle the audio
	        cachePrefix: '', // Prefix to add to cache URLs
	        debug: false,
	        flashVersion: 9,
	        loop: false,
	        loopTrack: false,
	        onTrackFinished: null,
	        preload: true, // Prefetch the sc track data
	        startOn: 0,
	        togglePause: true, //Should pause act as a toggle?
	        tracksPerArtist: 10, // When given an artist URL, how many tracks to load?
	        useEQData: true,
	        useHTML5Audio: true,
	        useWaveformData: false,
	        volume: 100
	    };

	    var flashFallback = false;

	    var scResolveUrl = constants.protocol + '//api.soundcloud.com/resolve?url=http://soundcloud.com';
	    var scApiUrl = constants.protocol + '//api.soundcloud.com/';
	    var urlregex = new RegExp(/[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/gi);

	    var numEqBars = 64;
	    var eqBarValues;
	    var eqBarValuesLast;
	    var eqBarInterval = 256 / numEqBars;
	    //keep ref to local scope
	    var self = this;
	    var $this = $(this);

	    //local vars
	    this.tracks = [];
	    this.config = $.extend(defaults, config);
	    this.currentTrackIndex = this.config.startOn;
	    this.currentTrack = null;
	    this.sound = null;
	    this.loopTrack = false;

	    soundManager.setup({
	        debugMode: config.debug
	    });

	    //flag for if we're already inited
	    this.inited = false;

	    //hold a state so when you hit play it'll play on the correct sound when it's ready
	    this.playWhenReady = false;
	    // Cache for SoundCloud lookups.
	    this.cache = {};

	    // Initialization function.
	    this.init = function(){
	        if(self.inited) {
	            return;
	        }

	        self.changeTrack();
	        self.trigger('tdplayer.init');

	        if(self.config.autoplay) {
	            self.play();
	        }

	        self.inited = true;
	    };

	    // Load a track from a trimmed SC url
	    this.changeTrack = function(index){
	        var i;
	        var url;

	        self.log('changeTrack');

	        // Destroy the old sound
	        if(self.sound){
	            self.sound.destruct();
	            self.sound = null;
	        }

	        if(typeof index !== 'undefined') {
	            i = index;
	        } else {
	            i = self.currentTrackIndex;
	        }

	        if(index !== self.currentTrackIndex || !index) {
	            url = self.tracks[i];
	            self.resolveTrack(url, function(track) {
	                self.setSound(track);
	            });

	            self.trigger('tdplayer.changing_track', i);
	        }

	        return self;
	    }

	    /* ---- public methods ---- */

	    // Playlist related methods
	    this.play = function(){
	        self.log('play');

	        // If the sound is there and ready, get to it.
	        // If not, hold a state to come back to when ready.
	        if(self.sound && self.sound.readyState == 3) {
	            self.sound.play();
	        } else {
	            self.playWhenReady = true;
	        }

	        self.trigger('tdplayer.play', self.currentTrackIndex);

	        return self;
	    };

	    this.pause = function(force){
	        if(!force) {
	            force = false;
	        }

	        if(self.sound) {
	            if(self.config.togglePause && !force) {
	                self.sound.togglePause();
	            } else {
	                self.sound.pause();
	            }

	            self.trigger('tdplayer.pause', self.sound.paused);
	        }

	        return self;
	    };

	    this.resume = function(force){
	        if(!force) {
	            force = false;
	        }

	        if(self.sound) {
	            if(self.config.togglePause && !force) {
	                self.sound.togglePause();
	            } else {
	                self.sound.resume();
	            }

	            self.trigger('tdplayer.pause', self.sound.paused);
	        }

	        return self;
	    };

	    this.stop = function() {
	        if(self.sound) {
	            self.sound.stop();
	        }

	        self.trigger('tdplayer.stop');
	        self.log('stop');

	        return self;
	    };

	    this.next = function(autoplay) {
	        self.log('next');

	        // Play the next track?
	        if(typeof autoplay === 'undefined') {
	            self.playWhenReady = self.config.autoswitch;
	        } else {
	            self.playWhenReady = autoplay;
	        }

	        self.log(self.playWhenReady);

	        if(self.config.loopTrack) {
	            self.trigger('tdplayer.playlist.trackLooped');

	            self.changeTrack();
	        } else if(self.tracks[self.currentTrackIndex + 1]) {
	            self.currentTrackIndex += 1;
	            self.changeTrack();

	            self.trigger('tdplayer.playlist.next', self.currentTrackIndex-1, self.currentTrackIndex);
	            self.log('has next');
	        } else if(self.config.loop) {
	            self.currentTrackIndex = 0;
	            self.changeTrack();

	            self.trigger('tdplayer.playlist.looped');
	            self.log('looped');
	        } else {
	            self.currentTrackIndex = self.tracks.length - 1;

	            self.trigger('tdplayer.playlist.ended', self.config.onPlaylistFinished);
	            self.log('no mas');
	        }

	        return self;
	    };

	    this.prev = function(autoplay){
	        // Play the next track?
	        if(typeof autoplay === 'undefined') {
	            self.playWhenReady = self.config.autoswitch;
	        } else {
	            self.playWhenReady = autoplay;
	        }

	        if(self.tracks[self.currentTrackIndex - 1]) {
	            self.currentTrackIndex -= 1;
	            self.changeTrack();

	            self.trigger('tdplayer.playlist.prev');
	        } else if(self.config.loop) {
	            self.currentTrackIndex = self.tracks.length - 1;
	            self.changeTrack();

	            self.trigger('tdplayer.playlist.looped');
	        } else {
	            self.currentTrackIndex = 0;
	            self.trigger('tdplayer.playlist.restarted');
	        }

	        return self;
	    };

	    this.goto = function(index, autoplay){
	        self.log('goto');

	        // Play the next track?
	        if(typeof autoplay === 'undefined') {
	            self.playWhenReady = self.config.autoswitch;
	        } else {
	            self.playWhenReady = autoplay;
	        }

	        if(self.tracks[index]) {
	            self.currentTrackIndex = index;

	            self.trigger('tdplayer.playlist.goto');
	            self.changeTrack();
	        }

	        return self;
	    };

	    // Sound related methods
	    this.restartTrack = function() {
	        self.position(0);
	        return self;
	    };

	    this.mute = function() {
	        if(self.sound) {
	            self.sound.toggleMute();
	        }

	        self.trigger('tdplayer.mute', self.sound.muted);

	        return self;
	    };

	    // Could we move to the next track?
	    this.hasNext = function() {
	        self.log('has next');

	        if(self.tracks[self.currentTrackIndex + 1]) {
	            return true;
	        } else if(self.config.loop && self.tracks.length > 1) {
	            return true;
	        }

	        return false;
	    };

	    // Could we move to the previous track?
	    this.hasPrev = function() {
	        if(self.tracks[self.currentTrackIndex - 1]) {
	            return true;
	        } else if(self.config.loop && self.tracks.length > 1) {
	            return true;
	        }

	        return false;
	    };


	    this.getTime = function() {
	        var time = this.position();
	        var ms = time % 1000;
	        var s = Math.floor((time / 1000) % 60);
	        var m = Math.floor((time / (60 * 1000)) % 60);
	        var h = Math.floor((time / (60 * 60 * 1000)) % 24);
	        var t = m + ':' + self.pad(s);

	        if(h > 0) {
	            t = h + ':' + t;
	        }

	        return t;
	    };

	    this.position = function(pos) {
	        if(self.sound) {
	            if(pos || pos === 0) {
	                //limit to bounds
	                pos = Math.min(self.sound.duration, pos);
	                pos = Math.max(0, pos);

	                self.trigger('tdplayer.position', pos);

	                //setter
	                return self.sound.setPosition(pos);
	            } else {
	                self.trigger('tdplayer.position', self.sound.position);

	                //getter
	                return self.sound.position;
	            }
	        } else {
	            return 0;
	        }
	    };

	    this.volume = function(vol) {
	        if(self.sound) {
	            if(vol || vol === 0) {
	                //limit to bounds
	                vol = Math.min(100, vol);
	                vol = Math.max(0, vol);

	                self.trigger('tdplayer.volume', vol);

	                //setter
	                self.config.volume = vol;
	                return self.sound.setVolume(vol);
	            } else {
	                self.trigger('tdplayer.volume', self.sound.volume);

	                //getter
	                return self.sound.volume;
	            }
	        } else {
	            return self.config.volume;
	        }
	    };

	    // Move to a new position in the song given a click location in the
	    // form of a fraction of the song length.
	    this.seek = function(relative) {
	        var pos = self.currentTrack.duration * relative;
	        self.position(pos);

	        return self;
	    };

	    // Loop to the start of the playlist.
	    this.loop = function(doLoop){
	        if(doLoop){
	            self.config.loop = doLoop;
	            self.trigger('tdplayer.loop_changed', self.config.loop);
	        }

	        return self.config.loop;
	    };

	    // Lookup a track's data, either from cache or do a lookup. Takes id or url.
	    this.trackInfo = function(id, cb){
	        if(self.isNumeric(id)) {
	            id = self.tracks[id];
	        }

	        return self.resolveTrack(id, cb);
	    };

	    // Use jquery to register events.
	    this.on = function(evnt, cb){
	        return $this.on(evnt, cb);
	    };

	    this.trigger = function(evnt){
	        var args = (arguments.length > 1) ? __slice.call(arguments, 1) : [];

	        return $this.trigger(evnt, args);
	    };

	    // Readies player for garbage collection.
	    this.destroy = function(){
	        if(self.sound) {
	            self.sound.destruct();
	        }

	        self.tracks = [];
	        $this.off();
	        $this.remove();
	        self.tracks = [];
	        self.track = null;
	    };

	    /* ---- private methods ---- */

	    self.getTrack = function() {
	        return self.currentTrack;
	    };

	    self.getTracks = function(callback) {
	        var urls = self.getPlaylist();
	        var trackObjects = [];

	        async.map(urls, function(url, done) {
	            self.trackInfo(url, function(track) {
	                return done(null, track);
	            });
	        }, function(err, trackObjects) {
	            if(err) {
	                return callback([]);
	            } else {
	                return callback(trackObjects);
	            }
	        });
	    };

	    self.getTrackIndex = function() {
	        return self.currentTrackIndex;
	    };

	    self.getSound = function() {
	        return self.sound;
	    };

	    self.getPlaylist = function() {
	        return self.tracks;
	    };

	    self.setCache = function(url, track) {
	        if(self.config.cache === true) {
	            self.cache[self.config.cachePrefix + url] = track;
	        }
	    };

	    self.getCache = function(url) {
	        if(self.config.cache === true) {
	            return self.cache[self.config.cachePrefix + url] || null;
	        }

	        return null;
	    };

	    self.setSound = function(track) {
	        var isMoz = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
	        var flashFallback;

	        if(isMoz === true) {
	            flashFallback = true;
	        }

	        // Store the current track object
	        self.currentTrack = track;
	        self.log('setSound');
	        self.trigger('tdplayer.track.info_loaded', track);

	        if(!track || !track.streamable) {
	            return;
	        }


	        // Get a SC url
	        var url = track.stream_url;

	        if(url.indexOf('secret_token') === -1) {
	            url += '?';
	        } else {
	            url += '&';
	        }

	        url += 'consumer_key=' + self.config.consumerKey;
	        url = url + "&ts=" + Math.round((new Date()).getTime() / 1000);

	        // Setup the SM2 sound object.
	        self.sound = soundManager.createSound({
	            flashVersion: 9,
	            autoLoad: true,
	            useHighPerformance: false,
	            id: 'track_' + track.id + self.config.cachePrefix,
	            multiShot: false,
	            loops: 1,
	            url: url,
	            volume: self.config.volume,
	            waitForWindowLoad: true,
	            wmode: 'transparent',
	            useEQData: true,
	            useWaveformData: false,
	            preferFlash: flashFallback,
	            whileloading: function() {
	                // Only use whole number percents.
	                var percent = Math.round(this.bytesLoaded / this.bytesTotal * 100);
	                self.trigger('tdplayer.track.whileloading', percent);
	            },
	            whileplaying: function() {
	                eqBarValues = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

	                if(self.config.visualizer == true && this.eqData) {
	                    for (var i=0;i<256;i++){
	                        eqBarValues[(i/eqBarInterval)>>0] += this.eqData.left[i];
	                    }
	                }

	                var reverseEqBarValues = eqBarValues.slice().reverse();
	                var fullEQ = reverseEqBarValues.concat(eqBarValues);
	                // Round to nearest 10th of a percent for performance
	                var percent = Math.round(this.position / track.duration * 100 * 10) / 10;
	                self.trigger('tdplayer.track.whileplaying', percent, fullEQ);
	            },
	            onplay: function() {
	                self.log('track.onplay');
	                self.trigger('tdplayer.track.played');
	            },
	            onresume: function() {
	                self.trigger('tdplayer.track.resumed');
	            },
	            onstop: function() {
	                self.trigger('tdplayer.track.stopped');
	            },
	            onpause: function() {
	                self.trigger('tdplayer.track.paused');
	            },
	            onfinish: function() {
	                if(self.config.onTrackFinished) {
	                    self.config.onTrackFinished(arguments);
	                }

	                self.trigger('tdplayer.track.finished');
	            },
	            onload: function() {
	                self.log('onload');
	                self.trigger('tdplayer.track.ready', self.config.onTrackReady);
	            }
	        });

	        self.trigger('tdplayer.track.bindable', track, self.sound);
	    };

	    // Gets a SC url and goes to SC to fetch the track data.
	    self.resolveTrack = function(url, cb) {
	        var originalUrl = url;

	        if(!url) {
	            return;
	        }

	        if(typeof url === 'object') {
	            return cb(url);
	        }

	        url = url.replace(/https?\:\/\/(www\.)?soundcloud\.com/gi, "");

	        var trackPromise = new $.Deferred();
	        var cached = self.getCache(url);
	        var streamSource;
	        var _track;

	        if(originalUrl.search(/(toneden\.io|toneden\.co|lvho.st)/i) !== -1) {
	            streamSource = 'toneden';
	        } else if(originalUrl.search(/soundcloud\.com/i) !== -1) {
	            streamSource = 'soundcloud';
	        } else if(originalUrl.match(urlregex)) {
	            streamSource = 'external';
	        }

	        // Allow non SC tracks (watch for bugs)
	        // look for a url, but not soundcloud.com
	        if(streamSource === 'external') {
	            _track = {
	                duration:0,
	                id:0,
	                permalink_url: url,
	                streamable: true,
	                stream_url: url
	            };

	            trackPromise.resolve(_track);
	        }

	        // If we're caching, check cache first.
	        if(self.config.cache === true && cached) {
	            if(cb) {
	                trackPromise.done(function() {
	                    cb(cached);
	                }).resolve();
	            }
	        } else {
	            // Define a complete condition for the promise.
	            trackPromise.done(function(_track) {
	                if(cb) {
	                    return cb(_track);
	                }
	            });

	            if(streamSource === 'toneden') {
	                self.resolveToneDenTrack(trackPromise);
	            } else if(streamSource === 'soundcloud') {
	                self.resolveSoundCloudTrack(trackPromise, url, originalUrl);
	            }
	        }

	        return trackPromise;
	    };

	    self.resolveToneDenTrack = function(trackPromise, url) {
	        $.ajax({
	            type: 'GET',
	            datatype: 'json',
	            url: url
	        });
	    };

	    self.resolveSoundCloudTrack = function(trackPromise, url, originalUrl) {
	        var datatype;
	        var resolveUrl;
	        var ajaxFunctionName;

	        // Safari is stupid, and doesn't follow redirects with json datatype.
	        if(isSafari) {
	            ajaxFunctionName = 'jsonp';
	            datatype = 'jsonp';
	            resolveUrl = scResolveUrl + url +
	                '&format=json' +
	                '&consumer_key=' + self.config.consumerKey +
	                '&callback=?';
	        } else {
	            ajaxFunctionName = 'ajax';
	            datatype = 'json';
	            resolveUrl = scResolveUrl + url +
	                '&format=json' +
	                '&consumer_key=' + self.config.consumerKey;
	        }

	        $[ajaxFunctionName]({
	            type: 'GET',
	            datatype: datatype,
	            url: resolveUrl,
	            crossDomain: true,
	            error: function(jqXHR, textStatus, errorThrown){
	                var track = {
	                    error: true,
	                    errorMessage: 'We couldn\'t load that track :('
	                };

	                if(self.config.cache) {
	                    self.setCache(url, track);
	                }

	                trackPromise.resolve(track);
	            },
	            success: function(_track) {
	                // Three types of 'tracks': users, sets, and individual tracks.
	                if(_track.kind === 'user') {
	                    self.getTracksForUser(_track, self.config.tracksPerArtist, function(tracks) {
	                        self.parseTracks(originalUrl, tracks, function(tracks) {
	                            _track = tracks[0];

	                            trackPromise.resolve(_track);
	                        });
	                    });
	                } else if(_track.tracks && _track.tracks.length > 0) {
	                    self.parseTracks(originalUrl, _track.tracks, function(tracks) {
	                        _track = tracks[0];
	                        trackPromise.resolve(_track);
	                    });
	                } else {
	                    // maybe cache the track
	                    self.processTrack(_track, function(track) {
	                        if(self.config.cache) {
	                            self.setCache(url, track);
	                        }

	                        trackPromise.resolve(track);
	                    });
	                }
	            }
	        });
	    };

	    // Gets tracks for a given user.
	    self.getTracksForUser = function(user, numTracks, cb) {
	        var tracksUrl = scApiUrl + 'users/' + user.id + '/tracks.json?' +
	            'consumer_key=' + self.config.consumerKey;

	        $.ajax({
	            url: tracksUrl,
	            error: function(jqXHR, textStatus, errorThrown) {
	                return cb([]);
	            },
	            success: function(tracks) {
	                if(tracks instanceof Array) {
	                    tracks = tracks.slice(0, Math.min(numTracks, tracks.length));
	                } else {
	                    tracks = [];
	                    console.log('Tracks is not an array.', tracks);
	                }

	                return cb(tracks);
	            }
	        });
	    }

	    // Get the comments for a given track.
	    self.getComments = function(track, cb) {
	        var privatePattern = /secret_token=([\w-]+)/g;
	        var match = privatePattern.exec(track.stream_url);

	        var trackCommentsUrl = scApiUrl + 'tracks/' + track.id +
	            '/comments.json?consumer_key=' + self.config.consumerKey;

	        if(match) {
	            trackCommentsUrl += '&secret_token=' + match[1];
	        }

	        $.ajax({
	            url: trackCommentsUrl,
	            error: function(jqXHR, textStatus, errorThrown) {
	                return cb([]);
	            },
	            success: cb
	        });
	    };

	    // Preload the SC track info.
	    self.preloadSCTracks = function(cb) {
	        // Make a copy of the original tracks array, since it will be mutated
	        // if one turns out to be the URL of a set or artist.
	        var originalURLs = JSON.parse(JSON.stringify(self.tracks));

	        async.each(originalURLs, function(url, next) {
	            self.resolveTrack(url, function(resolved) {
	                next();
	            });
	        }, function(err) {
	            if(err) {
	                self.log('Failed to preload tracks.');
	            }
	            
	            self.trigger('tdplayer.playlist.preloaded');

	            if(typeof cb === 'function') {
	                return cb();
	            }
	        });
	    };

	    // Helper function that is called on every track returned from SoundCloud.
	    // Use this to modify any fields on the track.
	    self.processTrack = function(track, cb) {
	        // Change the artwork_url to a larger format.
	        if(track.artwork_url) {
	            track.artwork_url = track.artwork_url.replace('large.jpg', 't500x500.jpg');

	            // SoundCloud uses 4 identical CDN domains to allow concurrently loading more images. Randomly select
	            // one to load from.
	            var between1And4 = Math.round(Math.random() * 3) + 1;

	            if(track.artwork_url.indexOf('i1.sndcdn') !== -1) {
	                track.artwork_url = track.artwork_url.replace('i1.sndcdn', 'i' + between1And4 + '.sndcdn');
	            }
	        }

	        if(track.download_url) {
	            if(track.sharing === 'private') {
	                track.download_url += '&client_id=6f85bdf51b0a19b7ab2df7b969233901';
	            } else {
	                track.download_url += '?client_id=6f85bdf51b0a19b7ab2df7b969233901';
	            }
	        }

	        return cb(track);
	    };

	    self.parseTracks = function(url, _tracks, cb) {
	        var startIndex = self.tracks.indexOf(url);

	        if(!_tracks || _tracks.length === 0) {
	            return cb([]);
	        }

	        async.map(_tracks, function(track, next) {
	            self.processTrack(track, function(processedTrack) {
	                // Slice out track url - begins with http://soundcloud.com/
	                var trackUrl = processedTrack.permalink_url.substring(21);

	                // Cache tracks
	                if(self.config.cache === true) {
	                    self.setCache(trackUrl, processedTrack);
	                }

	                return next(null, processedTrack);
	            });
	        }, function(err, processedTracks) {
	            if(err) {
	                console.error('Error processing tracks.');
	                console.error(err);

	                return cb([]);
	            }

	            // Add tracks to playlist
	            self.tracks = self.tracks.slice(0, startIndex)
	                .concat(processedTracks.map(function(track) {
	                    return track.permalink_url.substring(21);
	                }))
	                .concat(self.tracks.slice(startIndex + 1));
	            
	            return cb(processedTracks);
	        });
	    };

	    self.addTracks = function(tracks) {
	        // take a single string or array of strings
	        if(typeof tracks === 'string') {
	            tracks = [tracks];
	        }

	        if(tracks != null && tracks.length > 0) {
	            // add the tracks to the tracks array
	            self.tracks = self.tracks.concat(tracks);

	            // preload SC data? or init
	            if(self.config.preload == true) {
	                self.preloadSCTracks.call(self, self.init);
	            } else {
	                self.init.call(self);
	            }
	        }
	    };

	    self.removeTracks = function(index, howMany) {
	        // If the current track is in the range to be removed, move to the
	        // next available track.
	        if(self.getTrackIndex() >= index && self.getTrackIndex() <= (index + howMany)) {
	            if(self.tracks.length > index + howMany) {
	                self.changeTrack(index + howMany);
	            } else if(index > 0) {
	                self.changeTrack(index - 1);
	            } else {
	                self.changeTrack(0);
	            }
	        }

	        return self.tracks.splice(index, howMany);
	    };

	    self.setTracks = function(tracks) {
	        // take a single string or array of strings
	        if(typeof tracks === 'string') {
	            tracks = [tracks];
	        }

	        if(tracks != null && tracks.length > 0) {
	            // Set current playlist to the list of tracks.
	            self.tracks = tracks;

	            // preload SC data? or init
	            if(self.config.preload == true) {
	                self.preloadSCTracks.call(self, self.init);
	            } else {
	                self.init.call(self);
	            }
	        }
	    };

	    self.log = function() {
	        if(self.config.debug && window.console) {
	            console.log.apply(console, arguments);
	        }
	    };

	    // Helper utilities
	    self.isNumeric = function(n) {
	        return !isNaN(parseFloat(n)) && isFinite(n);
	    };

	    self.pad = function(num) {
	        if(num < 10) {
	            return '0' + num;
	        } else {
	            return '' + num;
	        }
	    };

	    /* internal events */
	    if(self.config.onPlaylistPreloaded) {
	        self.on('tdplayer.playlist.preloaded', self.config.onPlaylistPreloaded);
	    }

	    self.on('tdplayer.track.ready', function(e, cb) {
	        self.log('track.onready!!!');

	        if(self.playWhenReady == true) {
	            self.playWhenReady = false;
	            self.play();
	        }

	        if(typeof cb === 'function') {
	            cb();
	        }
	    });

	    self.on('tdplayer.track.finished', function(e, cb) {
	        self.log('track finished');

	        if(self.config.autoswitch && (self.config.loop || self.hasNext())) {
	            self.log('finished and autoswitch');
	            self.next().play();
	        }

	        if(typeof cb === 'function') {
	            cb();
	        }
	    });

	    // This shouldn't be necessary, but we want to make sure.
	    self.on('tdplayer.playlist.ended', function(e, cb) {
	        self.log('playlist ended');

	        if(!self.config.loop) {
	            self.stop();
	        }

	        if(typeof cb === 'function') {
	            cb();
	        }
	    });

	    // Init everything when we're sure SM2 has loaded
	    soundManager.onready(function() {
	        self.log('SOUNDMANAGER2 ready!!');

	        // Load tracks.
	        self.addTracks(tracks);
	    });

	    // Detect timeout for loading SM2 swf.
	    soundManager.ontimeout(function() {
	        self.log('SOUNDMANAGER2 TIMEDOUT!!');
	    });

	    //expose only the public methods
	    return {
	        config: this.config,
	        play: this.play,
	        pause: this.pause,
	        resume: this.resume,
	        stop: this.stop,
	        next: this.next,
	        prev: this.prev,
	        mute: this.mute,
	        getTime: this.getTime,
	        volume: this.volume,
	        restartTrack: this.restartTrack,
	        goto: this.goto,
	        position: this.position,
	        seek: this.seek,
	        trackInfo: this.trackInfo,
	        hasNext: this.hasNext,
	        hasPrev: this.hasPrev,
	        on: this.on,
	        addTracks: this.addTracks,
	        removeTracks: this.removeTracks,
	        setTracks: this.setTracks,
	        trigger: this.trigger,
	        track: this.getTrack,
	        tracks: this.getTracks,
	        trackIndex: this.getTrackIndex,
	        sound: this.getSound,
	        playlist: this.getPlaylist,
	        destroy: this.destroy
	    };
	};

	module.exports = SoundCloudPlayer;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate, process) {/*!
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
	(function () {

	    var async = {};
	    function noop() {}

	    // global on the server, window in the browser
	    var root, previous_async;

	    if (typeof window == 'object' && this === window) {
	        root = window;
	    }
	    else if (typeof global == 'object' && this === global) {
	        root = global;
	    }
	    else {
	        root = this;
	    }

	    if (root != null) {
	      previous_async = root.async;
	    }

	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };

	    function only_once(fn) {
	        var called = false;
	        return function() {
	            if (called) throw new Error("Callback was already called.");
	            called = true;
	            fn.apply(this, arguments);
	        };
	    }

	    function _once(fn) {
	        var called = false;
	        return function() {
	            if (called) return;
	            called = true;
	            fn.apply(this, arguments);
	        };
	    }

	    //// cross-browser compatiblity functions ////

	    var _toString = Object.prototype.toString;

	    var _isArray = Array.isArray || function (obj) {
	        return _toString.call(obj) === '[object Array]';
	    };

	    function _isArrayLike(arr) {
	        return _isArray(arr) || (
	            // has a positive integer length property
	            typeof arr.length === "number" &&
	            arr.length >= 0 &&
	            arr.length % 1 === 0
	        );
	    }

	    function _each(coll, iterator) {
	        return _isArrayLike(coll) ?
	            _arrayEach(coll, iterator) :
	            _forEachOf(coll, iterator);
	    }

	    function _arrayEach(arr, iterator) {
	      var index = -1,
	          length = arr.length;

	      while (++index < length) {
	        iterator(arr[index], index, arr);
	      }
	    }

	    function _map(arr, iterator) {
	      var index = -1,
	          length = arr.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = iterator(arr[index], index, arr);
	      }
	      return result;
	    }

	    function _range(count) {
	        return _map(Array(count), function (v, i) { return i; });
	    }

	    function _reduce(arr, iterator, memo) {
	        _arrayEach(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    }

	    function _forEachOf(object, iterator) {
	        _arrayEach(_keys(object), function (key) {
	            iterator(object[key], key);
	        });
	    }

	    var _keys = Object.keys || function (obj) {
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };

	    function _keyIterator(coll) {
	        var i = -1;
	        var len;
	        var keys;
	        if (_isArrayLike(coll)) {
	            len = coll.length;
	            return function next() {
	                i++;
	                return i < len ? i : null;
	            };
	        } else {
	            keys = _keys(coll);
	            len = keys.length;
	            return function next() {
	                i++;
	                return i < len ? keys[i] : null;
	            };
	        }
	    }

	    function _baseSlice(arr, start) {
	        start = start || 0;
	        var index = -1;
	        var length = arr.length;

	        if (start) {
	          length -= start;
	          length = length < 0 ? 0 : length;
	        }
	        var result = Array(length);

	        while (++index < length) {
	          result[index] = arr[index + start];
	        }
	        return result;
	    }

	    function _withoutIndex(iterator) {
	        return function (value, index, callback) {
	            return iterator(value, callback);
	        };
	    }

	    //// exported async module functions ////

	    //// nextTick implementation with browser-compatible fallback ////

	    // capture the global reference to guard against fakeTimer mocks
	    var _setImmediate;
	    if (typeof setImmediate === 'function') {
	        _setImmediate = setImmediate;
	    }

	    if (typeof process === 'undefined' || !(process.nextTick)) {
	        if (_setImmediate) {
	            async.nextTick = function (fn) {
	                // not a direct alias for IE10 compatibility
	                _setImmediate(fn);
	            };
	            async.setImmediate = async.nextTick;
	        }
	        else {
	            async.nextTick = function (fn) {
	                setTimeout(fn, 0);
	            };
	            async.setImmediate = async.nextTick;
	        }
	    }
	    else {
	        async.nextTick = process.nextTick;
	        if (_setImmediate) {
	            async.setImmediate = function (fn) {
	              // not a direct alias for IE10 compatibility
	              _setImmediate(fn);
	            };
	        }
	        else {
	            async.setImmediate = async.nextTick;
	        }
	    }

	    async.forEach =
	    async.each = function (arr, iterator, callback) {
	        return async.eachOf(arr, _withoutIndex(iterator), callback);
	    };

	    async.forEachSeries =
	    async.eachSeries = function (arr, iterator, callback) {
	        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
	    };


	    async.forEachLimit =
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
	    };

	    async.forEachOf =
	    async.eachOf = function (object, iterator, callback) {
	        callback = _once(callback || noop);
	        object = object || [];
	        var size = _isArrayLike(object) ? object.length : _keys(object).length;
	        var completed = 0;
	        if (!size) {
	            return callback(null);
	        }
	        _each(object, function (value, key) {
	            iterator(object[key], key, only_once(done));
	        });
	        function done(err) {
	          if (err) {
	              callback(err);
	          }
	          else {
	              completed += 1;
	              if (completed >= size) {
	                  callback(null);
	              }
	          }
	        }
	    };

	    async.forEachOfSeries =
	    async.eachOfSeries = function (obj, iterator, callback) {
	        callback = _once(callback || noop);
	        obj = obj || [];
	        var nextKey = _keyIterator(obj);
	        var key = nextKey();
	        function iterate() {
	            var sync = true;
	            if (key === null) {
	                return callback(null);
	            }
	            iterator(obj[key], key, only_once(function (err) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    key = nextKey();
	                    if (key === null) {
	                        return callback(null);
	                    } else {
	                        if (sync) {
	                            async.nextTick(iterate);
	                        } else {
	                            iterate();
	                        }
	                    }
	                }
	            }));
	            sync = false;
	        }
	        iterate();
	    };



	    async.forEachOfLimit =
	    async.eachOfLimit = function (obj, limit, iterator, callback) {
	        _eachOfLimit(limit)(obj, iterator, callback);
	    };

	    function _eachOfLimit(limit) {

	        return function (obj, iterator, callback) {
	            callback = _once(callback || noop);
	            obj = obj || [];
	            var nextKey = _keyIterator(obj);
	            if (limit <= 0) {
	                return callback(null);
	            }
	            var done = false;
	            var running = 0;
	            var errored = false;

	            (function replenish () {
	                if (done && running <= 0) {
	                    return callback(null);
	                }

	                while (running < limit && !errored) {
	                    var key = nextKey();
	                    if (key === null) {
	                        done = true;
	                        if (running <= 0) {
	                            callback(null);
	                        }
	                        return;
	                    }
	                    running += 1;
	                    iterator(obj[key], key, only_once(function (err) {
	                        running -= 1;
	                        if (err) {
	                            callback(err);
	                            errored = true;
	                        }
	                        else {
	                            replenish();
	                        }
	                    }));
	                }
	            })();
	        };
	    }


	    function doParallel(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOf, obj, iterator, callback);
	        };
	    }
	    function doParallelLimit(limit, fn) {
	        return function (obj, iterator, callback) {
	            return fn(_eachOfLimit(limit), obj, iterator, callback);
	        };
	    }
	    function doSeries(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOfSeries, obj, iterator, callback);
	        };
	    }

	    function _asyncMap(eachfn, arr, iterator, callback) {
	        callback = _once(callback || noop);
	        var results = [];
	        eachfn(arr, function (value, index, callback) {
	            iterator(value, function (err, v) {
	                results[index] = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, results);
	        });
	    }

	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = function (arr, limit, iterator, callback) {
	        return _mapLimit(limit)(arr, iterator, callback);
	    };

	    function _mapLimit(limit) {
	        return doParallelLimit(limit, _asyncMap);
	    }

	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.inject =
	    async.foldl =
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachOfSeries(arr, function (x, i, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err || null, memo);
	        });
	    };

	    async.foldr =
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, function (x) {
	            return x;
	        }).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };

	    function _filter(eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, index, callback) {
	            iterator(x.value, function (v) {
	                if (v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function () {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    }

	    async.select =
	    async.filter = doParallel(_filter);

	    async.selectSeries =
	    async.filterSeries = doSeries(_filter);

	    function _reject(eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, index, callback) {
	            iterator(x.value, function (v) {
	                if (!v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function () {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    }
	    async.reject = doParallel(_reject);
	    async.rejectSeries = doSeries(_reject);

	    function _detect(eachfn, arr, iterator, main_callback) {
	        eachfn(arr, function (x, index, callback) {
	            iterator(x, function (result) {
	                if (result) {
	                    main_callback(x);
	                    main_callback = noop;
	                }
	                else {
	                    callback();
	                }
	            });
	        }, function () {
	            main_callback();
	        });
	    }
	    async.detect = doParallel(_detect);
	    async.detectSeries = doSeries(_detect);

	    async.any =
	    async.some = function (arr, iterator, main_callback) {
	        async.eachOf(arr, function (x, _, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    main_callback(true);
	                    main_callback = noop;
	                }
	                callback();
	            });
	        }, function () {
	            main_callback(false);
	        });
	    };

	    async.all =
	    async.every = function (arr, iterator, main_callback) {
	        async.eachOf(arr, function (x, _, callback) {
	            iterator(x, function (v) {
	                if (!v) {
	                    main_callback(false);
	                    main_callback = noop;
	                }
	                callback();
	            });
	        }, function () {
	            main_callback(true);
	        });
	    };

	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                callback(null, _map(results.sort(comparator), function (x) {
	                    return x.value;
	                }));
	            }

	        });

	        function comparator(left, right) {
	            var a = left.criteria, b = right.criteria;
	            return a < b ? -1 : a > b ? 1 : 0;
	        }
	    };

	    async.auto = function (tasks, callback) {
	        callback = _once(callback || noop);
	        var keys = _keys(tasks);
	        var remainingTasks = keys.length;
	        if (!remainingTasks) {
	            return callback(null);
	        }

	        var results = {};

	        var listeners = [];
	        function addListener(fn) {
	            listeners.unshift(fn);
	        }
	        function removeListener(fn) {
	            for (var i = 0; i < listeners.length; i += 1) {
	                if (listeners[i] === fn) {
	                    listeners.splice(i, 1);
	                    return;
	                }
	            }
	        }
	        function taskComplete() {
	            remainingTasks--;
	            _arrayEach(listeners.slice(0), function (fn) {
	                fn();
	            });
	        }

	        addListener(function () {
	            if (!remainingTasks) {
	                callback(null, results);
	            }
	        });

	        _arrayEach(keys, function (k) {
	            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
	            function taskCallback(err) {
	                var args = _baseSlice(arguments, 1);
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _arrayEach(_keys(results), function(rkey) {
	                        safeResults[rkey] = results[rkey];
	                    });
	                    safeResults[k] = args;
	                    callback(err, safeResults);
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            }
	            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
	            // prevent dead-locks
	            var len = requires.length;
	            var dep;
	            while (len--) {
	                if (!(dep = tasks[requires[len]])) {
	                    throw new Error('Has inexistant dependency');
	                }
	                if (_isArray(dep) && !!~dep.indexOf(k)) {
	                    throw new Error('Has cyclic dependencies');
	                }
	            }
	            function ready() {
	                return _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            }
	            if (ready()) {
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                addListener(listener);
	            }
	            function listener() {
	                if (ready()) {
	                    removeListener(listener);
	                    task[task.length - 1](taskCallback, results);
	                }
	            }
	        });
	    };

	    async.retry = function(times, task, callback) {
	        var DEFAULT_TIMES = 5;
	        var attempts = [];
	        // Use defaults if times not passed
	        if (typeof times === 'function') {
	            callback = task;
	            task = times;
	            times = DEFAULT_TIMES;
	        }
	        // Make sure times is a number
	        times = parseInt(times, 10) || DEFAULT_TIMES;

	        function wrappedTask(wrappedCallback, wrappedResults) {
	            function retryAttempt(task, finalAttempt) {
	                return function(seriesCallback) {
	                    task(function(err, result){
	                        seriesCallback(!err || finalAttempt, {err: err, result: result});
	                    }, wrappedResults);
	                };
	            }

	            while (times) {
	                attempts.push(retryAttempt(task, !(times-=1)));
	            }
	            async.series(attempts, function(done, data){
	                data = data[data.length - 1];
	                (wrappedCallback || callback)(data.err, data.result);
	            });
	        }

	        // If a callback is passed, run this as a controll flow
	        return callback ? wrappedTask() : wrappedTask;
	    };

	    async.waterfall = function (tasks, callback) {
	        callback = _once(callback || noop);
	        if (!_isArray(tasks)) {
	          var err = new Error('First argument to waterfall must be an array of functions');
	          return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        function wrapIterator(iterator) {
	            return function (err) {
	                if (err) {
	                    callback.apply(null, arguments);
	                }
	                else {
	                    var args = _baseSlice(arguments, 1);
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    ensureAsync(iterator).apply(null, args);
	                }
	            };
	        }
	        wrapIterator(async.iterator(tasks))();
	    };

	    function _parallel(eachfn, tasks, callback) {
	        callback = callback || noop;
	        var results = _isArrayLike(tasks) ? [] : {};

	        eachfn(tasks, function (task, key, callback) {
	            task(function (err) {
	                var args = _baseSlice(arguments, 1);
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                results[key] = args;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, results);
	        });
	    }

	    async.parallel = function (tasks, callback) {
	        _parallel(async.eachOf, tasks, callback);
	    };

	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel(_eachOfLimit(limit), tasks, callback);
	    };

	    async.series = function (tasks, callback) {
	        callback = callback || noop;
	        var results = _isArrayLike(tasks) ? [] : {};

	        async.eachOfSeries(tasks, function (task, key, callback) {
	            task(function (err) {
	                var args = _baseSlice(arguments, 1);
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                results[key] = args;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, results);
	        });
	    };

	    async.iterator = function (tasks) {
	        function makeCallback(index) {
	            function fn() {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            }
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        }
	        return makeCallback(0);
	    };

	    async.apply = function (fn) {
	        var args = _baseSlice(arguments, 1);
	        return function () {
	            return fn.apply(
	                null, args.concat(_baseSlice(arguments))
	            );
	        };
	    };

	    function _concat(eachfn, arr, fn, callback) {
	        var result = [];
	        eachfn(arr, function (x, index, cb) {
	            fn(x, function (err, y) {
	                result = result.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, result);
	        });
	    }
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);

	    async.whilst = function (test, iterator, callback) {
	        if (test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.whilst(test, iterator, callback);
	            });
	        }
	        else {
	            callback(null);
	        }
	    };

	    async.doWhilst = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            var args = _baseSlice(arguments, 1);
	            if (test.apply(null, args)) {
	                async.doWhilst(iterator, test, callback);
	            }
	            else {
	                callback(null);
	            }
	        });
	    };

	    async.until = function (test, iterator, callback) {
	        if (!test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.until(test, iterator, callback);
	            });
	        }
	        else {
	            callback(null);
	        }
	    };

	    async.doUntil = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            var args = _baseSlice(arguments, 1);
	            if (!test.apply(null, args)) {
	                async.doUntil(iterator, test, callback);
	            }
	            else {
	                callback(null);
	            }
	        });
	    };

	    function _queue(worker, concurrency, payload) {
	        if (concurrency == null) {
	            concurrency = 1;
	        }
	        else if(concurrency === 0) {
	            throw new Error('Concurrency must not be zero');
	        }
	        function _insert(q, data, pos, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0 && q.idle()) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                   q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    callback: callback || noop
	                };

	                if (pos) {
	                  q.tasks.unshift(item);
	                } else {
	                  q.tasks.push(item);
	                }

	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	            });
	            async.setImmediate(q.process);
	        }
	        function _next(q, tasks) {
	            return function(){
	                workers -= 1;
	                var args = arguments;
	                _arrayEach(tasks, function (task) {
	                    task.callback.apply(task, args);
	                });
	                if (q.tasks.length + workers === 0) {
	                    q.drain();
	                }
	                q.process();
	            };
	        }

	        var workers = 0;
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            saturated: noop,
	            empty: noop,
	            drain: noop,
	            started: false,
	            paused: false,
	            push: function (data, callback) {
	                _insert(q, data, false, callback);
	            },
	            kill: function () {
	                q.drain = noop;
	                q.tasks = [];
	            },
	            unshift: function (data, callback) {
	                _insert(q, data, true, callback);
	            },
	            process: function () {
	                if (!q.paused && workers < q.concurrency && q.tasks.length) {
	                    while(workers < q.concurrency && q.tasks.length){
	                        var tasks = payload ?
	                            q.tasks.splice(0, payload) :
	                            q.tasks.splice(0, q.tasks.length);

	                        var data = _map(tasks, function (task) {
	                            return task.data;
	                        });

	                        if (q.tasks.length === 0) {
	                            q.empty();
	                        }
	                        workers += 1;
	                        var cb = only_once(_next(q, tasks));
	                        worker(data, cb);
	                    }
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            },
	            idle: function() {
	                return q.tasks.length + workers === 0;
	            },
	            pause: function () {
	                q.paused = true;
	            },
	            resume: function () {
	                if (q.paused === false) { return; }
	                q.paused = false;
	                var resumeCount = Math.min(q.concurrency, q.tasks.length);
	                // Need to call q.process once per concurrent
	                // worker to preserve full concurrency after pause
	                for (var w = 1; w <= resumeCount; w++) {
	                    async.setImmediate(q.process);
	                }
	            }
	        };
	        return q;
	    }

	    async.queue = function (worker, concurrency) {
	        var q = _queue(function (items, cb) {
	            worker(items[0], cb);
	        }, concurrency, 1);

	        return q;
	    };

	    async.priorityQueue = function (worker, concurrency) {

	        function _compareTasks(a, b){
	            return a.priority - b.priority;
	        }

	        function _binarySearch(sequence, item, compare) {
	          var beg = -1,
	              end = sequence.length - 1;
	          while (beg < end) {
	              var mid = beg + ((end - beg + 1) >>> 1);
	              if (compare(item, sequence[mid]) >= 0) {
	                  beg = mid;
	              } else {
	                  end = mid - 1;
	              }
	          }
	          return beg;
	        }

	        function _insert(q, data, priority, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    priority: priority,
	                    callback: typeof callback === 'function' ? callback : noop
	                };

	                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	                async.setImmediate(q.process);
	            });
	        }

	        // Start with a normal queue
	        var q = async.queue(worker, concurrency);

	        // Override push to accept second parameter representing priority
	        q.push = function (data, priority, callback) {
	            _insert(q, data, priority, callback);
	        };

	        // Remove unshift function
	        delete q.unshift;

	        return q;
	    };

	    async.cargo = function (worker, payload) {
	        return _queue(worker, 1, payload);
	    };

	    function _console_fn(name) {
	        return function (fn) {
	            var args = _baseSlice(arguments, 1);
	            fn.apply(null, args.concat([function (err) {
	                var args = _baseSlice(arguments, 1);
	                if (typeof console !== 'undefined') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _arrayEach(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            }]));
	        };
	    }
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/

	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        hasher = hasher || function (x) {
	            return x;
	        };
	        function memoized() {
	            var args = _baseSlice(arguments);
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (key in memo) {
	                async.nextTick(function () {
	                    callback.apply(null, memo[key]);
	                });
	            }
	            else if (key in queues) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([function () {
	                    memo[key] = _baseSlice(arguments);
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                      q[i].apply(null, arguments);
	                    }
	                }]));
	            }
	        }
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };

	    async.unmemoize = function (fn) {
	      return function () {
	        return (fn.unmemoized || fn).apply(null, arguments);
	      };
	    };

	    function _times(mapper) {
	        return function (count, iterator, callback) {
	            mapper(_range(count), iterator, callback);
	        };
	    }

	    async.times = _times(async.map);
	    async.timesSeries = _times(async.mapSeries);
	    async.timesLimit = function (count, limit, iterator, callback) {
	        return async.mapLimit(_range(count), limit, iterator, callback);
	    };

	    async.seq = function (/* functions... */) {
	        var fns = arguments;
	        return function () {
	            var that = this;
	            var args = _baseSlice(arguments);

	            var callback = args.slice(-1)[0];
	            if (typeof callback == 'function') {
	                args.pop();
	            } else {
	                callback = noop;
	            }

	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([function () {
	                    var err = arguments[0];
	                    var nextargs = _baseSlice(arguments, 1);
	                    cb(err, nextargs);
	                }]));
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        };
	    };

	    async.compose = function (/* functions... */) {
	      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
	    };


	    function _applyEach(eachfn, fns /*args...*/) {
	        function go() {
	            var that = this;
	            var args = _baseSlice(arguments);
	            var callback = args.pop();
	            return eachfn(fns, function (fn, _, cb) {
	                fn.apply(that, args.concat([cb]));
	            },
	            callback);
	        }
	        if (arguments.length > 2) {
	            var args = _baseSlice(arguments, 2);
	            return go.apply(this, args);
	        }
	        else {
	            return go;
	        }
	    }

	    async.applyEach = function (/*fns, args...*/) {
	        var args = _baseSlice(arguments);
	        return _applyEach.apply(null, [async.eachOf].concat(args));
	    };
	    async.applyEachSeries = function (/*fns, args...*/) {
	        var args = _baseSlice(arguments);
	        return _applyEach.apply(null, [async.eachOfSeries].concat(args));
	    };


	    async.forever = function (fn, callback) {
	        var done = only_once(callback || noop);
	        var task = ensureAsync(fn);
	        function next(err) {
	            if (err) {
	                return done(err);
	            }
	            task(next);
	        }
	        next();
	    };

	    function ensureAsync(fn) {
	        return function (/*...args, callback*/) {
	            var args = _baseSlice(arguments);
	            var callback = args.pop();
	            args.push(function () {
	                var innerArgs = arguments;
	                if (sync) {
	                    async.setImmediate(function () {
	                        callback.apply(null, innerArgs);
	                    });
	                } else {
	                    callback.apply(null, innerArgs);
	                }
	            });
	            var sync = true;
	            fn.apply(this, args);
	            sync = false;
	        };
	    }

	    async.ensureAsync = ensureAsync;

	    // Node.js
	    if (typeof module !== 'undefined' && module.exports) {
	        module.exports = async;
	    }
	    // AMD / RequireJS
	    else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return async;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }

	}());

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(36).setImmediate, __webpack_require__(37)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(37).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36).setImmediate, __webpack_require__(36).clearImmediate))

/***/ },
/* 37 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            currentQueue[queueIndex].run();
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** @license
	 *
	 * SoundManager 2: JavaScript Sound for the Web
	 * ----------------------------------------------
	 * http://schillmania.com/projects/soundmanager2/
	 *
	 * Copyright (c) 2007, Scott Schiller. All rights reserved.
	 * Code provided under the BSD License:
	 * http://schillmania.com/projects/soundmanager2/license.txt
	 *
	 * V2.97a.20131201
	 */

	/*global window, SM2_DEFER, sm2Debugger, console, document, navigator, setTimeout, setInterval, clearInterval, Audio, opera */
	/*jslint regexp: true, sloppy: true, white: true, nomen: true, plusplus: true, todo: true */

	/**
	 * About this file
	 * -------------------------------------------------------------------------------------
	 * This is the fully-commented source version of the SoundManager 2 API,
	 * recommended for use during development and testing.
	 *
	 * See soundmanager2-nodebug-jsmin.js for an optimized build (~11KB with gzip.)
	 * http://schillmania.com/projects/soundmanager2/doc/getstarted/#basic-inclusion
	 * Alternately, serve this file with gzip for 75% compression savings (~30KB over HTTP.)
	 *
	 * You may notice <d> and </d> comments in this source; these are delimiters for
	 * debug blocks which are removed in the -nodebug builds, further optimizing code size.
	 *
	 * Also, as you may note: Whoa, reliable cross-platform/device audio support is hard! ;)
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(39)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dsp) {

	"use strict";

	var _undefined = undefined;
	var soundManager = null;

	/**
	 * The SoundManager constructor.
	 *
	 * @constructor
	 * @param {string} smURL Optional: Path to SWF files
	 * @param {string} smID Optional: The ID to use for the SWF container element
	 * @this {SoundManager}
	 * @return {SoundManager} The new SoundManager instance
	 */

	function SoundManager(smURL, smID) {

	  /**
	   * soundManager configuration options list
	   * defines top-level configuration properties to be applied to the soundManager instance (eg. soundManager.flashVersion)
	   * to set these properties, use the setup() method - eg., soundManager.setup({url: '/swf/', flashVersion: 9})
	   */

	  this.setupOptions = {

	    'url': (smURL || null),             // path (directory) where SoundManager 2 SWFs exist, eg., /path/to/swfs/
	    'flashVersion': 8,                  // flash build to use (8 or 9.) Some API features require 9.
	    'debugMode': true,                  // enable debugging output (console.log() with HTML fallback)
	    'debugFlash': false,                // enable debugging output inside SWF, troubleshoot Flash/browser issues
	    'useConsole': true,                 // use console.log() if available (otherwise, writes to #soundmanager-debug element)
	    'consoleOnly': true,                // if console is being used, do not create/write to #soundmanager-debug
	    'waitForWindowLoad': false,         // force SM2 to wait for window.onload() before trying to call soundManager.onload()
	    'bgColor': '#ffffff',               // SWF background color. N/A when wmode = 'transparent'
	    'useHighPerformance': false,        // position:fixed flash movie can help increase js/flash speed, minimize lag
	    'flashPollingInterval': null,       // msec affecting whileplaying/loading callback frequency. If null, default of 50 msec is used.
	    'html5PollingInterval': null,       // msec affecting whileplaying() for HTML5 audio, excluding mobile devices. If null, native HTML5 update events are used.
	    'flashLoadTimeout': 1000,           // msec to wait for flash movie to load before failing (0 = infinity)
	    'wmode': null,                      // flash rendering mode - null, 'transparent', or 'opaque' (last two allow z-index to work)
	    'allowScriptAccess': 'always',      // for scripting the SWF (object/embed property), 'always' or 'sameDomain'
	    'useFlashBlock': false,             // *requires flashblock.css, see demos* - allow recovery from flash blockers. Wait indefinitely and apply timeout CSS to SWF, if applicable.
	    'useHTML5Audio': true,              // use HTML5 Audio() where API is supported (most Safari, Chrome versions), Firefox (no MP3/MP4.) Ideally, transparent vs. Flash API where possible.
	    'html5Test': /^(probably|maybe)$/i, // HTML5 Audio() format support test. Use /^probably$/i; if you want to be more conservative.
	    'preferFlash': false,               // overrides useHTML5audio, will use Flash for MP3/MP4/AAC if present. Potential option if HTML5 playback with these formats is quirky.
	    'noSWFCache': false,                // if true, appends ?ts={date} to break aggressive SWF caching.
	    'idPrefix': 'sound'                 // if an id is not provided to createSound(), this prefix is used for generated IDs - 'sound0', 'sound1' etc.

	  };

	  this.defaultOptions = {

	    /**
	     * the default configuration for sound objects made with createSound() and related methods
	     * eg., volume, auto-load behaviour and so forth
	     */

	    'autoLoad': false,        // enable automatic loading (otherwise .load() will be called on demand with .play(), the latter being nicer on bandwidth - if you want to .load yourself, you also can)
	    'autoPlay': false,        // enable playing of file as soon as possible (much faster if "stream" is true)
	    'from': null,             // position to start playback within a sound (msec), default = beginning
	    'loops': 1,               // how many times to repeat the sound (position will wrap around to 0, setPosition() will break out of loop when >0)
	    'onid3': null,            // callback function for "ID3 data is added/available"
	    'onload': null,           // callback function for "load finished"
	    'whileloading': null,     // callback function for "download progress update" (X of Y bytes received)
	    'onplay': null,           // callback for "play" start
	    'onpause': null,          // callback for "pause"
	    'onresume': null,         // callback for "resume" (pause toggle)
	    'whileplaying': null,     // callback during play (position update)
	    'onposition': null,       // object containing times and function callbacks for positions of interest
	    'onstop': null,           // callback for "user stop"
	    'onfailure': null,        // callback function for when playing fails
	    'onfinish': null,         // callback function for "sound finished playing"
	    'multiShot': true,        // let sounds "restart" or layer on top of each other when played multiple times, rather than one-shot/one at a time
	    'multiShotEvents': false, // fire multiple sound events (currently onfinish() only) when multiShot is enabled
	    'position': null,         // offset (milliseconds) to seek to within loaded sound data.
	    'pan': 0,                 // "pan" settings, left-to-right, -100 to 100
	    'stream': true,           // allows playing before entire file has loaded (recommended)
	    'to': null,               // position to end playback within a sound (msec), default = end
	    'type': null,             // MIME-like hint for file pattern / canPlay() tests, eg. audio/mp3
	    'usePolicyFile': false,   // enable crossdomain.xml request for audio on remote domains (for ID3/waveform access)
	    'volume': 100             // self-explanatory. 0-100, the latter being the max.

	  };

	  this.flash9Options = {

	    /**
	     * flash 9-only options,
	     * merged into defaultOptions if flash 9 is being used
	     */

	    'isMovieStar': null,      // "MovieStar" MPEG4 audio mode. Null (default) = auto detect MP4, AAC etc. based on URL. true = force on, ignore URL
	    'usePeakData': false,     // enable left/right channel peak (level) data
	    'useWaveformData': false, // enable sound spectrum (raw waveform data) - NOTE: May increase CPU load.
	    'useEQData': false,       // enable sound EQ (frequency spectrum data) - NOTE: May increase CPU load.
	    'onbufferchange': null,   // callback for "isBuffering" property change
	    'ondataerror': null       // callback for waveform/eq data access error (flash playing audio in other tabs/domains)

	  };

	  this.movieStarOptions = {

	    /**
	     * flash 9.0r115+ MPEG4 audio options,
	     * merged into defaultOptions if flash 9+movieStar mode is enabled
	     */

	    'bufferTime': 3,          // seconds of data to buffer before playback begins (null = flash default of 0.1 seconds - if AAC playback is gappy, try increasing.)
	    'serverURL': null,        // rtmp: FMS or FMIS server to connect to, required when requesting media via RTMP or one of its variants
	    'onconnect': null,        // rtmp: callback for connection to flash media server
	    'duration': null          // rtmp: song duration (msec)

	  };

	  this.audioFormats = {

	    /**
	     * determines HTML5 support + flash requirements.
	     * if no support (via flash and/or HTML5) for a "required" format, SM2 will fail to start.
	     * flash fallback is used for MP3 or MP4 if HTML5 can't play it (or if preferFlash = true)
	     */

	    'mp3': {
	      'type': ['audio/mpeg; codecs="mp3"', 'audio/mpeg', 'audio/mp3', 'audio/MPA', 'audio/mpa-robust'],
	      'required': true
	    },

	    'mp4': {
	      'related': ['aac','m4a','m4b'], // additional formats under the MP4 container
	      'type': ['audio/mp4; codecs="mp4a.40.2"', 'audio/aac', 'audio/x-m4a', 'audio/MP4A-LATM', 'audio/mpeg4-generic'],
	      'required': false
	    },

	    'ogg': {
	      'type': ['audio/ogg; codecs=vorbis'],
	      'required': false
	    },

	    'opus': {
	      'type': ['audio/ogg; codecs=opus', 'audio/opus'],
	      'required': false
	    },

	    'wav': {
	      'type': ['audio/wav; codecs="1"', 'audio/wav', 'audio/wave', 'audio/x-wav'],
	      'required': false
	    }

	  };

	  // HTML attributes (id + class names) for the SWF container

	  this.movieID = 'sm2-container';
	  this.id = (smID || 'sm2movie');

	  this.debugID = 'soundmanager-debug';
	  this.debugURLParam = /([#?&])debug=1/i;

	  // dynamic attributes

	  this.versionNumber = 'V2.97a.20131201';
	  this.version = null;
	  this.movieURL = null;
	  this.altURL = null;
	  this.swfLoaded = false;
	  this.enabled = false;
	  this.oMC = null;
	  this.sounds = {};
	  this.soundIDs = [];
	  this.muted = false;
	  this.didFlashBlock = false;
	  this.filePattern = null;

	  this.filePatterns = {

	    'flash8': /\.mp3(\?.*)?$/i,
	    'flash9': /\.mp3(\?.*)?$/i

	  };

	  // support indicators, set at init

	  this.features = {

	    'buffering': false,
	    'peakData': false,
	    'waveformData': false,
	    'eqData': false,
	    'movieStar': false

	  };

	  // flash sandbox info, used primarily in troubleshooting

	  this.sandbox = {

	    // <d>
	    'type': null,
	    'types': {
	      'remote': 'remote (domain-based) rules',
	      'localWithFile': 'local with file access (no internet access)',
	      'localWithNetwork': 'local with network (internet access only, no local access)',
	      'localTrusted': 'local, trusted (local+internet access)'
	    },
	    'description': null,
	    'noRemote': null,
	    'noLocal': null
	    // </d>

	  };

	  /**
	   * format support (html5/flash)
	   * stores canPlayType() results based on audioFormats.
	   * eg. { mp3: boolean, mp4: boolean }
	   * treat as read-only.
	   */

	  this.html5 = {
	    'usingFlash': null // set if/when flash fallback is needed
	  };

	  // file type support hash
	  this.flash = {};

	  // determined at init time
	  this.html5Only = true;

	  // used for special cases (eg. iPad/iPhone/palm OS?)
	  this.ignoreFlash = false;

	  /**
	   * a few private internals (OK, a lot. :D)
	   */

	  var SMSound,
	  sm2 = this, globalHTML5Audio = null, flash = null, sm = 'soundManager', smc = sm + ': ', h5 = 'HTML5::', id, ua = navigator.userAgent, wl = window.location.href.toString(), doc = document, doNothing, setProperties, init, fV, on_queue = [], debugOpen = true, debugTS, didAppend = false, appendSuccess = false, didInit = false, disabled = false, windowLoaded = false, _wDS, wdCount = 0, initComplete, mixin, assign, extraOptions, addOnEvent, processOnEvents, initUserOnload, delayWaitForEI, waitForEI, rebootIntoHTML5, setVersionInfo, handleFocus, strings, initMovie, preInit, domContentLoaded, winOnLoad, didDCLoaded, getDocument, createMovie, catchError, setPolling, initDebug, debugLevels = ['log', 'info', 'warn', 'error'], defaultFlashVersion = 8, disableObject, failSafely, normalizeMovieURL, oRemoved = null, oRemovedHTML = null, str, flashBlockHandler, getSWFCSS, swfCSS, toggleDebug, loopFix, policyFix, complain, idCheck, waitingForEI = false, initPending = false, startTimer, stopTimer, timerExecute, h5TimerCount = 0, h5IntervalTimer = null, parseURL, messages = [],
	  canIgnoreFlash, needsFlash = null, featureCheck, html5OK, html5CanPlay, html5Ext, html5Unload, domContentLoadedIE, testHTML5, event, slice = Array.prototype.slice, useGlobalHTML5Audio = false, lastGlobalHTML5URL, hasFlash, detectFlash, badSafariFix, html5_events, showSupport, flushMessages, wrapCallback, idCounter = 0,
	  is_iDevice = ua.match(/(ipad|iphone|ipod)/i), isAndroid = ua.match(/android/i), isIE = ua.match(/msie/i), isWebkit = ua.match(/webkit/i), isSafari = (ua.match(/safari/i) && !ua.match(/chrome/i)), isOpera = (ua.match(/opera/i)),
	  mobileHTML5 = (ua.match(/(mobile|pre\/|xoom)/i) || is_iDevice || isAndroid),
	  isBadSafari = (!wl.match(/usehtml5audio/i) && !wl.match(/sm2\-ignorebadua/i) && isSafari && !ua.match(/silk/i) && ua.match(/OS X 10_6_([3-7])/i)), // Safari 4 and 5 (excluding Kindle Fire, "Silk") occasionally fail to load/play HTML5 audio on Snow Leopard 10.6.3 through 10.6.7 due to bug(s) in QuickTime X and/or other underlying frameworks. :/ Confirmed bug. https://bugs.webkit.org/show_bug.cgi?id=32159
	  hasConsole = (window.console !== _undefined && console.log !== _undefined), isFocused = (doc.hasFocus !== _undefined?doc.hasFocus():null), tryInitOnFocus = (isSafari && (doc.hasFocus === _undefined || !doc.hasFocus())), okToDisable = !tryInitOnFocus, flashMIME = /(mp3|mp4|mpa|m4a|m4b)/i, msecScale = 1000,
	  emptyURL = 'about:blank', // safe URL to unload, or load nothing from (flash 8 + most HTML5 UAs)
	  emptyWAV = 'data:audio/wave;base64,/UklGRiYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQIAAAD//w==', // tiny WAV for HTML5 unloading
	  overHTTP = (doc.location?doc.location.protocol.match(/http/i):null),
	  http = (!overHTTP ? 'http:/'+'/' : ''),
	  // mp3, mp4, aac etc.
	  netStreamMimeTypes = /^\s*audio\/(?:x-)?(?:mpeg4|aac|flv|mov|mp4||m4v|m4a|m4b|mp4v|3gp|3g2)\s*(?:$|;)/i,
	  // Flash v9.0r115+ "moviestar" formats
	  netStreamTypes = ['mpeg4', 'aac', 'flv', 'mov', 'mp4', 'm4v', 'f4v', 'm4a', 'm4b', 'mp4v', '3gp', '3g2'],
	  netStreamPattern = new RegExp('\\.(' + netStreamTypes.join('|') + ')(\\?.*)?$', 'i');

	  this.mimePattern = /^\s*audio\/(?:x-)?(?:mp(?:eg|3))\s*(?:$|;)/i; // default mp3 set

	  // use altURL if not "online"
	  this.useAltURL = !overHTTP;

	  swfCSS = {

	    'swfBox': 'sm2-object-box',
	    'swfDefault': 'movieContainer',
	    'swfError': 'swf_error', // SWF loaded, but SM2 couldn't start (other error)
	    'swfTimedout': 'swf_timedout',
	    'swfLoaded': 'swf_loaded',
	    'swfUnblocked': 'swf_unblocked', // or loaded OK
	    'sm2Debug': 'sm2_debug',
	    'highPerf': 'high_performance',
	    'flashDebug': 'flash_debug'

	  };

	  /**
	   * basic HTML5 Audio() support test
	   * try...catch because of IE 9 "not implemented" nonsense
	   * https://github.com/Modernizr/Modernizr/issues/224
	   */

	  this.hasHTML5 = (function() {
	    try {
	      // new Audio(null) for stupid Opera 9.64 case, which throws not_enough_arguments exception otherwise.
	      return (Audio !== _undefined && (isOpera && opera !== _undefined && opera.version() < 10 ? new Audio(null) : new Audio()).canPlayType !== _undefined);
	    } catch(e) {
	      return false;
	    }
	  }());

	  /**
	   * Public SoundManager API
	   * -----------------------
	   */

	  /**
	   * Configures top-level soundManager properties.
	   *
	   * @param {object} options Option parameters, eg. { flashVersion: 9, url: '/path/to/swfs/' }
	   * onready and ontimeout are also accepted parameters. call soundManager.setup() to see the full list.
	   */

	  this.setup = function(options) {

	    var noURL = (!sm2.url);

	    // warn if flash options have already been applied

	    if (options !== _undefined && didInit && needsFlash && sm2.ok() && (options.flashVersion !== _undefined || options.url !== _undefined || options.html5Test !== _undefined)) {
	      complain(str('setupLate'));
	    }

	    // TODO: defer: true?

	    assign(options);

	    // special case 1: "Late setup". SM2 loaded normally, but user didn't assign flash URL eg., setup({url:...}) before SM2 init. Treat as delayed init.

	    if (options) {

	      if (noURL && didDCLoaded && options.url !== _undefined) {
	        sm2.beginDelayedInit();
	      }

	      // special case 2: If lazy-loading SM2 (DOMContentLoaded has already happened) and user calls setup() with url: parameter, try to init ASAP.

	      if (!didDCLoaded && options.url !== _undefined && (doc.readyState === 'interactive' || doc.readyState === 'complete')) {
	        setTimeout(domContentLoaded, 1);
	      }

	    }

	    return sm2;

	  };

	  this.ok = function() {

	    return (needsFlash ? (didInit && !disabled) : (sm2.useHTML5Audio && sm2.hasHTML5));

	  };

	  this.supported = this.ok; // legacy

	  this.getMovie = function(smID) {

	    // safety net: some old browsers differ on SWF references, possibly related to ExternalInterface / flash version
	    return id(smID) || doc[smID] || window[smID];

	  };

	  /**
	   * Creates a SMSound sound object instance.
	   *
	   * @param {object} oOptions Sound options (at minimum, id and url parameters are required.)
	   * @return {object} SMSound The new SMSound object.
	   */

	  this.createSound = function(oOptions, _url) {

	    var cs, cs_string, options, oSound = null;

	    // <d>
	    cs = sm + '.createSound(): ';
	    cs_string = cs + str(!didInit?'notReady':'notOK');
	    // </d>

	    if (!didInit || !sm2.ok()) {
	      complain(cs_string);
	      return false;
	    }

	    if (_url !== _undefined) {
	      // function overloading in JS! :) ..assume simple createSound(id, url) use case
	      oOptions = {
	        'id': oOptions,
	        'url': _url
	      };
	    }

	    // inherit from defaultOptions
	    options = mixin(oOptions);

	    options.url = parseURL(options.url);

	    // generate an id, if needed.
	    if (options.id === undefined) {
	      options.id = sm2.setupOptions.idPrefix + (idCounter++);
	    }

	    // <d>
	    if (options.id.toString().charAt(0).match(/^[0-9]$/)) {
	      sm2._wD(cs + str('badID', options.id), 2);
	    }

	    sm2._wD(cs + options.id + (options.url ? ' (' + options.url + ')' : ''), 1);
	    // </d>

	    if (idCheck(options.id, true)) {
	      sm2._wD(cs + options.id + ' exists', 1);
	      return sm2.sounds[options.id];
	    }

	    function make() {

	      options = loopFix(options);
	      sm2.sounds[options.id] = new SMSound(options);
	      sm2.soundIDs.push(options.id);
	      return sm2.sounds[options.id];

	    }

	    if (html5OK(options)) {

	      oSound = make();
	      sm2._wD(options.id + ': Using HTML5');
	      oSound._setup_html5(options);

	    } else {

	      if (sm2.html5Only) {
	        sm2._wD(options.id + ': No HTML5 support for this sound, and no Flash. Exiting.');
	        return make();
	      }

	      // TODO: Move HTML5/flash checks into generic URL parsing/handling function.

	      if (sm2.html5.usingFlash && options.url && options.url.match(/data\:/i)) {
	        // data: URIs not supported by Flash, either.
	        sm2._wD(options.id + ': data: URIs not supported via Flash. Exiting.');
	        return make();
	      }

	      if (fV > 8) {
	        if (options.isMovieStar === null) {
	          // attempt to detect MPEG-4 formats
	          options.isMovieStar = !!(options.serverURL || (options.type ? options.type.match(netStreamMimeTypes) : false) || (options.url && options.url.match(netStreamPattern)));
	        }
	        // <d>
	        if (options.isMovieStar) {
	          sm2._wD(cs + 'using MovieStar handling');
	          if (options.loops > 1) {
	            _wDS('noNSLoop');
	          }
	        }
	        // </d>
	      }

	      options = policyFix(options, cs);
	      oSound = make();

	      if (fV === 8) {
	        flash._createSound(options.id, options.loops||1, options.usePolicyFile);
	      } else {
	        flash._createSound(options.id, options.url, options.usePeakData, options.useWaveformData, options.useEQData, options.isMovieStar, (options.isMovieStar?options.bufferTime:false), options.loops||1, options.serverURL, options.duration||null, options.autoPlay, true, options.autoLoad, options.usePolicyFile);
	        if (!options.serverURL) {
	          // We are connected immediately
	          oSound.connected = true;
	          if (options.onconnect) {
	            options.onconnect.apply(oSound);
	          }
	        }
	      }

	      if (!options.serverURL && (options.autoLoad || options.autoPlay)) {
	        // call load for non-rtmp streams
	        oSound.load(options);
	      }

	    }

	    // rtmp will play in onconnect
	    if (!options.serverURL && options.autoPlay) {
	      oSound.play();
	    }

	    return oSound;

	  };

	  /**
	   * Destroys a SMSound sound object instance.
	   *
	   * @param {string} sID The ID of the sound to destroy
	   */

	  this.destroySound = function(sID, _bFromSound) {

	    // explicitly destroy a sound before normal page unload, etc.

	    if (!idCheck(sID)) {
	      return false;
	    }

	    var oS = sm2.sounds[sID], i;

	    // Disable all callbacks while the sound is being destroyed
	    oS._iO = {};

	    oS.stop();
	    oS.unload();

	    for (i = 0; i < sm2.soundIDs.length; i++) {
	      if (sm2.soundIDs[i] === sID) {
	        sm2.soundIDs.splice(i, 1);
	        break;
	      }
	    }

	    if (!_bFromSound) {
	      // ignore if being called from SMSound instance
	      oS.destruct(true);
	    }

	    oS = null;
	    delete sm2.sounds[sID];

	    return true;

	  };

	  /**
	   * Calls the load() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @param {object} oOptions Optional: Sound options
	   */

	  this.load = function(sID, oOptions) {

	    if (!idCheck(sID)) {
	      return false;
	    }
	    return sm2.sounds[sID].load(oOptions);

	  };

	  /**
	   * Calls the unload() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   */

	  this.unload = function(sID) {

	    if (!idCheck(sID)) {
	      return false;
	    }
	    return sm2.sounds[sID].unload();

	  };

	  /**
	   * Calls the onPosition() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @param {number} nPosition The position to watch for
	   * @param {function} oMethod The relevant callback to fire
	   * @param {object} oScope Optional: The scope to apply the callback to
	   * @return {SMSound} The SMSound object
	   */

	  this.onPosition = function(sID, nPosition, oMethod, oScope) {

	    if (!idCheck(sID)) {
	      return false;
	    }
	    return sm2.sounds[sID].onposition(nPosition, oMethod, oScope);

	  };

	  // legacy/backwards-compability: lower-case method name
	  this.onposition = this.onPosition;

	  /**
	   * Calls the clearOnPosition() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @param {number} nPosition The position to watch for
	   * @param {function} oMethod Optional: The relevant callback to fire
	   * @return {SMSound} The SMSound object
	   */

	  this.clearOnPosition = function(sID, nPosition, oMethod) {

	    if (!idCheck(sID)) {
	      return false;
	    }
	    return sm2.sounds[sID].clearOnPosition(nPosition, oMethod);

	  };

	  /**
	   * Calls the play() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @param {object} oOptions Optional: Sound options
	   * @return {SMSound} The SMSound object
	   */

	  this.play = function(sID, oOptions) {

	    var result = null,
	        // legacy function-overloading use case: play('mySound', '/path/to/some.mp3');
	        overloaded = (oOptions && !(oOptions instanceof Object));

	    if (!didInit || !sm2.ok()) {
	      complain(sm + '.play(): ' + str(!didInit?'notReady':'notOK'));
	      return false;
	    }

	    if (!idCheck(sID, overloaded)) {

	      if (!overloaded) {
	        // no sound found for the given ID. Bail.
	        return false;
	      }

	      if (overloaded) {
	        oOptions = {
	          url: oOptions
	        };
	      }

	      if (oOptions && oOptions.url) {
	        // overloading use case, create+play: .play('someID', {url:'/path/to.mp3'});
	        sm2._wD(sm + '.play(): Attempting to create "' + sID + '"', 1);
	        oOptions.id = sID;
	        result = sm2.createSound(oOptions).play();
	      }

	    } else if (overloaded) {

	      // existing sound object case
	      oOptions = {
	        url: oOptions
	      };

	    }

	    if (result === null) {
	      // default case
	      result = sm2.sounds[sID].play(oOptions);
	    }

	    return result;

	  };

	  this.start = this.play; // just for convenience

	  /**
	   * Calls the setPosition() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @param {number} nMsecOffset Position (milliseconds)
	   * @return {SMSound} The SMSound object
	   */

	  this.setPosition = function(sID, nMsecOffset) {

	    if (!idCheck(sID)) {
	      return false;
	    }
	    return sm2.sounds[sID].setPosition(nMsecOffset);

	  };

	  /**
	   * Calls the stop() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @return {SMSound} The SMSound object
	   */

	  this.stop = function(sID) {

	    if (!idCheck(sID)) {
	      return false;
	    }

	    sm2._wD(sm + '.stop(' + sID + ')', 1);
	    return sm2.sounds[sID].stop();

	  };

	  /**
	   * Stops all currently-playing sounds.
	   */

	  this.stopAll = function() {

	    var oSound;
	    sm2._wD(sm + '.stopAll()', 1);

	    for (oSound in sm2.sounds) {
	      if (sm2.sounds.hasOwnProperty(oSound)) {
	        // apply only to sound objects
	        sm2.sounds[oSound].stop();
	      }
	    }

	  };

	  /**
	   * Calls the pause() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @return {SMSound} The SMSound object
	   */

	  this.pause = function(sID) {

	    if (!idCheck(sID)) {
	      return false;
	    }
	    return sm2.sounds[sID].pause();

	  };

	  /**
	   * Pauses all currently-playing sounds.
	   */

	  this.pauseAll = function() {

	    var i;
	    for (i = sm2.soundIDs.length-1; i >= 0; i--) {
	      sm2.sounds[sm2.soundIDs[i]].pause();
	    }

	  };

	  /**
	   * Calls the resume() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @return {SMSound} The SMSound object
	   */

	  this.resume = function(sID) {

	    if (!idCheck(sID)) {
	      return false;
	    }
	    return sm2.sounds[sID].resume();

	  };

	  /**
	   * Resumes all currently-paused sounds.
	   */

	  this.resumeAll = function() {

	    var i;
	    for (i = sm2.soundIDs.length-1; i >= 0; i--) {
	      sm2.sounds[sm2.soundIDs[i]].resume();
	    }

	  };

	  /**
	   * Calls the togglePause() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @return {SMSound} The SMSound object
	   */

	  this.togglePause = function(sID) {

	    if (!idCheck(sID)) {
	      return false;
	    }
	    return sm2.sounds[sID].togglePause();

	  };

	  /**
	   * Calls the setPan() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @param {number} nPan The pan value (-100 to 100)
	   * @return {SMSound} The SMSound object
	   */

	  this.setPan = function(sID, nPan) {

	    if (!idCheck(sID)) {
	      return false;
	    }
	    return sm2.sounds[sID].setPan(nPan);

	  };

	  /**
	   * Calls the setVolume() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @param {number} nVol The volume value (0 to 100)
	   * @return {SMSound} The SMSound object
	   */

	  this.setVolume = function(sID, nVol) {

	    if (!idCheck(sID)) {
	      return false;
	    }
	    return sm2.sounds[sID].setVolume(nVol);

	  };

	  /**
	   * Calls the mute() method of either a single SMSound object by ID, or all sound objects.
	   *
	   * @param {string} sID Optional: The ID of the sound (if omitted, all sounds will be used.)
	   */

	  this.mute = function(sID) {

	    var i = 0;

	    if (sID instanceof String) {
	      sID = null;
	    }

	    if (!sID) {

	      sm2._wD(sm + '.mute(): Muting all sounds');
	      for (i = sm2.soundIDs.length-1; i >= 0; i--) {
	        sm2.sounds[sm2.soundIDs[i]].mute();
	      }
	      sm2.muted = true;

	    } else {

	      if (!idCheck(sID)) {
	        return false;
	      }
	      sm2._wD(sm + '.mute(): Muting "' + sID + '"');
	      return sm2.sounds[sID].mute();

	    }

	    return true;

	  };

	  /**
	   * Mutes all sounds.
	   */

	  this.muteAll = function() {

	    sm2.mute();

	  };

	  /**
	   * Calls the unmute() method of either a single SMSound object by ID, or all sound objects.
	   *
	   * @param {string} sID Optional: The ID of the sound (if omitted, all sounds will be used.)
	   */

	  this.unmute = function(sID) {

	    var i;

	    if (sID instanceof String) {
	      sID = null;
	    }

	    if (!sID) {

	      sm2._wD(sm + '.unmute(): Unmuting all sounds');
	      for (i = sm2.soundIDs.length-1; i >= 0; i--) {
	        sm2.sounds[sm2.soundIDs[i]].unmute();
	      }
	      sm2.muted = false;

	    } else {

	      if (!idCheck(sID)) {
	        return false;
	      }
	      sm2._wD(sm + '.unmute(): Unmuting "' + sID + '"');
	      return sm2.sounds[sID].unmute();

	    }

	    return true;

	  };

	  /**
	   * Unmutes all sounds.
	   */

	  this.unmuteAll = function() {

	    sm2.unmute();

	  };

	  /**
	   * Calls the toggleMute() method of a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @return {SMSound} The SMSound object
	   */

	  this.toggleMute = function(sID) {

	    if (!idCheck(sID)) {
	      return false;
	    }
	    return sm2.sounds[sID].toggleMute();

	  };

	  /**
	   * Retrieves the memory used by the flash plugin.
	   *
	   * @return {number} The amount of memory in use
	   */

	  this.getMemoryUse = function() {

	    // flash-only
	    var ram = 0;

	    if (flash && fV !== 8) {
	      ram = parseInt(flash._getMemoryUse(), 10);
	    }

	    return ram;

	  };

	  /**
	   * Undocumented: NOPs soundManager and all SMSound objects.
	   */

	  this.disable = function(bNoDisable) {

	    // destroy all functions
	    var i;

	    if (bNoDisable === _undefined) {
	      bNoDisable = false;
	    }

	    if (disabled) {
	      return false;
	    }

	    disabled = true;
	    _wDS('shutdown', 1);

	    for (i = sm2.soundIDs.length-1; i >= 0; i--) {
	      disableObject(sm2.sounds[sm2.soundIDs[i]]);
	    }

	    // fire "complete", despite fail
	    initComplete(bNoDisable);
	    event.remove(window, 'load', initUserOnload);

	    return true;

	  };

	  /**
	   * Determines playability of a MIME type, eg. 'audio/mp3'.
	   */

	  this.canPlayMIME = function(sMIME) {

	    var result;

	    if (sm2.hasHTML5) {
	      result = html5CanPlay({type:sMIME});
	    }

	    if (!result && needsFlash) {
	      // if flash 9, test netStream (movieStar) types as well.
	      result = (sMIME && sm2.ok() ? !!((fV > 8 ? sMIME.match(netStreamMimeTypes) : null) || sMIME.match(sm2.mimePattern)) : null); // TODO: make less "weird" (per JSLint)
	    }

	    return result;

	  };

	  /**
	   * Determines playability of a URL based on audio support.
	   *
	   * @param {string} sURL The URL to test
	   * @return {boolean} URL playability
	   */

	  this.canPlayURL = function(sURL) {

	    var result;

	    if (sm2.hasHTML5) {
	      result = html5CanPlay({url: sURL});
	    }

	    if (!result && needsFlash) {
	      result = (sURL && sm2.ok() ? !!(sURL.match(sm2.filePattern)) : null);
	    }

	    return result;

	  };

	  /**
	   * Determines playability of an HTML DOM &lt;a&gt; object (or similar object literal) based on audio support.
	   *
	   * @param {object} oLink an HTML DOM &lt;a&gt; object or object literal including href and/or type attributes
	   * @return {boolean} URL playability
	   */

	  this.canPlayLink = function(oLink) {

	    if (oLink.type !== _undefined && oLink.type) {
	      if (sm2.canPlayMIME(oLink.type)) {
	        return true;
	      }
	    }

	    return sm2.canPlayURL(oLink.href);

	  };

	  /**
	   * Retrieves a SMSound object by ID.
	   *
	   * @param {string} sID The ID of the sound
	   * @return {SMSound} The SMSound object
	   */

	  this.getSoundById = function(sID, _suppressDebug) {

	    if (!sID) {
	      return null;
	    }

	    var result = sm2.sounds[sID];

	    // <d>
	    if (!result && !_suppressDebug) {
	      sm2._wD(sm + '.getSoundById(): Sound "' + sID + '" not found.', 2);
	    }
	    // </d>

	    return result;

	  };

	  /**
	   * Queues a callback for execution when SoundManager has successfully initialized.
	   *
	   * @param {function} oMethod The callback method to fire
	   * @param {object} oScope Optional: The scope to apply to the callback
	   */

	  this.onready = function(oMethod, oScope) {

	    var sType = 'onready',
	        result = false;

	    if (typeof oMethod === 'function') {

	      // <d>
	      if (didInit) {
	        sm2._wD(str('queue', sType));
	      }
	      // </d>

	      if (!oScope) {
	        oScope = window;
	      }

	      addOnEvent(sType, oMethod, oScope);
	      processOnEvents();

	      result = true;

	    } else {

	      throw str('needFunction', sType);

	    }

	    return result;

	  };

	  /**
	   * Queues a callback for execution when SoundManager has failed to initialize.
	   *
	   * @param {function} oMethod The callback method to fire
	   * @param {object} oScope Optional: The scope to apply to the callback
	   */

	  this.ontimeout = function(oMethod, oScope) {

	    var sType = 'ontimeout',
	        result = false;

	    if (typeof oMethod === 'function') {

	      // <d>
	      if (didInit) {
	        sm2._wD(str('queue', sType));
	      }
	      // </d>

	      if (!oScope) {
	        oScope = window;
	      }

	      addOnEvent(sType, oMethod, oScope);
	      processOnEvents({type:sType});

	      result = true;

	    } else {

	      throw str('needFunction', sType);

	    }

	    return result;

	  };

	  /**
	   * Writes console.log()-style debug output to a console or in-browser element.
	   * Applies when debugMode = true
	   *
	   * @param {string} sText The console message
	   * @param {object} nType Optional log level (number), or object. Number case: Log type/style where 0 = 'info', 1 = 'warn', 2 = 'error'. Object case: Object to be dumped.
	   */

	  this._writeDebug = function(sText, sTypeOrObject) {

	    // pseudo-private console.log()-style output
	    // <d>

	    var sDID = 'soundmanager-debug', o, oItem;

	    if (!sm2.debugMode) {
	      return false;
	    }

	    if (hasConsole && sm2.useConsole) {
	      if (sTypeOrObject && typeof sTypeOrObject === 'object') {
	        // object passed; dump to console.
	        console.log(sText, sTypeOrObject);
	      } else if (debugLevels[sTypeOrObject] !== _undefined) {
	        console[debugLevels[sTypeOrObject]](sText);
	      } else {
	        console.log(sText);
	      }
	      if (sm2.consoleOnly) {
	        return true;
	      }
	    }

	    o = id(sDID);

	    if (!o) {
	      return false;
	    }

	    oItem = doc.createElement('div');

	    if (++wdCount % 2 === 0) {
	      oItem.className = 'sm2-alt';
	    }

	    if (sTypeOrObject === _undefined) {
	      sTypeOrObject = 0;
	    } else {
	      sTypeOrObject = parseInt(sTypeOrObject, 10);
	    }

	    oItem.appendChild(doc.createTextNode(sText));

	    if (sTypeOrObject) {
	      if (sTypeOrObject >= 2) {
	        oItem.style.fontWeight = 'bold';
	      }
	      if (sTypeOrObject === 3) {
	        oItem.style.color = '#ff3333';
	      }
	    }

	    // top-to-bottom
	    // o.appendChild(oItem);

	    // bottom-to-top
	    o.insertBefore(oItem, o.firstChild);

	    o = null;
	    // </d>

	    return true;

	  };

	  // <d>
	  // last-resort debugging option
	  if (wl.indexOf('sm2-debug=alert') !== -1) {
	    this._writeDebug = function(sText) {
	      window.alert(sText);
	    };
	  }
	  // </d>

	  // alias
	  this._wD = this._writeDebug;

	  /**
	   * Provides debug / state information on all SMSound objects.
	   */

	  this._debug = function() {

	    // <d>
	    var i, j;
	    _wDS('currentObj', 1);

	    for (i = 0, j = sm2.soundIDs.length; i < j; i++) {
	      sm2.sounds[sm2.soundIDs[i]]._debug();
	    }
	    // </d>

	  };

	  /**
	   * Restarts and re-initializes the SoundManager instance.
	   *
	   * @param {boolean} resetEvents Optional: When true, removes all registered onready and ontimeout event callbacks.
	   * @param {boolean} excludeInit Options: When true, does not call beginDelayedInit() (which would restart SM2).
	   * @return {object} soundManager The soundManager instance.
	   */

	  this.reboot = function(resetEvents, excludeInit) {

	    // reset some (or all) state, and re-init unless otherwise specified.

	    // <d>
	    if (sm2.soundIDs.length) {
	      sm2._wD('Destroying ' + sm2.soundIDs.length + ' SMSound object' + (sm2.soundIDs.length !== 1 ? 's' : '') + '...');
	    }
	    // </d>

	    var i, j, k;

	    for (i = sm2.soundIDs.length-1; i >= 0; i--) {
	      sm2.sounds[sm2.soundIDs[i]].destruct();
	    }

	    // trash ze flash (remove from the DOM)

	    if (flash) {

	      try {

	        if (isIE) {
	          oRemovedHTML = flash.innerHTML;
	        }

	        oRemoved = flash.parentNode.removeChild(flash);

	      } catch(e) {

	        // Remove failed? May be due to flash blockers silently removing the SWF object/embed node from the DOM. Warn and continue.

	        _wDS('badRemove', 2);

	      }

	    }

	    // actually, force recreate of movie.

	    oRemovedHTML = oRemoved = needsFlash = flash = null;

	    sm2.enabled = didDCLoaded = didInit = waitingForEI = initPending = didAppend = appendSuccess = disabled = useGlobalHTML5Audio = sm2.swfLoaded = false;

	    sm2.soundIDs = [];
	    sm2.sounds = {};

	    idCounter = 0;

	    if (!resetEvents) {
	      // reset callbacks for onready, ontimeout etc. so that they will fire again on re-init
	      for (i in on_queue) {
	        if (on_queue.hasOwnProperty(i)) {
	          for (j = 0, k = on_queue[i].length; j < k; j++) {
	            on_queue[i][j].fired = false;
	          }
	        }
	      }
	    } else {
	      // remove all callbacks entirely
	      on_queue = [];
	    }

	    // <d>
	    if (!excludeInit) {
	      //sm2._wD(sm + ': Rebooting...');
	    }
	    // </d>

	    // reset HTML5 and flash canPlay test results

	    sm2.html5 = {
	      'usingFlash': null
	    };

	    sm2.flash = {};

	    // reset device-specific HTML/flash mode switches

	    sm2.html5Only = false;
	    sm2.ignoreFlash = false;

	    window.setTimeout(function() {

	      preInit();

	      // by default, re-init

	      if (!excludeInit) {
	        sm2.beginDelayedInit();
	      }

	    }, 20);

	    return sm2;

	  };

	  this.reset = function() {

	    /**
	     * Shuts down and restores the SoundManager instance to its original loaded state, without an explicit reboot. All onready/ontimeout handlers are removed.
	     * After this call, SM2 may be re-initialized via soundManager.beginDelayedInit().
	     * @return {object} soundManager The soundManager instance.
	     */

	    _wDS('reset');
	    return sm2.reboot(true, true);

	  };

	  /**
	   * Undocumented: Determines the SM2 flash movie's load progress.
	   *
	   * @return {number or null} Percent loaded, or if invalid/unsupported, null.
	   */

	  this.getMoviePercent = function() {

	    /**
	     * Interesting syntax notes...
	     * Flash/ExternalInterface (ActiveX/NPAPI) bridge methods are not typeof "function" nor instanceof Function, but are still valid.
	     * Additionally, JSLint dislikes ('PercentLoaded' in flash)-style syntax and recommends hasOwnProperty(), which does not work in this case.
	     * Furthermore, using (flash && flash.PercentLoaded) causes IE to throw "object doesn't support this property or method".
	     * Thus, 'in' syntax must be used.
	     */

	    return (flash && 'PercentLoaded' in flash ? flash.PercentLoaded() : null); // Yes, JSLint. See nearby comment in source for explanation.

	  };

	  /**
	   * Additional helper for manually invoking SM2's init process after DOM Ready / window.onload().
	   */

	  this.beginDelayedInit = function() {

	    windowLoaded = true;
	    domContentLoaded();

	    setTimeout(function() {

	      if (initPending) {
	        return false;
	      }

	      createMovie();
	      initMovie();
	      initPending = true;

	      return true;

	    }, 20);

	    delayWaitForEI();

	  };

	  /**
	   * Destroys the SoundManager instance and all SMSound instances.
	   */

	  this.destruct = function() {

	    sm2._wD(sm + '.destruct()');
	    sm2.disable(true);

	  };

	  /**
	   * SMSound() (sound object) constructor
	   * ------------------------------------
	   *
	   * @param {object} oOptions Sound options (id and url are required attributes)
	   * @return {SMSound} The new SMSound object
	   */

	  SMSound = function(oOptions) {

	    var s = this, resetProperties, add_html5_events, remove_html5_events, stop_html5_timer, start_html5_timer, attachOnPosition, onplay_called = false, onPositionItems = [], onPositionFired = 0, detachOnPosition, applyFromTo, lastURL = null, lastHTML5State, urlOmitted;


	    //HTML5 audio sampling properties
	    this._useAdvancedHTML5 = false;
	    this._useMoz = false;
	    this._fftLeft;
	    this._fftRight;
	    this._fftRightO; //For when we set right = left but want to preserve the original
	    this._waveformLeft;
	    this._waveformRight;
	    this._audioContext;
	    this._processingNode;
	    this._sourceNode;
	    this._fbLength;
	    this._sample_size;
	    this._sample_rate;
	    this._analyser;
	    this._frequencyData;

	    lastHTML5State = {
	      // tracks duration + position (time)
	      duration: null,
	      time: null
	    };

	    this.id = oOptions.id;

	    // legacy
	    this.sID = this.id;

	    this.url = oOptions.url;
	    this.options = mixin(oOptions);

	    // per-play-instance-specific options
	    this.instanceOptions = this.options;

	    // short alias
	    this._iO = this.instanceOptions;

	    // assign property defaults
	    this.pan = this.options.pan;
	    this.volume = this.options.volume;

	    // whether or not this object is using HTML5
	    this.isHTML5 = false;

	    // internal HTML5 Audio() object reference
	    this._a = null;

	    // for flash 8 special-case createSound() without url, followed by load/play with url case
	    urlOmitted = (this.url ? false : true);

	    /**
	     * SMSound() public methods
	     * ------------------------
	     */

	    this.id3 = {};

	    /**
	     * Writes SMSound object parameters to debug console
	     */

	    this._debug = function() {

	      // <d>
	      sm2._wD(s.id + ': Merged options:', s.options);
	      // </d>

	    };

	    /**
	     * Begins loading a sound per its *url*.
	     *
	     * @param {object} oOptions Optional: Sound options
	     * @return {SMSound} The SMSound object
	     */

	    this.load = function(oOptions) {

	      var oSound = null, instanceOptions;

	      if (oOptions !== _undefined) {
	        s._iO = mixin(oOptions, s.options);
	      } else {
	        oOptions = s.options;
	        s._iO = oOptions;
	        if (lastURL && lastURL !== s.url) {
	          _wDS('manURL');
	          s._iO.url = s.url;
	          s.url = null;
	        }
	      }

	      if (!s._iO.url) {
	        s._iO.url = s.url;
	      }

	      s._iO.url = parseURL(s._iO.url);

	      // ensure we're in sync
	      s.instanceOptions = s._iO;

	      // local shortcut
	      instanceOptions = s._iO;

	      sm2._wD(s.id + ': load (' + instanceOptions.url + ')');

	      if (!instanceOptions.url && !s.url) {
	        sm2._wD(s.id + ': load(): url is unassigned. Exiting.', 2);
	        return s;
	      }

	      // <d>
	      if (!s.isHTML5 && fV === 8 && !s.url && !instanceOptions.autoPlay) {
	        // flash 8 load() -> play() won't work before onload has fired.
	        sm2._wD(s.id + ': Flash 8 load() limitation: Wait for onload() before calling play().', 1);
	      }
	      // </d>

	      if (instanceOptions.url === s.url && s.readyState !== 0 && s.readyState !== 2) {
	        _wDS('onURL', 1);
	        // if loaded and an onload() exists, fire immediately.
	        if (s.readyState === 3 && instanceOptions.onload) {
	          // assume success based on truthy duration.
	          wrapCallback(s, function() {
	            instanceOptions.onload.apply(s, [(!!s.duration)]);
	          });
	        }
	        return s;
	      }

	      // reset a few state properties

	      s.loaded = false;
	      s.readyState = 1;
	      s.playState = 0;
	      s.id3 = {};

	      // TODO: If switching from HTML5 -> flash (or vice versa), stop currently-playing audio.

	      if (html5OK(instanceOptions)) {

	        oSound = s._setup_html5(instanceOptions);

	        if (!oSound._called_load) {

	          s._html5_canplay = false;

	          // TODO: review called_load / html5_canplay logic

	          // if url provided directly to load(), assign it here.

	          if (s.url !== instanceOptions.url) {

	            sm2._wD(_wDS('manURL') + ': ' + instanceOptions.url);

	            s._a.src = instanceOptions.url;

	            // TODO: review / re-apply all relevant options (volume, loop, onposition etc.)

	            // reset position for new URL
	            s.setPosition(0);

	          }

	          // given explicit load call, try to preload.

	          // early HTML5 implementation (non-standard)
	          s._a.autobuffer = 'auto';

	          // standard property, values: none / metadata / auto
	          // reference: http://msdn.microsoft.com/en-us/library/ie/ff974759%28v=vs.85%29.aspx
	          s._a.preload = 'auto';

	          s._a._called_load = true;

	        } else {

	          sm2._wD(s.id + ': Ignoring request to load again');

	        }

	      } else {

	        if (sm2.html5Only) {
	          sm2._wD(s.id + ': No flash support. Exiting.');
	          return s;
	        }

	        if (s._iO.url && s._iO.url.match(/data\:/i)) {
	          // data: URIs not supported by Flash, either.
	          sm2._wD(s.id + ': data: URIs not supported via Flash. Exiting.');
	          return s;
	        }

	        try {
	          s.isHTML5 = false;
	          s._iO = policyFix(loopFix(instanceOptions));
	          // re-assign local shortcut
	          instanceOptions = s._iO;
	          if (fV === 8) {
	            flash._load(s.id, instanceOptions.url, instanceOptions.stream, instanceOptions.autoPlay, instanceOptions.usePolicyFile);
	          } else {
	            flash._load(s.id, instanceOptions.url, !!(instanceOptions.stream), !!(instanceOptions.autoPlay), instanceOptions.loops||1, !!(instanceOptions.autoLoad), instanceOptions.usePolicyFile);
	          }
	        } catch(e) {
	          _wDS('smError', 2);
	          debugTS('onload', false);
	          catchError({type:'SMSOUND_LOAD_JS_EXCEPTION', fatal:true});
	        }

	      }

	      // after all of this, ensure sound url is up to date.
	      s.url = instanceOptions.url;

	      return s;

	    };

	    /**
	     * Unloads a sound, canceling any open HTTP requests.
	     *
	     * @return {SMSound} The SMSound object
	     */

	    this.unload = function() {

	      // Flash 8/AS2 can't "close" a stream - fake it by loading an empty URL
	      // Flash 9/AS3: Close stream, preventing further load
	      // HTML5: Most UAs will use empty URL

	      if (s.readyState !== 0) {

	        sm2._wD(s.id + ': unload()');

	        if (!s.isHTML5) {

	          if (fV === 8) {
	            flash._unload(s.id, emptyURL);
	          } else {
	            flash._unload(s.id);
	          }

	        } else {

	          stop_html5_timer();

	          if (s._a) {

	            s._a.pause();

	            // update empty URL, too
	            lastURL = html5Unload(s._a);

	          }

	        }

	        // reset load/status flags
	        resetProperties();

	      }

	      return s;

	    };

	    /**
	     * Unloads and destroys a sound.
	     */

	    this.destruct = function(_bFromSM) {
	      sm2._wD(s.id + ': Destruct');

	      if (!s.isHTML5) {

	        // kill sound within Flash
	        // Disable the onfailure handler
	        s._iO.onfailure = null;
	        flash._destroySound(s.id);

	      } else {

	        stop_html5_timer();

	        if(s._useAdvancedHTML5 && !s._useMoz){
	            this._destroy_WebAudio_Waveform_Parser();
	        }

	        if (s._a) {
	          s._a.pause();
	          html5Unload(s._a);
	          if (!useGlobalHTML5Audio) {
	            remove_html5_events();
	          }
	          // break obvious circular reference
	          s._a._s = null;
	          s._a = null;
	        }

	      }

	      if (!_bFromSM) {
	        // ensure deletion from controller
	        sm2.destroySound(s.id, true);
	      }

	    };

	    /**
	     * Begins playing a sound.
	     *
	     * @param {object} oOptions Optional: Sound options
	     * @return {SMSound} The SMSound object
	     */

	    this.play = function(oOptions, _updatePlayState) {

	      var fN, allowMulti, a, onready,
	          audioClone, onended, oncanplay,
	          startOK = true,
	          exit = null;

	      // <d>
	      fN = s.id + ': play(): ';
	      // </d>

	      // default to true
	      _updatePlayState = (_updatePlayState === _undefined ? true : _updatePlayState);

	      if (!oOptions) {
	        oOptions = {};
	      }

	      // first, use local URL (if specified)
	      if (s.url) {
	        s._iO.url = s.url;
	      }

	      // mix in any options defined at createSound()
	      s._iO = mixin(s._iO, s.options);

	      // mix in any options specific to this method
	      s._iO = mixin(oOptions, s._iO);

	      s._iO.url = parseURL(s._iO.url);

	      s.instanceOptions = s._iO;

	      // RTMP-only
	      if (!s.isHTML5 && s._iO.serverURL && !s.connected) {
	        if (!s.getAutoPlay()) {
	          sm2._wD(fN +' Netstream not connected yet - setting autoPlay');
	          s.setAutoPlay(true);
	        }
	        // play will be called in onconnect()
	        return s;
	      }

	      if (html5OK(s._iO)) {
	        s._setup_html5(s._iO);
	        start_html5_timer();
	      }

	      if (s.playState === 1 && !s.paused) {
	        allowMulti = s._iO.multiShot;
	        if (!allowMulti) {
	          sm2._wD(fN + 'Already playing (one-shot)', 1);
	          if (s.isHTML5) {
	            // go back to original position.
	            s.setPosition(s._iO.position);
	          }
	          exit = s;
	        } else {
	          sm2._wD(fN + 'Already playing (multi-shot)', 1);
	        }
	      }

	      if (exit !== null) {
	        return exit;
	      }

	      // edge case: play() with explicit URL parameter
	      if (oOptions.url && oOptions.url !== s.url) {

	        // special case for createSound() followed by load() / play() with url; avoid double-load case.
	        if (!s.readyState && !s.isHTML5 && fV === 8 && urlOmitted) {

	          urlOmitted = false;

	        } else {

	          // load using merged options
	          s.load(s._iO);

	        }

	      }

	      if (!s.loaded) {

	        if (s.readyState === 0) {

	          sm2._wD(fN + 'Attempting to load');

	          // try to get this sound playing ASAP
	          if (!s.isHTML5 && !sm2.html5Only) {

	            // flash: assign directly because setAutoPlay() increments the instanceCount
	            s._iO.autoPlay = true;
	            s.load(s._iO);

	          } else if (s.isHTML5) {

	            // iOS needs this when recycling sounds, loading a new URL on an existing object.
	            s.load(s._iO);

	          } else {

	            sm2._wD(fN + 'Unsupported type. Exiting.');
	            exit = s;

	          }

	          // HTML5 hack - re-set instanceOptions?
	          s.instanceOptions = s._iO;

	        } else if (s.readyState === 2) {

	          sm2._wD(fN + 'Could not load - exiting', 2);
	          exit = s;

	        } else {

	          sm2._wD(fN + 'Loading - attempting to play...');

	        }

	      } else {

	        // "play()"
	        sm2._wD(fN.substr(0, fN.lastIndexOf(':')));

	      }

	      if (exit !== null) {
	        return exit;
	      }

	      if (!s.isHTML5 && fV === 9 && s.position > 0 && s.position === s.duration) {
	        // flash 9 needs a position reset if play() is called while at the end of a sound.
	        sm2._wD(fN + 'Sound at end, resetting to position:0');
	        oOptions.position = 0;
	      }

	      /**
	       * Streams will pause when their buffer is full if they are being loaded.
	       * In this case paused is true, but the song hasn't started playing yet.
	       * If we just call resume() the onplay() callback will never be called.
	       * So only call resume() if the position is > 0.
	       * Another reason is because options like volume won't have been applied yet.
	       * For normal sounds, just resume.
	       */

	      if (s.paused && s.position >= 0 && (!s._iO.serverURL || s.position > 0)) {

	        // https://gist.github.com/37b17df75cc4d7a90bf6
	        sm2._wD(fN + 'Resuming from paused state', 1);
	        s.resume();

	      } else {

	        s._iO = mixin(oOptions, s._iO);

	        // apply from/to parameters, if they exist (and not using RTMP)
	        if (s._iO.from !== null && s._iO.to !== null && s.instanceCount === 0 && s.playState === 0 && !s._iO.serverURL) {

	          onready = function() {
	            // sound "canplay" or onload()
	            // re-apply from/to to instance options, and start playback
	            s._iO = mixin(oOptions, s._iO);
	            s.play(s._iO);
	          };

	          // HTML5 needs to at least have "canplay" fired before seeking.
	          if (s.isHTML5 && !s._html5_canplay) {

	            // this hasn't been loaded yet. load it first, and then do this again.
	            sm2._wD(fN + 'Beginning load for from/to case');

	            s.load({
	              // note: custom HTML5-only event added for from/to implementation.
	              _oncanplay: onready
	            });

	            exit = false;

	          } else if (!s.isHTML5 && !s.loaded && (!s.readyState || s.readyState !== 2)) {

	            // to be safe, preload the whole thing in Flash.

	            sm2._wD(fN + 'Preloading for from/to case');

	            s.load({
	              onload: onready
	            });

	            exit = false;

	          }

	          if (exit !== null) {
	            return exit;
	          }

	          // otherwise, we're ready to go. re-apply local options, and continue

	          s._iO = applyFromTo();

	        }

	        // sm2._wD(fN + 'Starting to play');

	        // increment instance counter, where enabled + supported
	        if (!s.instanceCount || s._iO.multiShotEvents || (s.isHTML5 && s._iO.multiShot && !useGlobalHTML5Audio) || (!s.isHTML5 && fV > 8 && !s.getAutoPlay())) {
	          s.instanceCount++;
	        }

	        // if first play and onposition parameters exist, apply them now
	        if (s._iO.onposition && s.playState === 0) {
	          attachOnPosition(s);
	        }

	        s.playState = 1;
	        s.paused = false;

	        s.position = (s._iO.position !== _undefined && !isNaN(s._iO.position) ? s._iO.position : 0);

	        if (!s.isHTML5) {
	          s._iO = policyFix(loopFix(s._iO));
	        }

	        if (s._iO.onplay && _updatePlayState) {
	          s._iO.onplay.apply(s);
	          onplay_called = true;
	        }

	        s.setVolume(s._iO.volume, true);
	        s.setPan(s._iO.pan, true);

	        if (!s.isHTML5) {

	          startOK = flash._start(s.id, s._iO.loops || 1, (fV === 9 ? s.position : s.position / msecScale), s._iO.multiShot || false);

	          if (fV === 9 && !startOK) {
	            // edge case: no sound hardware, or 32-channel flash ceiling hit.
	            // applies only to Flash 9, non-NetStream/MovieStar sounds.
	            // http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/media/Sound.html#play%28%29
	            sm2._wD(fN + 'No sound hardware, or 32-sound ceiling hit', 2);
	            if (s._iO.onplayerror) {
	              s._iO.onplayerror.apply(s);
	            }

	          }

	        } else {

	          if (s.instanceCount < 2) {

	            // HTML5 single-instance case

	            start_html5_timer();

	            a = s._setup_html5();

	            s.setPosition(s._iO.position);

	            a.play();

	          } else {

	            // HTML5 multi-shot case

	            sm2._wD(s.id + ': Cloning Audio() for instance #' + s.instanceCount + '...');

	            audioClone = new Audio(s._iO.url);

	            onended = function() {
	              event.remove(audioClone, 'ended', onended);
	              s._onfinish(s);
	              // cleanup
	              html5Unload(audioClone);
	              audioClone = null;
	            };

	            oncanplay = function() {
	              event.remove(audioClone, 'canplay', oncanplay);
	              try {
	                audioClone.currentTime = s._iO.position/msecScale;
	              } catch(err) {
	                complain(s.id + ': multiShot play() failed to apply position of ' + (s._iO.position/msecScale));
	              }
	              audioClone.play();
	            };

	            event.add(audioClone, 'ended', onended);

	            // apply volume to clones, too
	            if (s._iO.volume !== undefined) {
	              audioClone.volume = Math.max(0, Math.min(1, s._iO.volume/100));
	            }

	            // playing multiple muted sounds? if you do this, you're weird ;) - but let's cover it.
	            if (s.muted) {
	              audioClone.muted = true;
	            }

	            if (s._iO.position) {
	              // HTML5 audio can't seek before onplay() event has fired.
	              // wait for canplay, then seek to position and start playback.
	              event.add(audioClone, 'canplay', oncanplay);
	            } else {
	              // begin playback at currentTime: 0
	              audioClone.play();
	            }

	          }

	        }

	      }

	      return s;

	    };

	    // just for convenience
	    this.start = this.play;

	    /**
	     * Stops playing a sound (and optionally, all sounds)
	     *
	     * @param {boolean} bAll Optional: Whether to stop all sounds
	     * @return {SMSound} The SMSound object
	     */

	    this.stop = function(bAll) {

	      var instanceOptions = s._iO,
	          originalPosition;

	      if (s.playState === 1) {

	        sm2._wD(s.id + ': stop()');

	        s._onbufferchange(0);
	        s._resetOnPosition(0);
	        s.paused = false;

	        if (!s.isHTML5) {
	          s.playState = 0;
	        }

	        // remove onPosition listeners, if any
	        detachOnPosition();

	        // and "to" position, if set
	        if (instanceOptions.to) {
	          s.clearOnPosition(instanceOptions.to);
	        }

	        if (!s.isHTML5) {

	          flash._stop(s.id, bAll);

	          // hack for netStream: just unload
	          if (instanceOptions.serverURL) {
	            s.unload();
	          }

	        } else {

	          if (s._a) {

	            originalPosition = s.position;

	            // act like Flash, though
	            s.setPosition(0);

	            // hack: reflect old position for onstop() (also like Flash)
	            s.position = originalPosition;

	            // html5 has no stop()
	            // NOTE: pausing means iOS requires interaction to resume.
	            s._a.pause();

	            s.playState = 0;

	            // and update UI
	            s._onTimer();

	            stop_html5_timer();

	          }

	        }

	        s.instanceCount = 0;
	        s._iO = {};

	        if (instanceOptions.onstop) {
	          instanceOptions.onstop.apply(s);
	        }

	      }

	      return s;

	    };

	    /**
	     * Undocumented/internal: Sets autoPlay for RTMP.
	     *
	     * @param {boolean} autoPlay state
	     */

	    this.setAutoPlay = function(autoPlay) {

	      sm2._wD(s.id + ': Autoplay turned ' + (autoPlay ? 'on' : 'off'));
	      s._iO.autoPlay = autoPlay;

	      if (!s.isHTML5) {
	        flash._setAutoPlay(s.id, autoPlay);
	        if (autoPlay) {
	          // only increment the instanceCount if the sound isn't loaded (TODO: verify RTMP)
	          if (!s.instanceCount && s.readyState === 1) {
	            s.instanceCount++;
	            sm2._wD(s.id + ': Incremented instance count to '+s.instanceCount);
	          }
	        }
	      }

	    };

	    /**
	     * Undocumented/internal: Returns the autoPlay boolean.
	     *
	     * @return {boolean} The current autoPlay value
	     */

	    this.getAutoPlay = function() {

	      return s._iO.autoPlay;

	    };

	    /**
	     * Sets the position of a sound.
	     *
	     * @param {number} nMsecOffset Position (milliseconds)
	     * @return {SMSound} The SMSound object
	     */

	    this.setPosition = function(nMsecOffset) {

	      if (nMsecOffset === _undefined) {
	        nMsecOffset = 0;
	      }

	      var position, position1K,
	          // Use the duration from the instance options, if we don't have a track duration yet.
	          // position >= 0 and <= current available (loaded) duration
	          offset = (s.isHTML5 ? Math.max(nMsecOffset, 0) : Math.min(s.duration || s._iO.duration, Math.max(nMsecOffset, 0)));

	      s.position = offset;
	      position1K = s.position/msecScale;
	      s._resetOnPosition(s.position);
	      s._iO.position = offset;

	      if (!s.isHTML5) {

	        position = (fV === 9 ? s.position : position1K);

	        if (s.readyState && s.readyState !== 2) {
	          // if paused or not playing, will not resume (by playing)
	          flash._setPosition(s.id, position, (s.paused || !s.playState), s._iO.multiShot);
	        }

	      } else if (s._a) {

	        // Set the position in the canplay handler if the sound is not ready yet
	        if (s._html5_canplay) {

	          if (s._a.currentTime !== position1K) {

	            /**
	             * DOM/JS errors/exceptions to watch out for:
	             * if seek is beyond (loaded?) position, "DOM exception 11"
	             * "INDEX_SIZE_ERR": DOM exception 1
	             */
	            sm2._wD(s.id + ': setPosition('+position1K+')');

	            try {
	              s._a.currentTime = position1K;
	              if (s.playState === 0 || s.paused) {
	                // allow seek without auto-play/resume
	                s._a.pause();
	              }
	            } catch(e) {
	              sm2._wD(s.id + ': setPosition(' + position1K + ') failed: ' + e.message, 2);
	            }

	          }

	        } else if (position1K) {

	          // warn on non-zero seek attempts
	          sm2._wD(s.id + ': setPosition(' + position1K + '): Cannot seek yet, sound not ready', 2);
	          return s;

	        }

	        if (s.paused) {

	          // if paused, refresh UI right away
	          // force update
	          s._onTimer(true);

	        }

	      }

	      return s;

	    };

	    /**
	     * Pauses sound playback.
	     *
	     * @return {SMSound} The SMSound object
	     */

	    this.pause = function(_bCallFlash) {

	      if (s.paused || (s.playState === 0 && s.readyState !== 1)) {
	        return s;
	      }

	      sm2._wD(s.id + ': pause()');
	      s.paused = true;

	      if (!s.isHTML5) {
	        if (_bCallFlash || _bCallFlash === _undefined) {
	          flash._pause(s.id, s._iO.multiShot);
	        }
	      } else {
	        s._setup_html5().pause();
	        stop_html5_timer();
	      }

	      if (s._iO.onpause) {
	        s._iO.onpause.apply(s);
	      }

	      return s;

	    };

	    /**
	     * Resumes sound playback.
	     *
	     * @return {SMSound} The SMSound object
	     */

	    /**
	     * When auto-loaded streams pause on buffer full they have a playState of 0.
	     * We need to make sure that the playState is set to 1 when these streams "resume".
	     * When a paused stream is resumed, we need to trigger the onplay() callback if it
	     * hasn't been called already. In this case since the sound is being played for the
	     * first time, I think it's more appropriate to call onplay() rather than onresume().
	     */

	    this.resume = function() {

	      var instanceOptions = s._iO;

	      if (!s.paused) {
	        return s;
	      }

	      sm2._wD(s.id + ': resume()');
	      s.paused = false;
	      s.playState = 1;

	      if (!s.isHTML5) {
	        if (instanceOptions.isMovieStar && !instanceOptions.serverURL) {
	          // Bizarre Webkit bug (Chrome reported via 8tracks.com dudes): AAC content paused for 30+ seconds(?) will not resume without a reposition.
	          s.setPosition(s.position);
	        }
	        // flash method is toggle-based (pause/resume)
	        flash._pause(s.id, instanceOptions.multiShot);
	      } else {
	        s._setup_html5().play();
	        start_html5_timer();
	      }

	      if (!onplay_called && instanceOptions.onplay) {
	        instanceOptions.onplay.apply(s);
	        onplay_called = true;
	      } else if (instanceOptions.onresume) {
	        instanceOptions.onresume.apply(s);
	      }

	      return s;

	    };

	    /**
	     * Toggles sound playback.
	     *
	     * @return {SMSound} The SMSound object
	     */

	    this.togglePause = function() {

	      sm2._wD(s.id + ': togglePause()');

	      if (s.playState === 0) {
	        s.play({
	          position: (fV === 9 && !s.isHTML5 ? s.position : s.position / msecScale)
	        });
	        return s;
	      }

	      if (s.paused) {
	        s.resume();
	      } else {
	        s.pause();
	      }

	      return s;

	    };

	    /**
	     * Sets the panning (L-R) effect.
	     *
	     * @param {number} nPan The pan value (-100 to 100)
	     * @return {SMSound} The SMSound object
	     */

	    this.setPan = function(nPan, bInstanceOnly) {

	      if (nPan === _undefined) {
	        nPan = 0;
	      }

	      if (bInstanceOnly === _undefined) {
	        bInstanceOnly = false;
	      }

	      if (!s.isHTML5) {
	        flash._setPan(s.id, nPan);
	      } // else { no HTML5 pan? }

	      s._iO.pan = nPan;

	      if (!bInstanceOnly) {
	        s.pan = nPan;
	        s.options.pan = nPan;
	      }

	      return s;

	    };

	    /**
	     * Sets the volume.
	     *
	     * @param {number} nVol The volume value (0 to 100)
	     * @return {SMSound} The SMSound object
	     */

	    this.setVolume = function(nVol, _bInstanceOnly) {

	      /**
	       * Note: Setting volume has no effect on iOS "special snowflake" devices.
	       * Hardware volume control overrides software, and volume
	       * will always return 1 per Apple docs. (iOS 4 + 5.)
	       * http://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/AddingSoundtoCanvasAnimations/AddingSoundtoCanvasAnimations.html
	       */

	      if (nVol === _undefined) {
	        nVol = 100;
	      }

	      if (_bInstanceOnly === _undefined) {
	        _bInstanceOnly = false;
	      }

	      if (!s.isHTML5) {
	        flash._setVolume(s.id, (sm2.muted && !s.muted) || s.muted?0:nVol);
	      } else if (s._a) {
	        if (sm2.muted && !s.muted) {
	          s.muted = true;
	          s._a.muted = true;
	        }
	        // valid range: 0-1
	        s._a.volume = Math.max(0, Math.min(1, nVol/100));
	      }

	      s._iO.volume = nVol;

	      if (!_bInstanceOnly) {
	        s.volume = nVol;
	        s.options.volume = nVol;
	      }

	      return s;

	    };

	    /**
	     * Mutes the sound.
	     *
	     * @return {SMSound} The SMSound object
	     */

	    this.mute = function() {

	      s.muted = true;

	      if (!s.isHTML5) {
	        flash._setVolume(s.id, 0);
	      } else if (s._a) {
	        s._a.muted = true;
	      }

	      return s;

	    };

	    /**
	     * Unmutes the sound.
	     *
	     * @return {SMSound} The SMSound object
	     */

	    this.unmute = function() {

	      s.muted = false;
	      var hasIO = (s._iO.volume !== _undefined);

	      if (!s.isHTML5) {
	        flash._setVolume(s.id, hasIO?s._iO.volume:s.options.volume);
	      } else if (s._a) {
	        s._a.muted = false;
	      }

	      return s;

	    };

	    /**
	     * Toggles the muted state of a sound.
	     *
	     * @return {SMSound} The SMSound object
	     */

	    this.toggleMute = function() {

	      return (s.muted?s.unmute():s.mute());

	    };

	    /**
	     * Registers a callback to be fired when a sound reaches a given position during playback.
	     *
	     * @param {number} nPosition The position to watch for
	     * @param {function} oMethod The relevant callback to fire
	     * @param {object} oScope Optional: The scope to apply the callback to
	     * @return {SMSound} The SMSound object
	     */

	    this.onPosition = function(nPosition, oMethod, oScope) {

	      // TODO: basic dupe checking?

	      onPositionItems.push({
	        position: parseInt(nPosition, 10),
	        method: oMethod,
	        scope: (oScope !== _undefined ? oScope : s),
	        fired: false
	      });

	      return s;

	    };

	    // legacy/backwards-compability: lower-case method name
	    this.onposition = this.onPosition;

	    /**
	     * Removes registered callback(s) from a sound, by position and/or callback.
	     *
	     * @param {number} nPosition The position to clear callback(s) for
	     * @param {function} oMethod Optional: Identify one callback to be removed when multiple listeners exist for one position
	     * @return {SMSound} The SMSound object
	     */

	    this.clearOnPosition = function(nPosition, oMethod) {

	      var i;

	      nPosition = parseInt(nPosition, 10);

	      if (isNaN(nPosition)) {
	        // safety check
	        return false;
	      }

	      for (i=0; i < onPositionItems.length; i++) {

	        if (nPosition === onPositionItems[i].position) {
	          // remove this item if no method was specified, or, if the method matches
	          if (!oMethod || (oMethod === onPositionItems[i].method)) {
	            if (onPositionItems[i].fired) {
	              // decrement "fired" counter, too
	              onPositionFired--;
	            }
	            onPositionItems.splice(i, 1);
	          }
	        }

	      }

	    };

	    this._processOnPosition = function() {

	      var i, item, j = onPositionItems.length;
			
	      if (!j || !s.playState || onPositionFired >= j) {
	        return false;
	      }

	      for (i=j-1; i >= 0; i--) {
	        item = onPositionItems[i];
	        if (!item.fired && s.position >= item.position) {
	          item.fired = true;
	          onPositionFired++;
	          item.method.apply(item.scope, [item.position]);
			  j = onPositionItems.length; //  reset j -- onPositionItems.length can be changed in the item callback above... occasionally breaking the loop.
	        }
	      }
		
	      return true;

	    };

	    this._resetOnPosition = function(nPosition) {

	      // reset "fired" for items interested in this position
	      var i, item, j = onPositionItems.length;

	      if (!j) {
	        return false;
	      }

	      for (i=j-1; i >= 0; i--) {
	        item = onPositionItems[i];
	        if (item.fired && nPosition <= item.position) {
	          item.fired = false;
	          onPositionFired--;
	        }
	      }

	      return true;

	    };

	    /**
	     * SMSound() private internals
	     * --------------------------------
	     */

	    applyFromTo = function() {

	      var instanceOptions = s._iO,
	          f = instanceOptions.from,
	          t = instanceOptions.to,
	          start, end;

	      end = function() {

	        // end has been reached.
	        sm2._wD(s.id + ': "To" time of ' + t + ' reached.');

	        // detach listener
	        s.clearOnPosition(t, end);

	        // stop should clear this, too
	        s.stop();

	      };

	      start = function() {

	        sm2._wD(s.id + ': Playing "from" ' + f);

	        // add listener for end
	        if (t !== null && !isNaN(t)) {
	          s.onPosition(t, end);
	        }

	      };

	      if (f !== null && !isNaN(f)) {

	        // apply to instance options, guaranteeing correct start position.
	        instanceOptions.position = f;

	        // multiShot timing can't be tracked, so prevent that.
	        instanceOptions.multiShot = false;

	        start();

	      }

	      // return updated instanceOptions including starting position
	      return instanceOptions;

	    };

	    attachOnPosition = function() {

	      var item,
	          op = s._iO.onposition;

	      // attach onposition things, if any, now.

	      if (op) {

	        for (item in op) {
	          if (op.hasOwnProperty(item)) {
	            s.onPosition(parseInt(item, 10), op[item]);
	          }
	        }

	      }

	    };

	    detachOnPosition = function() {

	      var item,
	          op = s._iO.onposition;

	      // detach any onposition()-style listeners.

	      if (op) {

	        for (item in op) {
	          if (op.hasOwnProperty(item)) {
	            s.clearOnPosition(parseInt(item, 10));
	          }
	        }

	      }

	    };

	    start_html5_timer = function() {

	      if (s.isHTML5) {
	        startTimer(s);
	      }

	    };

	    stop_html5_timer = function() {

	      if (s.isHTML5) {
	        stopTimer(s);
	      }

	    };

	    resetProperties = function(retainPosition) {

	      if (!retainPosition) {
	        onPositionItems = [];
	        onPositionFired = 0;
	      }

	      onplay_called = false;

	      s._hasTimer = null;
	      s._a = null;
	      s._html5_canplay = false;
	      s.bytesLoaded = null;
	      s.bytesTotal = null;
	      s.duration = (s._iO && s._iO.duration ? s._iO.duration : null);
	      s.durationEstimate = null;
	      s.buffered = [];

	      // legacy: 1D array
	      s.eqData = [];

	      s.eqData.left = [];
	      s.eqData.right = [];

	      s.frequencyData = [];

	      s.failures = 0;
	      s.isBuffering = false;
	      s.instanceOptions = {};
	      s.instanceCount = 0;
	      s.loaded = false;
	      s.metadata = {};

	      // 0 = uninitialised, 1 = loading, 2 = failed/error, 3 = loaded/success
	      s.readyState = 0;

	      s.muted = false;
	      s.paused = false;

	      s.peakData = {
	        left: 0,
	        right: 0
	      };

	      s.waveformData = {
	        left: [],
	        right: []
	      };

	      s.playState = 0;
	      s.position = null;

	      s.id3 = {};

	    };

	    var audioProcessEvent = function ( e ) {
	      if(s.paused || s.playState === 0) return;
	      // When we're processing some data through the HTML WebAudio API
	      var buffers = [];
	      var channels, resolution;
	      channels = s._channels = e.inputBuffer.numberOfChannels;

	      if(e && e.inputBuffer && e.inputBuffer.getChannelData(0)) {
	        s._waveformLeft = e.inputBuffer.getChannelData(0);
	        
	        if(s.instanceOptions.useEQData){
	          s._fftLeft.forward(s._waveformLeft);
	          // webAudio API frequency data
	          // s._frequencyData = new Uint8Array(s._analyser.frequencyBinCount);
	          // s._analyser.getByteFrequencyData(s._frequencyData);
	        }

	        if(channels > 1){
	          s._waveformRight = e.inputBuffer.getChannelData(1);
	          if(s.instanceOptions.useEQData){
	            s._fftRight = s._fftRightO;
	            s._fftRight.forward(s._waveformRight);
	          }
	        } else {
	          s._waveformRight = s._waveformLeft;
	          s._fftRight = s._fftLeft;
	        }
	      }

	      s._onTimer(true);
	    };
	  
	    this._create_WebAudio_Waveform_Parser = function(){
	      // Initialisation for Google Chrome/Web Audio compatible browsers
	      // TODO: Make this work for Safari/Mozilla

	      // Firefox will only play silence if you attempt to call createMediaElementSource
	      // on an audio file coming from a different origin. Pain in the ass.
	      // See: http://stackoverflow.com/questions/19708561/firefox-25-and-audiocontext-createjavascriptnote-not-a-function

	      s._sample_rate = 44100;
	      s._sample_size = 2048;

	      if(s.instanceOptions.useWaveformData || s.instanceOptions.useEQData || s.instanceOptions.usePeakData){ 
	        var context = s._audioContext;
	        var source = s._sourceNode = context.createMediaElementSource( s._a );
	        var proc;

	        // Cross-compatibility for Chrome and Firefox.
	        if(context.createJavaScriptNode) {
	            proc = s._processingNode = context.createJavaScriptNode( s._sample_size / 2, 1, 1 );
	        } else {
	            proc = s._processingNode = context.createScriptProcessor( s._sample_size / 2, 1, 1 );
	        }

	        source.connect( proc );

	        proc.connect( context.destination );

	        source.connect( context.destination );

	        proc.onaudioprocess = audioProcessEvent;   

	        s._fftLeft = new dsp.FFT( s._sample_size / 2, s._sample_rate );
	        s._fftRight = s._fftRightO = new dsp.FFT( s._sample_size / 2, s._sample_rate );

	        // if(!s._analyser) {
	        //   s._analyser = context.createAnalyser();
	        // }
	        // s._analyser.smoothingTimeConstant = 0.8;
	        // source.connect(s._analyser);
	        // s._analyser.connect(context.destination);
	      }

	    };
	    
	    this._destroy_WebAudio_Waveform_Parser = function(){
	      if(s._sourceNode)
	        s._sourceNode.disconnect(0); 
	      
	      if(s._processingNode)
	        s._processingNode.disconnect(0); 
	    };

	    this._create_Mozilla_Waveform_Parser = function(){
	      //Initialisation for Mozilla Firefox

	      s._sample_rate = 44100;
	      s._fbLength = 2048;
	      s._channels = 2;
	      //s._fbLength = s._a.mozFrameBufferLength;
	      //s._channels = s._a.mozChannels;  
	      //s._sample_rate = s._a.mozSampleRate;     
	 
	      if(s.instanceOptions.useWaveformData || s.instanceOptions.useEQData || s.instanceOptions.usePeakData){ 
	        s._waveformLeft = new Float32Array( s._fbLength / s._channels );
	        s._waveformRight = new Float32Array( s._fbLength / s._channels );
	      }

	      if(s.instanceOptions.useEQData || s.instanceOptions.usePeakData){ 
	        s._fftLeft = new dsp.FFT( s._fbLength / s._channels, s._sample_rate );
	        s._fftRight = s._fftLeft;
	        if(s._channels > 1){
	          s._fftRight = new dsp.FFT( s._fbLength / s._channels, s._sample_rate );
	        }
	      }
	    };

	    resetProperties();

	    /**
	     * Pseudo-private SMSound internals
	     * --------------------------------
	     */

	    this._onTimer = function(bForce) {
	      /**
	       * HTML5-only _whileplaying() etc.
	       * called from both HTML5 native events, and polling/interval-based timers
	       * mimics flash and fires only when time/duration change, so as to be polling-friendly
	       */

	      var duration, isNew = false, time, x = {};
	      var peakData = x;
	      var waveformLeft = x;
	      var waveformRight = x; 
	      var eqData = x;
	      var frequencyData = x;

	      if (s._hasTimer || bForce) {

	        // TODO: May not need to track readyState (1 = loading)

	        if (s._a && (bForce || ((s.playState > 0 || s.readyState === 1) && !s.paused))) {

	          duration = s._get_html5_duration();

	          if (duration !== lastHTML5State.duration) {

	            lastHTML5State.duration = duration;
	            s.duration = duration;
	            isNew = true;

	          }

	          // TODO: investigate why this goes wack if not set/re-set each time.
	          s.durationEstimate = s.duration;

	          //time = (s._audioContext.currentTime * msecScale || 0);
	          time = (s._a.currentTime * msecScale || 0);

	          if (time !== lastHTML5State.time) {

	            lastHTML5State.time = time;
	            isNew = true;

	          }

	          if (isNew || bForce) {

	            // s._whileplaying(time,x,x,x,x);
	            if(s._useAdvancedHTML5){
	                if(s.instanceOptions.useWaveformData){
	                    waveformLeft = s._waveformLeft;
	                    waveformRight = s._waveformRight;
	                }
	                if(s.instanceOptions.useEQData){
	                    eqData = {leftEQ: s._fftLeft.spectrum};
	                    // frequencyData = s._frequencyData;
	                }
	            }
	            
	            s._whileplaying(time, peakData, waveformLeft, waveformRight, eqData);

	          }

	        }/* else {

	          // sm2._wD('_onTimer: Warn for "'+s.id+'": '+(!s._a?'Could not find element. ':'')+(s.playState === 0?'playState bad, 0?':'playState = '+s.playState+', OK'));

	          return false;

	        }*/

	        return isNew;

	      }

	    };

	    this._get_html5_duration = function() {

	      var instanceOptions = s._iO,
	          // if audio object exists, use its duration - else, instance option duration (if provided - it's a hack, really, and should be retired) OR null
	          d = (s._a && s._a.duration ? s._a.duration*msecScale : (instanceOptions && instanceOptions.duration ? instanceOptions.duration : null)),
	          result = (d && !isNaN(d) && d !== Infinity ? d : null);

	      return result;

	    };

	    this._apply_loop = function(a, nLoops) {

	      /**
	       * boolean instead of "loop", for webkit? - spec says string. http://www.w3.org/TR/html-markup/audio.html#audio.attrs.loop
	       * note that loop is either off or infinite under HTML5, unlike Flash which allows arbitrary loop counts to be specified.
	       */

	      // <d>
	      if (!a.loop && nLoops > 1) {
	        sm2._wD('Note: Native HTML5 looping is infinite.', 1);
	      }
	      // </d>

	      a.loop = (nLoops > 1 ? 'loop' : '');

	    };

	    this._setup_html5 = function(oOptions) {

	      var instanceOptions = mixin(s._iO, oOptions),
	          a = useGlobalHTML5Audio ? globalHTML5Audio : s._a,
	          dURL = decodeURI(instanceOptions.url),
	          sameURL;

	      /**
	       * "First things first, I, Poppa..." (reset the previous state of the old sound, if playing)
	       * Fixes case with devices that can only play one sound at a time
	       * Otherwise, other sounds in mid-play will be terminated without warning and in a stuck state
	       */

	      if (useGlobalHTML5Audio) {

	        if (dURL === decodeURI(lastGlobalHTML5URL)) {
	          // global HTML5 audio: re-use of URL
	          sameURL = true;
	        }

	      } else if (dURL === decodeURI(lastURL)) {

	        // options URL is the same as the "last" URL, and we used (loaded) it
	        sameURL = true;

	      }

	      if (a) {

	        if (a._s) {

	          if (useGlobalHTML5Audio) {

	            if (a._s && a._s.playState && !sameURL) {

	              // global HTML5 audio case, and loading a new URL. stop the currently-playing one.
	              a._s.stop();

	            }

	          } else if (!useGlobalHTML5Audio && dURL === decodeURI(lastURL)) {

	            // non-global HTML5 reuse case: same url, ignore request
	            s._apply_loop(a, instanceOptions.loops);

	            return a;

	          }

	        }

	        if (!sameURL) {

	          // don't retain onPosition() stuff with new URLs.

	          if (lastURL) {
	            resetProperties(false);
	          }

	          // assign new HTML5 URL

	          a.src = instanceOptions.url;

	          s.url = instanceOptions.url;

	          lastURL = instanceOptions.url;

	          lastGlobalHTML5URL = instanceOptions.url;

	          a._called_load = false;

	        }

	      } else {

	        if (instanceOptions.autoLoad || instanceOptions.autoPlay) {

	          s._a = new Audio(instanceOptions.url);
	          s._a.load();

	        } else {

	          // null for stupid Opera 9.64 case
	          s._a = (isOpera && opera.version() < 10 ? new Audio(null) : new Audio());

	        }

	        // assign local reference
	        a = s._a;

	        a._called_load = false;

	        if (useGlobalHTML5Audio) {

	          globalHTML5Audio = a;

	        }

	      }

	      s.isHTML5 = true;

	      if(dsp.FFT && Float32Array){
	        //Use html5 for spectrum/waveform (dsp.js must be available)
	        var contextClass =(window.AudioContext || 
	          window.webkitAudioContext || 
	          window.mozAudioContext || 
	          window.oAudioContext || 
	          window.msAudioContext);

	        if(window.AudioProcessingEvent && contextClass){
	            //Webkit and WebAudio API
	          
	            if(!mobileHTML5) {
	                s._useAdvancedHTML5 = true;
	            }

	            if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
	              s._useMoz = true;
	            }

	            if(!s._audioContext) {
	              if(window.ToneDen && window.ToneDen.audioContext) {
	                s._audioContext = window.ToneDen.audioContext;
	              } else {
	                s._audioContext = new contextClass();
	                window.ToneDen.audioContext = s._audioContext;
	              }
	            }

	            sm2._wD(s.id + ': Using HTML5 Audio for eqData and waveform');
	        } else if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
	            //Mozilla Firefox
	            sm2._wD(s.id + ': Using Mozilla Audio for eqData and waveform');
	            s._useAdvancedHTML5 = true;
	            s._useMoz = true;
	        }
	      }

	      // store a ref on the track
	      s._a = a;

	      // store a ref on the audio
	      a._s = s;

	      add_html5_events();

	      s._apply_loop(a, instanceOptions.loops);

	      if (instanceOptions.autoLoad || instanceOptions.autoPlay) {

	        s.load();

	      } else {

	        // early HTML5 implementation (non-standard)
	        a.autobuffer = false;

	        // standard ('none' is also an option.)
	        a.preload = 'auto';

	      }

	      return a;

	    };

	    add_html5_events = function() {

	      if (s._a._added_events) {
	        return false;
	      }

	      var f;

	      function add(oEvt, oFn, bCapture) {
	        return s._a ? s._a.addEventListener(oEvt, oFn, bCapture||false) : null;
	      }

	      s._a._added_events = true;

	      for (f in html5_events) {
	        if (html5_events.hasOwnProperty(f)) {
	          add(f, html5_events[f]);
	        }
	      }

	      return true;

	    };

	    remove_html5_events = function() {

	      // Remove event listeners

	      var f;

	      function remove(oEvt, oFn, bCapture) {
	        return (s._a ? s._a.removeEventListener(oEvt, oFn, bCapture||false) : null);
	      }

	      sm2._wD(s.id + ': Removing event listeners');
	      s._a._added_events = false;

	      for (f in html5_events) {
	        if (html5_events.hasOwnProperty(f)) {
	          remove(f, html5_events[f]);
	        }
	      }

	    };

	    /**
	     * Pseudo-private event internals
	     * ------------------------------
	     */

	    this._onload = function(nSuccess) {

	      var fN,
	          // check for duration to prevent false positives from flash 8 when loading from cache.
	          loadOK = !!nSuccess || (!s.isHTML5 && fV === 8 && s.duration);

	      // <d>
	      fN = s.id + ': ';
	      sm2._wD(fN + (loadOK ? 'onload()' : 'Failed to load / invalid sound?' + (!s.duration ? ' Zero-length duration reported.' : ' -') + ' (' + s.url + ')'), (loadOK ? 1 : 2));
	      if (!loadOK && !s.isHTML5) {
	        if (sm2.sandbox.noRemote === true) {
	          sm2._wD(fN + str('noNet'), 1);
	        }
	        if (sm2.sandbox.noLocal === true) {
	          sm2._wD(fN + str('noLocal'), 1);
	        }
	      }
	      // </d>

	      s.loaded = loadOK;
	      s.readyState = loadOK?3:2;
	      s._onbufferchange(0);

	      if (s._iO.onload) {
	        wrapCallback(s, function() {
	          s._iO.onload.apply(s, [loadOK]);
	        });
	      }

	      return true;

	    };

	    this._onbufferchange = function(nIsBuffering) {

	      if (s.playState === 0) {
	        // ignore if not playing
	        return false;
	      }

	      if ((nIsBuffering && s.isBuffering) || (!nIsBuffering && !s.isBuffering)) {
	        return false;
	      }

	      s.isBuffering = (nIsBuffering === 1);
	      if (s._iO.onbufferchange) {
	        sm2._wD(s.id + ': Buffer state change: ' + nIsBuffering);
	        s._iO.onbufferchange.apply(s);
	      }

	      return true;

	    };

	    /**
	     * Playback may have stopped due to buffering, or related reason.
	     * This state can be encountered on iOS < 6 when auto-play is blocked.
	     */

	    this._onsuspend = function() {

	      if (s._iO.onsuspend) {
	        sm2._wD(s.id + ': Playback suspended');
	        s._iO.onsuspend.apply(s);
	      }

	      return true;

	    };

	    /**
	     * flash 9/movieStar + RTMP-only method, should fire only once at most
	     * at this point we just recreate failed sounds rather than trying to reconnect
	     */

	    this._onfailure = function(msg, level, code) {

	      s.failures++;
	      sm2._wD(s.id + ': Failures = ' + s.failures);

	      if (s._iO.onfailure && s.failures === 1) {
	        s._iO.onfailure(s, msg, level, code);
	      } else {
	        sm2._wD(s.id + ': Ignoring failure');
	      }

	    };

	    this._onfinish = function() {

	      // store local copy before it gets trashed...
	      var io_onfinish = s._iO.onfinish;

	      s._onbufferchange(0);
	      s._resetOnPosition(0);

	      // reset some state items
	      if (s.instanceCount) {

	        s.instanceCount--;

	        if (!s.instanceCount) {

	          // remove onPosition listeners, if any
	          detachOnPosition();

	          // reset instance options
	          s.playState = 0;
	          s.paused = false;
	          s.instanceCount = 0;
	          s.instanceOptions = {};
	          s._iO = {};
	          stop_html5_timer();

	          // reset position, too
	          if (s.isHTML5) {
	            s.position = 0;
	          }

	        }

	        if (!s.instanceCount || s._iO.multiShotEvents) {
	          // fire onfinish for last, or every instance
	          if (io_onfinish) {
	            sm2._wD(s.id + ': onfinish()');
	            wrapCallback(s, function() {
	              io_onfinish.apply(s);
	            });
	          }
	        }

	      }

	    };

	    this._whileloading = function(nBytesLoaded, nBytesTotal, nDuration, nBufferLength) {

	      var instanceOptions = s._iO;

	      s.bytesLoaded = nBytesLoaded;
	      s.bytesTotal = nBytesTotal;
	      s.duration = Math.floor(nDuration);
	      s.bufferLength = nBufferLength;

	      if (!s.isHTML5 && !instanceOptions.isMovieStar) {

	        if (instanceOptions.duration) {
	          // use duration from options, if specified and larger. nobody should be specifying duration in options, actually, and it should be retired.
	          s.durationEstimate = (s.duration > instanceOptions.duration) ? s.duration : instanceOptions.duration;
	        } else {
	          s.durationEstimate = parseInt((s.bytesTotal / s.bytesLoaded) * s.duration, 10);
	        }

	      } else {

	        s.durationEstimate = s.duration;

	      }

	      // for flash, reflect sequential-load-style buffering
	      if (!s.isHTML5) {
	        s.buffered = [{
	          'start': 0,
	          'end': s.duration
	        }];
	      }

	      // allow whileloading to fire even if "load" fired under HTML5, due to HTTP range/partials
	      if ((s.readyState !== 3 || s.isHTML5) && instanceOptions.whileloading) {
	        instanceOptions.whileloading.apply(s);
	      }

	    };

	    this._whileplaying = function(nPosition, oPeakData, oWaveformDataLeft, oWaveformDataRight, oEQData) {

	      var instanceOptions = s._iO,
	          // eqLeft;
	          eqLeft, eqRight;

	      if (isNaN(nPosition) || nPosition === null) {
	        // flash safety net
	        return false;
	      }

	      // Safari HTML5 play() may return small -ve values when starting from position: 0, eg. -50.120396875. Unexpected/invalid per W3, I think. Normalize to 0.
	      s.position = Math.max(0, nPosition);

	      s._processOnPosition();

	      if (!s.isHTML5 && fV > 8 || s._useAdvancedHTML5) {

	        if (instanceOptions.usePeakData && oPeakData !== _undefined && oPeakData) {
	          s.peakData = {
	            left: oPeakData.leftPeak,
	            right: oPeakData.rightPeak
	          };
	        }

	        if (instanceOptions.useWaveformData && oWaveformDataLeft !== _undefined && oWaveformDataLeft) {
	          // s.waveformData = {
	          //   left: oWaveformDataLeft.split(','),
	          //   right: oWaveformDataRight.split(',')
	          // };
	          if(typeof(oWaveformDataLeft) == 'string'){
	            s.waveformData = {
	              left: oWaveformDataLeft.split(','),
	              right: oWaveformDataRight.split(',')
	            };
	          } else {
	            s.waveformData = {
	              left: oWaveformDataLeft,
	              right: oWaveformDataRight
	            };
	          }
	        }

	        if (instanceOptions.useEQData) {
	          if (oEQData !== _undefined && oEQData && oEQData.leftEQ) {
	            // eqLeft = oEQData.leftEQ;
	            // s.eqData = eqLeft;
	            // s.eqData.left = eqLeft;
	            // if (oEQData.rightEQ !== _undefined && oEQData.rightEQ) {
	            //   s.eqData.right = oEQData.rightEQ.split(',');
	            if(typeof(oEQData.leftEQ) == 'string'){
	              eqLeft = oEQData.leftEQ.split(',');
	            } else {
	              eqLeft = oEQData.leftEQ;
	              eqRight = eqLeft;
	            }
	          }

	          if (oEQData.rightEQ !== _undefined && oEQData.rightEQ) {
	            if(typeof(oEQData.rightEQ) == 'string'){
	              eqRight = oEQData.rightEQ.split(',');
	            } else {
	              eqRight = oEQData.rightEQ;
	            }
	          }

	          s.eqData = {};
	          s.frequencyData = {};
	          s.eqData.left = eqLeft;
	          s.eqData.right= eqRight;
	        }

	      }

	      if (s.playState === 1) {

	        // special case/hack: ensure buffering is false if loading from cache (and not yet started)
	        if (!s.isHTML5 && fV === 8 && !s.position && s.isBuffering) {
	          s._onbufferchange(0);
	        }

	        if (instanceOptions.whileplaying) {
	          // flash may call after actual finish
	          instanceOptions.whileplaying.apply(s);
	        }

	      }

	      return true;

	    };

	    this._oncaptiondata = function(oData) {

	      /**
	       * internal: flash 9 + NetStream (MovieStar/RTMP-only) feature
	       *
	       * @param {object} oData
	       */

	      sm2._wD(s.id + ': Caption data received.');

	      s.captiondata = oData;

	      if (s._iO.oncaptiondata) {
	        s._iO.oncaptiondata.apply(s, [oData]);
	      }

	    };

	    this._onmetadata = function(oMDProps, oMDData) {

	      /**
	       * internal: flash 9 + NetStream (MovieStar/RTMP-only) feature
	       * RTMP may include song title, MovieStar content may include encoding info
	       *
	       * @param {array} oMDProps (names)
	       * @param {array} oMDData (values)
	       */

	      sm2._wD(s.id + ': Metadata received.');

	      var oData = {}, i, j;

	      for (i = 0, j = oMDProps.length; i < j; i++) {
	        oData[oMDProps[i]] = oMDData[i];
	      }
	      s.metadata = oData;

	      if (s._iO.onmetadata) {
	        s._iO.onmetadata.apply(s);
	      }

	    };

	    this._onid3 = function(oID3Props, oID3Data) {

	      /**
	       * internal: flash 8 + flash 9 ID3 feature
	       * may include artist, song title etc.
	       *
	       * @param {array} oID3Props (names)
	       * @param {array} oID3Data (values)
	       */

	      sm2._wD(s.id + ': ID3 data received.');

	      var oData = [], i, j;

	      for (i = 0, j = oID3Props.length; i < j; i++) {
	        oData[oID3Props[i]] = oID3Data[i];
	      }
	      s.id3 = mixin(s.id3, oData);

	      if (s._iO.onid3) {
	        s._iO.onid3.apply(s);
	      }

	    };

	    // flash/RTMP-only

	    this._onconnect = function(bSuccess) {

	      bSuccess = (bSuccess === 1);
	      sm2._wD(s.id + ': ' + (bSuccess ? 'Connected.' : 'Failed to connect? - ' + s.url), (bSuccess ? 1 : 2));
	      s.connected = bSuccess;

	      if (bSuccess) {

	        s.failures = 0;

	        if (idCheck(s.id)) {
	          if (s.getAutoPlay()) {
	            // only update the play state if auto playing
	            s.play(_undefined, s.getAutoPlay());
	          } else if (s._iO.autoLoad) {
	            s.load();
	          }
	        }

	        if (s._iO.onconnect) {
	          s._iO.onconnect.apply(s, [bSuccess]);
	        }

	      }

	    };

	    this._ondataerror = function(sError) {

	      // flash 9 wave/eq data handler
	      // hack: called at start, and end from flash at/after onfinish()
	      if (s.playState > 0) {
	        sm2._wD(s.id + ': Data error: ' + sError);
	        if (s._iO.ondataerror) {
	          s._iO.ondataerror.apply(s);
	        }
	      }

	    };

	    // <d>
	    this._debug();
	    // </d>

	  }; // SMSound()

	  /**
	   * Private SoundManager internals
	   * ------------------------------
	   */

	  getDocument = function() {

	    return (doc.body || doc.getElementsByTagName('div')[0]);

	  };

	  id = function(sID) {

	    return doc.getElementById(sID);

	  };

	  mixin = function(oMain, oAdd) {

	    // non-destructive merge
	    var o1 = (oMain || {}), o2, o;

	    // if unspecified, o2 is the default options object
	    o2 = (oAdd === _undefined ? sm2.defaultOptions : oAdd);

	    for (o in o2) {

	      if (o2.hasOwnProperty(o) && o1[o] === _undefined) {

	        if (typeof o2[o] !== 'object' || o2[o] === null) {

	          // assign directly
	          o1[o] = o2[o];

	        } else {

	          // recurse through o2
	          o1[o] = mixin(o1[o], o2[o]);

	        }

	      }

	    }

	    return o1;

	  };

	  wrapCallback = function(oSound, callback) {

	    /**
	     * 03/03/2013: Fix for Flash Player 11.6.602.171 + Flash 8 (flashVersion = 8) SWF issue
	     * setTimeout() fix for certain SMSound callbacks like onload() and onfinish(), where subsequent calls like play() and load() fail when Flash Player 11.6.602.171 is installed, and using soundManager with flashVersion = 8 (which is the default).
	     * Not sure of exact cause. Suspect race condition and/or invalid (NaN-style) position argument trickling down to the next JS -> Flash _start() call, in the play() case.
	     * Fix: setTimeout() to yield, plus safer null / NaN checking on position argument provided to Flash.
	     * https://getsatisfaction.com/schillmania/topics/recent_chrome_update_seems_to_have_broken_my_sm2_audio_player
	     */
	    if (!oSound.isHTML5 && fV === 8) {
	      window.setTimeout(callback, 0);
	    } else {
	      callback();
	    }

	  };

	  // additional soundManager properties that soundManager.setup() will accept

	  extraOptions = {
	    'onready': 1,
	    'ontimeout': 1,
	    'defaultOptions': 1,
	    'flash9Options': 1,
	    'movieStarOptions': 1
	  };

	  assign = function(o, oParent) {

	    /**
	     * recursive assignment of properties, soundManager.setup() helper
	     * allows property assignment based on whitelist
	     */

	    var i,
	        result = true,
	        hasParent = (oParent !== _undefined),
	        setupOptions = sm2.setupOptions,
	        bonusOptions = extraOptions;

	    // <d>

	    // if soundManager.setup() called, show accepted parameters.

	    if (o === _undefined) {

	      result = [];

	      for (i in setupOptions) {

	        if (setupOptions.hasOwnProperty(i)) {
	          result.push(i);
	        }

	      }

	      for (i in bonusOptions) {

	        if (bonusOptions.hasOwnProperty(i)) {

	          if (typeof sm2[i] === 'object') {

	            result.push(i+': {...}');

	          } else if (sm2[i] instanceof Function) {

	            result.push(i+': function() {...}');

	          } else {

	            result.push(i);

	          }

	        }

	      }

	      sm2._wD(str('setup', result.join(', ')));

	      return false;

	    }

	    // </d>

	    for (i in o) {

	      if (o.hasOwnProperty(i)) {

	        // if not an {object} we want to recurse through...

	        if (typeof o[i] !== 'object' || o[i] === null || o[i] instanceof Array || o[i] instanceof RegExp) {

	          // check "allowed" options

	          if (hasParent && bonusOptions[oParent] !== _undefined) {

	            // valid recursive / nested object option, eg., { defaultOptions: { volume: 50 } }
	            sm2[oParent][i] = o[i];

	          } else if (setupOptions[i] !== _undefined) {

	            // special case: assign to setupOptions object, which soundManager property references
	            sm2.setupOptions[i] = o[i];

	            // assign directly to soundManager, too
	            sm2[i] = o[i];

	          } else if (bonusOptions[i] === _undefined) {

	            // invalid or disallowed parameter. complain.
	            complain(str((sm2[i] === _undefined ? 'setupUndef' : 'setupError'), i), 2);

	            result = false;

	          } else {

	            /**
	             * valid extraOptions (bonusOptions) parameter.
	             * is it a method, like onready/ontimeout? call it.
	             * multiple parameters should be in an array, eg. soundManager.setup({onready: [myHandler, myScope]});
	             */

	            if (sm2[i] instanceof Function) {

	              sm2[i].apply(sm2, (o[i] instanceof Array? o[i] : [o[i]]));

	            } else {

	              // good old-fashioned direct assignment
	              sm2[i] = o[i];

	            }

	          }

	        } else {

	          // recursion case, eg., { defaultOptions: { ... } }

	          if (bonusOptions[i] === _undefined) {

	            // invalid or disallowed parameter. complain.
	            complain(str((sm2[i] === _undefined ? 'setupUndef' : 'setupError'), i), 2);

	            result = false;

	          } else {

	            // recurse through object
	            return assign(o[i], i);

	          }

	        }

	      }

	    }

	    return result;

	  };

	  function preferFlashCheck(kind) {

	    // whether flash should play a given type
	    return (sm2.preferFlash && hasFlash && !sm2.ignoreFlash && (sm2.flash[kind] !== _undefined && sm2.flash[kind]));

	  }

	  /**
	   * Internal DOM2-level event helpers
	   * ---------------------------------
	   */

	  event = (function() {

	    // normalize event methods
	    var old = (window.attachEvent),
	    evt = {
	      add: (old?'attachEvent':'addEventListener'),
	      remove: (old?'detachEvent':'removeEventListener')
	    };

	    // normalize "on" event prefix, optional capture argument
	    function getArgs(oArgs) {

	      var args = slice.call(oArgs),
	          len = args.length;

	      if (old) {
	        // prefix
	        args[1] = 'on' + args[1];
	        if (len > 3) {
	          // no capture
	          args.pop();
	        }
	      } else if (len === 3) {
	        args.push(false);
	      }

	      return args;

	    }

	    function apply(args, sType) {

	      // normalize and call the event method, with the proper arguments
	      var element = args.shift(),
	          method = [evt[sType]];

	      if (old) {
	        // old IE can't do apply().
	        element[method](args[0], args[1]);
	      } else {
	        element[method].apply(element, args);
	      }

	    }

	    function add() {

	      apply(getArgs(arguments), 'add');

	    }

	    function remove() {

	      apply(getArgs(arguments), 'remove');

	    }

	    return {
	      'add': add,
	      'remove': remove
	    };

	  }());

	  /**
	   * Internal HTML5 event handling
	   * -----------------------------
	   */

	  function html5_event(oFn) {

	    // wrap html5 event handlers so we don't call them on destroyed and/or unloaded sounds

	    return function(e) {

	      var s = this._s,
	          result;

	      if (!s || !s._a) {
	        // <d>
	        if (s && s.id) {
	          sm2._wD(s.id + ': Ignoring ' + e.type);
	        } else {
	          sm2._wD(h5 + 'Ignoring ' + e.type);
	        }
	        // </d>
	        result = null;
	      } else {
	        result = oFn.call(this, e);
	      }

	      return result;

	    };

	  }

	  html5_events = {

	    // HTML5 event-name-to-handler map

	    abort: html5_event(function() {

	      sm2._wD(this._s.id + ': abort');

	    }),

	    // enough has loaded to play

	    canplay: html5_event(function(e) {

	      var s = this._s,
	          position1K;

	      if (s._html5_canplay) {
	        // this event has already fired. ignore.
	        return true;
	      }

	      s._html5_canplay = true;
	      sm2._wD(s.id + ': canplay');
	      s._onbufferchange(0);

	      // position according to instance options
	      position1K = (s._iO.position !== _undefined && !isNaN(s._iO.position)?s._iO.position/msecScale:null);

	      // set the position if position was set before the sound loaded
	      if (s.position && this.currentTime !== position1K) {
	        sm2._wD(s.id + ': canplay: Setting position to ' + position1K);
	        try {
	          this.currentTime = position1K;
	        } catch(ee) {
	          sm2._wD(s.id + ': canplay: Setting position of ' + position1K + ' failed: ' + ee.message, 2);
	        }
	      }

	      // hack for HTML5 from/to case
	      if (s._iO._oncanplay) {
	        s._iO._oncanplay();
	      }

	      s._useAdvancedHTML5 = false;
	    }),

	    canplaythrough: html5_event(function() {

	      var s = this._s;

	      sm2._wD(s.id + ': canplaythrough');

	      // Hack to stop the network request from continuing forever.
	      if(s.playState !== 1) {
	          s._a.volume = 0;
	          s._a.play();
	          s._a.pause();
	          s._a.volume = 1;
	      }

	      if (!s.loaded) {
	        s._onbufferchange(0);
	        s._whileloading(s.bytesLoaded, s.bytesTotal, s._get_html5_duration());
	        s._onload(true);
	      }
	    }),

	    // TODO: Reserved for potential use
	    /*
	    emptied: html5_event(function() {

	      sm2._wD(this._s.id + ': emptied');

	    }),
	    */

	    ended: html5_event(function() {

	      var s = this._s;

	      sm2._wD(s.id + ': ended');

	      s._onfinish();

	    }),

	    error: html5_event(function() {

	      sm2._wD(this._s.id + ': HTML5 error, code ' + this.error.code);
	      /**
	       * HTML5 error codes, per W3C
	       * Error 1: Client aborted download at user's request.
	       * Error 2: Network error after load started.
	       * Error 3: Decoding issue.
	       * Error 4: Media (audio file) not supported.
	       * Reference: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#error-codes
	       */
	      // call load with error state?
	      this._s._onload(false);

	    }),

	    loadeddata: html5_event(function() {

	      var s = this._s;

	      sm2._wD(s.id + ': loadeddata');

	      // safari seems to nicely report progress events, eventually totalling 100%
	      if (!s._loaded && !isSafari) {
	        s.duration = s._get_html5_duration();
	      }

	    }),

	    loadedmetadata: html5_event(function() {

	      sm2._wD(this._s.id + ': loadedmetadata');

	    }),

	    loadstart: html5_event(function() {

	      sm2._wD(this._s.id + ': loadstart');
	      // assume buffering at first
	      this._s._onbufferchange(1);

	    }),

	    play: html5_event(function() {

	      // sm2._wD(this._s.id + ': play()');
	      // once play starts, no buffering
	      this._s._onbufferchange(0);
	    }),

	    playing: html5_event(function() {

	      sm2._wD(this._s.id + ': playing');
	      // once play starts, no buffering
	      this._s._onbufferchange(0);

	    }),

	    progress: html5_event(function(e) {

	      // note: can fire repeatedly after "loaded" event, due to use of HTTP range/partials

	      var s = this._s,
	          i, j, progStr, buffered = 0,
	          isProgress = (e.type === 'progress'),
	          ranges = e.target.buffered,
	          // firefox 3.6 implements e.loaded/total (bytes)
	          loaded = (e.loaded||0),
	          total = (e.total||1);

	      // reset the "buffered" (loaded byte ranges) array
	      s.buffered = [];

	      if (ranges && ranges.length) {

	        // if loaded is 0, try TimeRanges implementation as % of load
	        // https://developer.mozilla.org/en/DOM/TimeRanges

	        // re-build "buffered" array
	        // HTML5 returns seconds. SM2 API uses msec for setPosition() etc., whether Flash or HTML5.
	        for (i=0, j=ranges.length; i<j; i++) {
	          s.buffered.push({
	            'start': ranges.start(i) * msecScale,
	            'end': ranges.end(i) * msecScale
	          });
	        }

	        // use the last value locally
	        buffered = (ranges.end(0) - ranges.start(0)) * msecScale;

	        // linear case, buffer sum; does not account for seeking and HTTP partials / byte ranges
	        loaded = Math.min(1, buffered/(e.target.duration*msecScale));

	        // <d>
	        if (isProgress && ranges.length > 1) {
	          progStr = [];
	          j = ranges.length;
	          for (i=0; i<j; i++) {
	            progStr.push(e.target.buffered.start(i)*msecScale +'-'+ e.target.buffered.end(i)*msecScale);
	          }
	          //sm2._wD(this._s.id + ': progress, timeRanges: ' + progStr.join(', '));
	        }

	        if (isProgress && !isNaN(loaded)) {
	          //sm2._wD(this._s.id + ': progress, ' + Math.floor(loaded*100) + '% loaded');
	        }
	        // </d>

	      }

	      if (!isNaN(loaded)) {

	        // if progress, likely not buffering
	        s._onbufferchange(0);
	        // TODO: prevent calls with duplicate values.
	        s._whileloading(loaded, total, s._get_html5_duration());
	        if (loaded && total && loaded === total) {
	          // in case "onload" doesn't fire (eg. gecko 1.9.2)
	          html5_events.canplaythrough.call(this, e);
	        }

	      }

	    }),

	    ratechange: html5_event(function() {

	      sm2._wD(this._s.id + ': ratechange');

	    }),

	    suspend: html5_event(function(e) {

	      // download paused/stopped, may have finished (eg. onload)
	      var s = this._s;

	      sm2._wD(this._s.id + ': suspend');
	      html5_events.progress.call(this, e);
	      s._onsuspend();

	    }),

	    stalled: html5_event(function() {

	      sm2._wD(this._s.id + ': stalled');

	    }),

	    timeupdate: html5_event(function() {

	      var s = this._s;
	      if(s._useAdvancedHTML5) return;
	      this._s._onTimer();

	    }),

	    waiting: html5_event(function() {

	      var s = this._s;

	      // see also: seeking
	      sm2._wD(this._s.id + ': waiting');

	      // playback faster than download rate, etc.
	      s._onbufferchange(1);

	    }),

	    // only for firefox
	    MozAudioAvailable: html5_event(function(e) {
	      var s = this._s;
	      if(!s._useAdvancedHTML5 || !s._useMoz) return;
	      if(s._channels < 2){
	        s._waveformLeft = e.frameBuffer;
	        s._waveformRight = e.frameBuffer;
	      } else {
	        var per_channel = s._fbLength / s._channels;
	        for ( var i = 0; i < per_channel; i++ ) {
	          s._waveformLeft[i] = e.frameBuffer[i * s._channels];
	          s._waveformRight[i] = e.frameBuffer[i * s._channels + 1];
	        } 
	      }
	      s._fftLeft.forward( s._waveformLeft );
	      if(s._channels > 1){
	        s._fftRight.forward( s._waveformRight );
	      }
	      s._onTimer(true);
	    })

	  };

	  html5OK = function(iO) {

	    // playability test based on URL or MIME type

	    var result;

	    if (!iO || (!iO.type && !iO.url && !iO.serverURL)) {

	      // nothing to check
	      result = false;

	    } else if (iO.serverURL || (iO.type && preferFlashCheck(iO.type))) {

	      // RTMP, or preferring flash
	      result = false;

	    } else {

	      // Use type, if specified. Pass data: URIs to HTML5. If HTML5-only mode, no other options, so just give 'er
	      result = ((iO.type ? html5CanPlay({type:iO.type}) : html5CanPlay({url:iO.url}) || sm2.html5Only || iO.url.match(/data\:/i)));

	    }

	    return result;

	  };

	  html5Unload = function(oAudio) {

	    /**
	     * Internal method: Unload media, and cancel any current/pending network requests.
	     * Firefox can load an empty URL, which allegedly destroys the decoder and stops the download.
	     * https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox#Stopping_the_download_of_media
	     * However, Firefox has been seen loading a relative URL from '' and thus requesting the hosting page on unload.
	     * Other UA behaviour is unclear, so everyone else gets an about:blank-style URL.
	     */

	    var url;

	    if (oAudio) {

	      // Firefox and Chrome accept short WAVe data: URIs. Chome dislikes audio/wav, but accepts audio/wav for data: MIME.
	      // Desktop Safari complains / fails on data: URI, so it gets about:blank.
	      url = (isSafari ? emptyURL : (sm2.html5.canPlayType('audio/wav') ? emptyWAV : emptyURL));

	      oAudio.src = url;

	      // reset some state, too
	      if (oAudio._called_unload !== undefined) {
	        oAudio._called_load = false;
	      }

	      oAudio.remove();
	    }

	    if (useGlobalHTML5Audio) {

	      // ensure URL state is trashed, also
	      lastGlobalHTML5URL = null;

	    }

	    return url;

	  };

	  html5CanPlay = function(o) {

	    /**
	     * Try to find MIME, test and return truthiness
	     * o = {
	     *  url: '/path/to/an.mp3',
	     *  type: 'audio/mp3'
	     * }
	     */

	    if (!sm2.useHTML5Audio || !sm2.hasHTML5) {
	      return false;
	    }

	    var url = (o.url || null),
	        mime = (o.type || null),
	        aF = sm2.audioFormats,
	        result,
	        offset,
	        fileExt,
	        item;

	    // account for known cases like audio/mp3

	    if (mime && sm2.html5[mime] !== _undefined) {
	      return (sm2.html5[mime] && !preferFlashCheck(mime));
	    }

	    if (!html5Ext) {
	      html5Ext = [];
	      for (item in aF) {
	        if (aF.hasOwnProperty(item)) {
	          html5Ext.push(item);
	          if (aF[item].related) {
	            html5Ext = html5Ext.concat(aF[item].related);
	          }
	        }
	      }
	      html5Ext = new RegExp('\\.('+html5Ext.join('|')+')(\\?.*)?$','i');
	    }

	    // TODO: Strip URL queries, etc.
	    fileExt = (url ? url.toLowerCase().match(html5Ext) : null);

	    if (!fileExt || !fileExt.length) {
	      if (!mime) {
	        result = false;
	      } else {
	        // audio/mp3 -> mp3, result should be known
	        offset = mime.indexOf(';');
	        // strip "audio/X; codecs..."
	        fileExt = (offset !== -1?mime.substr(0,offset):mime).substr(6);
	      }
	    } else {
	      // match the raw extension name - "mp3", for example
	      fileExt = fileExt[1];
	    }

	    if (fileExt && sm2.html5[fileExt] !== _undefined) {
	      // result known
	      result = (sm2.html5[fileExt] && !preferFlashCheck(fileExt));
	    } else {
	      mime = 'audio/'+fileExt;
	      result = sm2.html5.canPlayType({type:mime});
	      sm2.html5[fileExt] = result;
	      // sm2._wD('canPlayType, found result: ' + result);
	      result = (result && sm2.html5[mime] && !preferFlashCheck(mime));
	    }

	    return result;

	  };

	  testHTML5 = function() {

	    /**
	     * Internal: Iterates over audioFormats, determining support eg. audio/mp3, audio/mpeg and so on
	     * assigns results to html5[] and flash[].
	     */

	    if (!sm2.useHTML5Audio || !sm2.hasHTML5) {
	      // without HTML5, we need Flash.
	      sm2.html5.usingFlash = true;
	      needsFlash = true;
	      return false;
	    }

	    // double-whammy: Opera 9.64 throws WRONG_ARGUMENTS_ERR if no parameter passed to Audio(), and Webkit + iOS happily tries to load "null" as a URL. :/
	    var a = (Audio !== _undefined ? (isOpera && opera.version() < 10 ? new Audio(null) : new Audio()) : null),
	        item, lookup, support = {}, aF, i;

	    function cp(m) {

	      var canPlay, j,
	          result = false,
	          isOK = false;

	      if (!a || typeof a.canPlayType !== 'function') {
	        return result;
	      }

	      if (m instanceof Array) {
	        // iterate through all mime types, return any successes
	        for (i=0, j=m.length; i<j; i++) {
	          if (sm2.html5[m[i]] || a.canPlayType(m[i]).match(sm2.html5Test)) {
	            isOK = true;
	            sm2.html5[m[i]] = true;
	            // note flash support, too
	            sm2.flash[m[i]] = !!(m[i].match(flashMIME));
	          }
	        }
	        result = isOK;
	      } else {
	        canPlay = (a && typeof a.canPlayType === 'function' ? a.canPlayType(m) : false);
	        result = !!(canPlay && (canPlay.match(sm2.html5Test)));
	      }

	      return result;

	    }

	    // test all registered formats + codecs

	    aF = sm2.audioFormats;

	    for (item in aF) {

	      if (aF.hasOwnProperty(item)) {

	        lookup = 'audio/' + item;

	        support[item] = cp(aF[item].type);

	        // write back generic type too, eg. audio/mp3
	        support[lookup] = support[item];

	        // assign flash
	        if (item.match(flashMIME)) {

	          sm2.flash[item] = true;
	          sm2.flash[lookup] = true;

	        } else {

	          sm2.flash[item] = false;
	          sm2.flash[lookup] = false;

	        }

	        // assign result to related formats, too

	        if (aF[item] && aF[item].related) {

	          for (i=aF[item].related.length-1; i >= 0; i--) {

	            // eg. audio/m4a
	            support['audio/'+aF[item].related[i]] = support[item];
	            sm2.html5[aF[item].related[i]] = support[item];
	            sm2.flash[aF[item].related[i]] = support[item];

	          }

	        }

	      }

	    }

	    support.canPlayType = (a?cp:null);
	    sm2.html5 = mixin(sm2.html5, support);

	    sm2.html5.usingFlash = featureCheck();
	    needsFlash = sm2.html5.usingFlash;

	    return true;

	  };

	  strings = {

	    // <d>
	    notReady: 'Unavailable - wait until onready() has fired.',
	    notOK: 'Audio support is not available.',
	    domError: sm + 'exception caught while appending SWF to DOM.',
	    spcWmode: 'Removing wmode, preventing known SWF loading issue(s)',
	    swf404: smc + 'Verify that %s is a valid path.',
	    tryDebug: 'Try ' + sm + '.debugFlash = true for more security details (output goes to SWF.)',
	    checkSWF: 'See SWF output for more debug info.',
	    localFail: smc + 'Non-HTTP page (' + doc.location.protocol + ' URL?) Review Flash player security settings for this special case:\nhttp://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html\nMay need to add/allow path, eg. c:/sm2/ or /users/me/sm2/',
	    waitFocus: smc + 'Special case: Waiting for SWF to load with window focus...',
	    waitForever: smc + 'Waiting indefinitely for Flash (will recover if unblocked)...',
	    waitSWF: smc + 'Waiting for 100% SWF load...',
	    needFunction: smc + 'Function object expected for %s',
	    badID: 'Sound ID "%s" should be a string, starting with a non-numeric character',
	    currentObj: smc + '_debug(): Current sound objects',
	    waitOnload: smc + 'Waiting for window.onload()',
	    docLoaded: smc + 'Document already loaded',
	    onload: smc + 'initComplete(): calling soundManager.onload()',
	    onloadOK: sm + '.onload() complete',
	    didInit: smc + 'init(): Already called?',
	    secNote: 'Flash security note: Network/internet URLs will not load due to security restrictions. Access can be configured via Flash Player Global Security Settings Page: http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html',
	    badRemove: smc + 'Failed to remove Flash node.',
	    shutdown: sm + '.disable(): Shutting down',
	    queue: smc + 'Queueing %s handler',
	    smError: 'SMSound.load(): Exception: JS-Flash communication failed, or JS error.',
	    fbTimeout: 'No flash response, applying .'+swfCSS.swfTimedout+' CSS...',
	    fbLoaded: 'Flash loaded',
	    fbHandler: smc + 'flashBlockHandler()',
	    manURL: 'SMSound.load(): Using manually-assigned URL',
	    onURL: sm + '.load(): current URL already assigned.',
	    badFV: sm + '.flashVersion must be 8 or 9. "%s" is invalid. Reverting to %s.',
	    as2loop: 'Note: Setting stream:false so looping can work (flash 8 limitation)',
	    noNSLoop: 'Note: Looping not implemented for MovieStar formats',
	    needfl9: 'Note: Switching to flash 9, required for MP4 formats.',
	    mfTimeout: 'Setting flashLoadTimeout = 0 (infinite) for off-screen, mobile flash case',
	    needFlash: smc + 'Fatal error: Flash is needed to play some required formats, but is not available.',
	    gotFocus: smc + 'Got window focus.',
	    policy: 'Enabling usePolicyFile for data access',
	    setup: sm + '.setup(): allowed parameters: %s',
	    setupError: sm + '.setup(): "%s" cannot be assigned with this method.',
	    setupUndef: sm + '.setup(): Could not find option "%s"',
	    setupLate: sm + '.setup(): url, flashVersion and html5Test property changes will not take effect until reboot().',
	    noURL: smc + 'Flash URL required. Call soundManager.setup({url:...}) to get started.',
	    sm2Loaded: 'SoundManager 2: Ready.',
	    reset: sm + '.reset(): Removing event callbacks',
	    mobileUA: 'Mobile UA detected, preferring HTML5 by default.',
	    globalHTML5: '', //'Using singleton HTML5 Audio() pattern for this device.'
	    // </d>

	  };

	  str = function() {

	    // internal string replace helper.
	    // arguments: o [,items to replace]
	    // <d>

	    var args,
	        i, j, o,
	        sstr;

	    // real array, please
	    args = slice.call(arguments);

	    // first argument
	    o = args.shift();

	    sstr = (strings && strings[o] ? strings[o] : '');

	    if (sstr && args && args.length) {
	      for (i = 0, j = args.length; i < j; i++) {
	        sstr = sstr.replace('%s', args[i]);
	      }
	    }

	    return sstr;
	    // </d>

	  };

	  loopFix = function(sOpt) {

	    // flash 8 requires stream = false for looping to work
	    if (fV === 8 && sOpt.loops > 1 && sOpt.stream) {
	      _wDS('as2loop');
	      sOpt.stream = false;
	    }

	    return sOpt;

	  };

	  policyFix = function(sOpt, sPre) {

	    if (sOpt && !sOpt.usePolicyFile && (sOpt.onid3 || sOpt.usePeakData || sOpt.useWaveformData || sOpt.useEQData)) {
	      sm2._wD((sPre || '') + str('policy'));
	      sOpt.usePolicyFile = true;
	    }

	    return sOpt;

	  };

	  complain = function(sMsg) {

	    // <d>
	    if (hasConsole && console.warn !== _undefined) {
	      console.warn(sMsg);
	    } else {
	      sm2._wD(sMsg);
	    }
	    // </d>

	  };

	  doNothing = function() {

	    return false;

	  };

	  disableObject = function(o) {

	    var oProp;

	    for (oProp in o) {
	      if (o.hasOwnProperty(oProp) && typeof o[oProp] === 'function') {
	        o[oProp] = doNothing;
	      }
	    }

	    oProp = null;

	  };

	  failSafely = function(bNoDisable) {

	    // general failure exception handler

	    if (bNoDisable === _undefined) {
	      bNoDisable = false;
	    }

	    if (disabled || bNoDisable) {
	      sm2.disable(bNoDisable);
	    }

	  };

	  normalizeMovieURL = function(smURL) {

	    var urlParams = null, url;

	    if (smURL) {
	      if (smURL.match(/\.swf(\?.*)?$/i)) {
	        urlParams = smURL.substr(smURL.toLowerCase().lastIndexOf('.swf?') + 4);
	        if (urlParams) {
	          // assume user knows what they're doing
	          return smURL;
	        }
	      } else if (smURL.lastIndexOf('/') !== smURL.length - 1) {
	        // append trailing slash, if needed
	        smURL += '/';
	      }
	    }

	    url = (smURL && smURL.lastIndexOf('/') !== - 1 ? smURL.substr(0, smURL.lastIndexOf('/') + 1) : './') + sm2.movieURL;

	    if (sm2.noSWFCache) {
	      url += ('?ts=' + new Date().getTime());
	    }

	    return url;

	  };

	  setVersionInfo = function() {

	    // short-hand for internal use

	    fV = parseInt(sm2.flashVersion, 10);

	    if (fV !== 8 && fV !== 9) {
	      sm2._wD(str('badFV', fV, defaultFlashVersion));
	      sm2.flashVersion = fV = defaultFlashVersion;
	    }

	    // debug flash movie, if applicable

	    var isDebug = (sm2.debugMode || sm2.debugFlash?'_debug.swf':'.swf');

	    if (sm2.useHTML5Audio && !sm2.html5Only && sm2.audioFormats.mp4.required && fV < 9) {
	      sm2._wD(str('needfl9'));
	      sm2.flashVersion = fV = 9;
	    }

	    sm2.version = sm2.versionNumber + (sm2.html5Only?' (HTML5-only mode)':(fV === 9?' (AS3/Flash 9)':' (AS2/Flash 8)'));

	    // set up default options
	    if (fV > 8) {
	      // +flash 9 base options
	      sm2.defaultOptions = mixin(sm2.defaultOptions, sm2.flash9Options);
	      sm2.features.buffering = true;
	      // +moviestar support
	      sm2.defaultOptions = mixin(sm2.defaultOptions, sm2.movieStarOptions);
	      sm2.filePatterns.flash9 = new RegExp('\\.(mp3|' + netStreamTypes.join('|') + ')(\\?.*)?$', 'i');
	      sm2.features.movieStar = true;
	    } else {
	      sm2.features.movieStar = false;
	    }

	    // regExp for flash canPlay(), etc.
	    sm2.filePattern = sm2.filePatterns[(fV !== 8?'flash9':'flash8')];

	    // if applicable, use _debug versions of SWFs
	    sm2.movieURL = (fV === 8?'soundmanager2.swf':'soundmanager2_flash9.swf').replace('.swf', isDebug);

	    sm2.features.peakData = sm2.features.waveformData = sm2.features.eqData = (fV > 8);

	  };

	  setPolling = function(bPolling, bHighPerformance) {

	    if (!flash) {
	      return false;
	    }

	    flash._setPolling(bPolling, bHighPerformance);

	  };

	  initDebug = function() {

	    // starts debug mode, creating output <div> for UAs without console object

	    // allow force of debug mode via URL
	    // <d>
	    if (sm2.debugURLParam.test(wl)) {
	      sm2.debugMode = true;
	    }

	    if (id(sm2.debugID)) {
	      return false;
	    }

	    var oD, oDebug, oTarget, oToggle, tmp;

	    if (sm2.debugMode && !id(sm2.debugID) && (!hasConsole || !sm2.useConsole || !sm2.consoleOnly)) {

	      oD = doc.createElement('div');
	      oD.id = sm2.debugID + '-toggle';

	      oToggle = {
	        'position': 'fixed',
	        'bottom': '0px',
	        'right': '0px',
	        'width': '1.2em',
	        'height': '1.2em',
	        'lineHeight': '1.2em',
	        'margin': '2px',
	        'textAlign': 'center',
	        'border': '1px solid #999',
	        'cursor': 'pointer',
	        'background': '#fff',
	        'color': '#333',
	        'zIndex': 10001
	      };

	      oD.appendChild(doc.createTextNode('-'));
	      oD.onclick = toggleDebug;
	      oD.title = 'Toggle SM2 debug console';

	      if (ua.match(/msie 6/i)) {
	        oD.style.position = 'absolute';
	        oD.style.cursor = 'hand';
	      }

	      for (tmp in oToggle) {
	        if (oToggle.hasOwnProperty(tmp)) {
	          oD.style[tmp] = oToggle[tmp];
	        }
	      }

	      oDebug = doc.createElement('div');
	      oDebug.id = sm2.debugID;
	      oDebug.style.display = (sm2.debugMode?'block':'none');

	      if (sm2.debugMode && !id(oD.id)) {
	        try {
	          oTarget = getDocument();
	          oTarget.appendChild(oD);
	        } catch(e2) {
	          throw new Error(str('domError')+' \n'+e2.toString());
	        }
	        oTarget.appendChild(oDebug);
	      }

	    }

	    oTarget = null;
	    // </d>

	  };

	  idCheck = this.getSoundById;

	  // <d>
	  _wDS = function(o, errorLevel) {

	    return (!o ? '' : sm2._wD(str(o), errorLevel));

	  };

	  toggleDebug = function() {

	    var o = id(sm2.debugID),
	    oT = id(sm2.debugID + '-toggle');

	    if (!o) {
	      return false;
	    }

	    if (debugOpen) {
	      // minimize
	      oT.innerHTML = '+';
	      o.style.display = 'none';
	    } else {
	      oT.innerHTML = '-';
	      o.style.display = 'block';
	    }

	    debugOpen = !debugOpen;

	  };

	  debugTS = function(sEventType, bSuccess, sMessage) {

	    // troubleshooter debug hooks

	    if (window.sm2Debugger !== _undefined) {
	      try {
	        sm2Debugger.handleEvent(sEventType, bSuccess, sMessage);
	      } catch(e) {
	        // oh well
	        return false;
	      }
	    }

	    return true;

	  };
	  // </d>

	  getSWFCSS = function() {

	    var css = [];

	    if (sm2.debugMode) {
	      css.push(swfCSS.sm2Debug);
	    }

	    if (sm2.debugFlash) {
	      css.push(swfCSS.flashDebug);
	    }

	    if (sm2.useHighPerformance) {
	      css.push(swfCSS.highPerf);
	    }

	    return css.join(' ');

	  };

	  flashBlockHandler = function() {

	    // *possible* flash block situation.

	    var name = str('fbHandler'),
	        p = sm2.getMoviePercent(),
	        css = swfCSS,
	        error = {type:'FLASHBLOCK'};

	    if (sm2.html5Only) {
	      // no flash, or unused
	      return false;
	    }

	    if (!sm2.ok()) {

	      if (needsFlash) {
	        // make the movie more visible, so user can fix
	        sm2.oMC.className = getSWFCSS() + ' ' + css.swfDefault + ' ' + (p === null?css.swfTimedout:css.swfError);
	        sm2._wD(name + ': ' + str('fbTimeout') + (p ? ' (' + str('fbLoaded') + ')' : ''));
	      }

	      sm2.didFlashBlock = true;

	      // fire onready(), complain lightly
	      processOnEvents({type:'ontimeout', ignoreInit:true, error:error});
	      catchError(error);

	    } else {

	      // SM2 loaded OK (or recovered)

	      // <d>
	      if (sm2.didFlashBlock) {
	        sm2._wD(name + ': Unblocked');
	      }
	      // </d>

	      if (sm2.oMC) {
	        sm2.oMC.className = [getSWFCSS(), css.swfDefault, css.swfLoaded + (sm2.didFlashBlock?' '+css.swfUnblocked:'')].join(' ');
	      }

	    }

	  };

	  addOnEvent = function(sType, oMethod, oScope) {

	    if (on_queue[sType] === _undefined) {
	      on_queue[sType] = [];
	    }

	    on_queue[sType].push({
	      'method': oMethod,
	      'scope': (oScope || null),
	      'fired': false
	    });

	  };

	  processOnEvents = function(oOptions) {

	    // if unspecified, assume OK/error

	    if (!oOptions) {
	      oOptions = {
	        type: (sm2.ok() ? 'onready' : 'ontimeout')
	      };
	    }

	    if (!didInit && oOptions && !oOptions.ignoreInit) {
	      // not ready yet.
	      return false;
	    }

	    if (oOptions.type === 'ontimeout' && (sm2.ok() || (disabled && !oOptions.ignoreInit))) {
	      // invalid case
	      return false;
	    }

	    var status = {
	          success: (oOptions && oOptions.ignoreInit?sm2.ok():!disabled)
	        },

	        // queue specified by type, or none
	        srcQueue = (oOptions && oOptions.type?on_queue[oOptions.type]||[]:[]),

	        queue = [], i, j,
	        args = [status],
	        canRetry = (needsFlash && !sm2.ok());

	    if (oOptions.error) {
	      args[0].error = oOptions.error;
	    }

	    for (i = 0, j = srcQueue.length; i < j; i++) {
	      if (srcQueue[i].fired !== true) {
	        queue.push(srcQueue[i]);
	      }
	    }

	    if (queue.length) {
	      // sm2._wD(sm + ': Firing ' + queue.length + ' ' + oOptions.type + '() item' + (queue.length === 1 ? '' : 's'));
	      for (i = 0, j = queue.length; i < j; i++) {
	        if (queue[i].scope) {
	          queue[i].method.apply(queue[i].scope, args);
	        } else {
	          queue[i].method.apply(this, args);
	        }
	        if (!canRetry) {
	          // useFlashBlock and SWF timeout case doesn't count here.
	          queue[i].fired = true;
	        }
	      }
	    }

	    return true;

	  };

	  initUserOnload = function() {

	    window.setTimeout(function() {

	      if (sm2.useFlashBlock) {
	        flashBlockHandler();
	      }

	      processOnEvents();

	      // call user-defined "onload", scoped to window

	      if (typeof sm2.onload === 'function') {
	        _wDS('onload', 1);
	        sm2.onload.apply(window);
	        _wDS('onloadOK', 1);
	      }

	      if (sm2.waitForWindowLoad) {
	        event.add(window, 'load', initUserOnload);
	      }

	    },1);

	  };

	  detectFlash = function() {

	    // hat tip: Flash Detect library (BSD, (C) 2007) by Carl "DocYes" S. Yestrau - http://featureblend.com/javascript-flash-detection-library.html / http://featureblend.com/license.txt

	    if (hasFlash !== _undefined) {
	      // this work has already been done.
	      return hasFlash;
	    }

	    var hasPlugin = false, n = navigator, nP = n.plugins, obj, type, types, AX = window.ActiveXObject;

	    if (nP && nP.length) {
	      type = 'application/x-shockwave-flash';
	      types = n.mimeTypes;
	      if (types && types[type] && types[type].enabledPlugin && types[type].enabledPlugin.description) {
	        hasPlugin = true;
	      }
	    } else if (AX !== _undefined && !ua.match(/MSAppHost/i)) {
	      // Windows 8 Store Apps (MSAppHost) are weird (compatibility?) and won't complain here, but will barf if Flash/ActiveX object is appended to the DOM.
	      try {
	        obj = new AX('ShockwaveFlash.ShockwaveFlash');
	      } catch(e) {
	        // oh well
	        obj = null;
	      }
	      hasPlugin = (!!obj);
	      // cleanup, because it is ActiveX after all
	      obj = null;
	    }

	    hasFlash = hasPlugin;

	    return hasPlugin;

	  };

	  featureCheck = function() {

	    var flashNeeded,
	        item,
	        formats = sm2.audioFormats,
	        // iPhone <= 3.1 has broken HTML5 audio(), but firmware 3.2 (original iPad) + iOS4 works.
	        isSpecial = (is_iDevice && !!(ua.match(/os (1|2|3_0|3_1)/i)));

	    if (isSpecial) {

	      // has Audio(), but is broken; let it load links directly.
	      sm2.hasHTML5 = false;

	      // ignore flash case, however
	      sm2.html5Only = true;

	      // hide the SWF, if present
	      if (sm2.oMC) {
	        sm2.oMC.style.display = 'none';
	      }

	    } else {

	      if (sm2.useHTML5Audio) {

	        if (!sm2.html5 || !sm2.html5.canPlayType) {
	          //sm2._wD('SoundManager: No HTML5 Audio() support detected.');
	          sm2.hasHTML5 = false;
	        }

	        // <d>
	        if (isBadSafari) {
	          sm2._wD(smc + 'Note: Buggy HTML5 Audio in Safari on this OS X release, see https://bugs.webkit.org/show_bug.cgi?id=32159 - ' + (!hasFlash ?' would use flash fallback for MP3/MP4, but none detected.' : 'will use flash fallback for MP3/MP4, if available'), 1);
	        }
	        // </d>

	      }

	    }

	    if (sm2.useHTML5Audio && sm2.hasHTML5) {

	      // sort out whether flash is optional, required or can be ignored.

	      // innocent until proven guilty.
	      canIgnoreFlash = true;

	      for (item in formats) {
	        if (formats.hasOwnProperty(item)) {
	          if (formats[item].required) {
	            if (!sm2.html5.canPlayType(formats[item].type)) {
	              // 100% HTML5 mode is not possible.
	              canIgnoreFlash = false;
	              flashNeeded = true;
	            } else if (sm2.preferFlash && (sm2.flash[item] || sm2.flash[formats[item].type])) {
	              // flash may be required, or preferred for this format.
	              flashNeeded = true;
	            }
	          }
	        }
	      }

	    }

	    // sanity check...
	    if (sm2.ignoreFlash) {
	      flashNeeded = false;
	      canIgnoreFlash = true;
	    }

	    sm2.html5Only = (sm2.hasHTML5 && sm2.useHTML5Audio && !flashNeeded);

	    return (!sm2.html5Only);

	  };

	  parseURL = function(url) {

	    /**
	     * Internal: Finds and returns the first playable URL (or failing that, the first URL.)
	     * @param {string or array} url A single URL string, OR, an array of URL strings or {url:'/path/to/resource', type:'audio/mp3'} objects.
	     */

	    var i, j, urlResult = 0, result;

	    if (url instanceof Array) {

	      // find the first good one
	      for (i=0, j=url.length; i<j; i++) {

	        if (url[i] instanceof Object) {
	          // MIME check
	          if (sm2.canPlayMIME(url[i].type)) {
	            urlResult = i;
	            break;
	          }

	        } else if (sm2.canPlayURL(url[i])) {
	          // URL string check
	          urlResult = i;
	          break;
	        }

	      }

	      // normalize to string
	      if (url[urlResult].url) {
	        url[urlResult] = url[urlResult].url;
	      }

	      result = url[urlResult];

	    } else {

	      // single URL case
	      result = url;

	    }

	    return result;

	  };


	  startTimer = function(oSound) {

	    /**
	     * attach a timer to this sound, and start an interval if needed
	     */

	    if (!oSound._hasTimer) {

	      oSound._hasTimer = true;

	      if (!mobileHTML5 && sm2.html5PollingInterval) {

	        if (h5IntervalTimer === null && h5TimerCount === 0) {

	          h5IntervalTimer = setInterval(timerExecute, sm2.html5PollingInterval);

	        }

	        h5TimerCount++;

	      }

	    }

	  };

	  stopTimer = function(oSound) {

	    /**
	     * detach a timer
	     */

	    if (oSound._hasTimer) {

	      oSound._hasTimer = false;

	      if (!mobileHTML5 && sm2.html5PollingInterval) {

	        // interval will stop itself at next execution.

	        h5TimerCount--;

	      }

	    }

	  };

	  timerExecute = function() {
	    /**
	     * manual polling for HTML5 progress events, ie., whileplaying() (can achieve greater precision than conservative default HTML5 interval)
	     */

	    var i;

	    if (h5IntervalTimer !== null && !h5TimerCount) {

	      // no active timers, stop polling interval.

	      clearInterval(h5IntervalTimer);

	      h5IntervalTimer = null;

	      return false;

	    }

	    // check all HTML5 sounds with timers

	    for (i = sm2.soundIDs.length-1; i >= 0; i--) {

	      if (sm2.sounds[sm2.soundIDs[i]].isHTML5 && sm2.sounds[sm2.soundIDs[i]]._hasTimer) {

	        sm2.sounds[sm2.soundIDs[i]]._onTimer();

	      }

	    }

	  };

	  catchError = function(options) {

	    options = (options !== _undefined ? options : {});

	    if (typeof sm2.onerror === 'function') {
	      sm2.onerror.apply(window, [{type:(options.type !== _undefined ? options.type : null)}]);
	    }

	    if (options.fatal !== _undefined && options.fatal) {
	      sm2.disable();
	    }

	  };

	  badSafariFix = function() {

	    // special case: "bad" Safari (OS X 10.3 - 10.7) must fall back to flash for MP3/MP4
	    if (!isBadSafari || !detectFlash()) {
	      // doesn't apply
	      return false;
	    }

	    var aF = sm2.audioFormats, i, item;

	    for (item in aF) {
	      if (aF.hasOwnProperty(item)) {
	        if (item === 'mp3' || item === 'mp4') {
	          sm2._wD(sm + ': Using flash fallback for ' + item + ' format');
	          sm2.html5[item] = false;
	          // assign result to related formats, too
	          if (aF[item] && aF[item].related) {
	            for (i = aF[item].related.length-1; i >= 0; i--) {
	              sm2.html5[aF[item].related[i]] = false;
	            }
	          }
	        }
	      }
	    }

	  };

	  /**
	   * Pseudo-private flash/ExternalInterface methods
	   * ----------------------------------------------
	   */

	  this._setSandboxType = function(sandboxType) {

	    // <d>
	    var sb = sm2.sandbox;

	    sb.type = sandboxType;
	    sb.description = sb.types[(sb.types[sandboxType] !== _undefined?sandboxType:'unknown')];

	    if (sb.type === 'localWithFile') {

	      sb.noRemote = true;
	      sb.noLocal = false;
	      _wDS('secNote', 2);

	    } else if (sb.type === 'localWithNetwork') {

	      sb.noRemote = false;
	      sb.noLocal = true;

	    } else if (sb.type === 'localTrusted') {

	      sb.noRemote = false;
	      sb.noLocal = false;

	    }
	    // </d>

	  };

	  this._externalInterfaceOK = function(swfVersion) {

	    // flash callback confirming flash loaded, EI working etc.
	    // swfVersion: SWF build string

	    if (sm2.swfLoaded) {
	      return false;
	    }

	    var e;

	    debugTS('swf', true);
	    debugTS('flashtojs', true);
	    sm2.swfLoaded = true;
	    tryInitOnFocus = false;

	    if (isBadSafari) {
	      badSafariFix();
	    }

	    // complain if JS + SWF build/version strings don't match, excluding +DEV builds
	    // <d>
	    if (!swfVersion || swfVersion.replace(/\+dev/i,'') !== sm2.versionNumber.replace(/\+dev/i, '')) {

	      e = sm + ': Fatal: JavaScript file build "' + sm2.versionNumber + '" does not match Flash SWF build "' + swfVersion + '" at ' + sm2.url + '. Ensure both are up-to-date.';

	      // escape flash -> JS stack so this error fires in window.
	      setTimeout(function versionMismatch() {
	        throw new Error(e);
	      }, 0);

	      // exit, init will fail with timeout
	      return false;

	    }
	    // </d>

	    // IE needs a larger timeout
	    setTimeout(init, isIE ? 100 : 1);

	  };

	  /**
	   * Private initialization helpers
	   * ------------------------------
	   */

	  createMovie = function(smID, smURL) {

	    if (didAppend && appendSuccess) {
	      // ignore if already succeeded
	      return false;
	    }

	    function initMsg() {

	      // <d>

	      var options = [],
	          title,
	          msg = [],
	          delimiter = ' + ';

	      title = '';//'SoundManager ' + sm2.version + (!sm2.html5Only && sm2.useHTML5Audio ? (sm2.hasHTML5 ? ' + HTML5 audio' : ', no HTML5 audio support') : '');

	      if (!sm2.html5Only) {

	        if (sm2.preferFlash) {
	          options.push('preferFlash');
	        }

	        if (sm2.useHighPerformance) {
	          options.push('useHighPerformance');
	        }

	        if (sm2.flashPollingInterval) {
	          options.push('flashPollingInterval (' + sm2.flashPollingInterval + 'ms)');
	        }

	        if (sm2.html5PollingInterval) {
	          options.push('html5PollingInterval (' + sm2.html5PollingInterval + 'ms)');
	        }

	        if (sm2.wmode) {
	          options.push('wmode (' + sm2.wmode + ')');
	        }

	        if (sm2.debugFlash) {
	          options.push('debugFlash');
	        }

	        if (sm2.useFlashBlock) {
	          options.push('flashBlock');
	        }

	      } else {

	        if (sm2.html5PollingInterval) {
	          options.push('html5PollingInterval (' + sm2.html5PollingInterval + 'ms)');
	        }

	      }

	      if (options.length) {
	        msg = msg.concat([options.join(delimiter)]);
	      }

	      sm2._wD(title + (msg.length ? delimiter + msg.join(', ') : ''), 1);

	      showSupport();

	      // </d>

	    }

	    if (sm2.html5Only) {

	      // 100% HTML5 mode
	      setVersionInfo();

	      initMsg();
	      sm2.oMC = id(sm2.movieID);
	      init();

	      // prevent multiple init attempts
	      didAppend = true;

	      appendSuccess = true;

	      return false;

	    }

	    // flash path
	    var remoteURL = (smURL || sm2.url),
	    localURL = (sm2.altURL || remoteURL),
	    swfTitle = 'JS/Flash audio component (SoundManager 2)',
	    oTarget = getDocument(),
	    extraClass = getSWFCSS(),
	    isRTL = null,
	    html = doc.getElementsByTagName('html')[0],
	    oEmbed, oMovie, tmp, movieHTML, oEl, s, x, sClass;

	    isRTL = (html && html.dir && html.dir.match(/rtl/i));
	    smID = (smID === _undefined?sm2.id:smID);

	    function param(name, value) {
	      return '<param name="'+name+'" value="'+value+'" />';
	    }

	    // safety check for legacy (change to Flash 9 URL)
	    setVersionInfo();
	    sm2.url = normalizeMovieURL(overHTTP?remoteURL:localURL);
	    smURL = sm2.url;

	    sm2.wmode = (!sm2.wmode && sm2.useHighPerformance ? 'transparent' : sm2.wmode);

	    if (sm2.wmode !== null && (ua.match(/msie 8/i) || (!isIE && !sm2.useHighPerformance)) && navigator.platform.match(/win32|win64/i)) {
	      /**
	       * extra-special case: movie doesn't load until scrolled into view when using wmode = anything but 'window' here
	       * does not apply when using high performance (position:fixed means on-screen), OR infinite flash load timeout
	       * wmode breaks IE 8 on Vista + Win7 too in some cases, as of January 2011 (?)
	       */
	       messages.push(strings.spcWmode);
	      sm2.wmode = null;
	    }

	    oEmbed = {
	      'name': smID,
	      'id': smID,
	      'src': smURL,
	      'quality': 'high',
	      'allowScriptAccess': sm2.allowScriptAccess,
	      'bgcolor': sm2.bgColor,
	      'pluginspage': http+'www.macromedia.com/go/getflashplayer',
	      'title': swfTitle,
	      'type': 'application/x-shockwave-flash',
	      'wmode': sm2.wmode,
	      // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html
	      'hasPriority': 'true'
	    };

	    if (sm2.debugFlash) {
	      oEmbed.FlashVars = 'debug=1';
	    }

	    if (!sm2.wmode) {
	      // don't write empty attribute
	      delete oEmbed.wmode;
	    }

	    if (isIE) {

	      // IE is "special".
	      oMovie = doc.createElement('div');
	      movieHTML = [
	        '<object id="' + smID + '" data="' + smURL + '" type="' + oEmbed.type + '" title="' + oEmbed.title +'" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="' + http+'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0">',
	        param('movie', smURL),
	        param('AllowScriptAccess', sm2.allowScriptAccess),
	        param('quality', oEmbed.quality),
	        (sm2.wmode? param('wmode', sm2.wmode): ''),
	        param('bgcolor', sm2.bgColor),
	        param('hasPriority', 'true'),
	        (sm2.debugFlash ? param('FlashVars', oEmbed.FlashVars) : ''),
	        '</object>'
	      ].join('');

	    } else {

	      oMovie = doc.createElement('embed');
	      for (tmp in oEmbed) {
	        if (oEmbed.hasOwnProperty(tmp)) {
	          oMovie.setAttribute(tmp, oEmbed[tmp]);
	        }
	      }

	    }

	    initDebug();
	    extraClass = getSWFCSS();
	    oTarget = getDocument();

	    if (oTarget) {

	      sm2.oMC = (id(sm2.movieID) || doc.createElement('div'));

	      if (!sm2.oMC.id) {

	        sm2.oMC.id = sm2.movieID;
	        sm2.oMC.className = swfCSS.swfDefault + ' ' + extraClass;
	        s = null;
	        oEl = null;

	        if (!sm2.useFlashBlock) {
	          if (sm2.useHighPerformance) {
	            // on-screen at all times
	            s = {
	              'position': 'fixed',
	              'width': '8px',
	              'height': '8px',
	              // >= 6px for flash to run fast, >= 8px to start up under Firefox/win32 in some cases. odd? yes.
	              'bottom': '0px',
	              'left': '0px',
	              'overflow': 'hidden'
	            };
	          } else {
	            // hide off-screen, lower priority
	            s = {
	              'position': 'absolute',
	              'width': '6px',
	              'height': '6px',
	              'top': '-9999px',
	              'left': '-9999px'
	            };
	            if (isRTL) {
	              s.left = Math.abs(parseInt(s.left,10))+'px';
	            }
	          }
	        }

	        if (isWebkit) {
	          // soundcloud-reported render/crash fix, safari 5
	          sm2.oMC.style.zIndex = 10000;
	        }

	        if (!sm2.debugFlash) {
	          for (x in s) {
	            if (s.hasOwnProperty(x)) {
	              sm2.oMC.style[x] = s[x];
	            }
	          }
	        }

	        try {
	          if (!isIE) {
	            sm2.oMC.appendChild(oMovie);
	          }
	          oTarget.appendChild(sm2.oMC);
	          if (isIE) {
	            oEl = sm2.oMC.appendChild(doc.createElement('div'));
	            oEl.className = swfCSS.swfBox;
	            oEl.innerHTML = movieHTML;
	          }
	          appendSuccess = true;
	        } catch(e) {
	          throw new Error(str('domError')+' \n'+e.toString());
	        }

	      } else {

	        // SM2 container is already in the document (eg. flashblock use case)
	        sClass = sm2.oMC.className;
	        sm2.oMC.className = (sClass?sClass+' ':swfCSS.swfDefault) + (extraClass?' '+extraClass:'');
	        sm2.oMC.appendChild(oMovie);
	        if (isIE) {
	          oEl = sm2.oMC.appendChild(doc.createElement('div'));
	          oEl.className = swfCSS.swfBox;
	          oEl.innerHTML = movieHTML;
	        }
	        appendSuccess = true;

	      }

	    }

	    didAppend = true;
	    initMsg();
	    // sm2._wD(sm + ': Trying to load ' + smURL + (!overHTTP && sm2.altURL ? ' (alternate URL)' : ''), 1);

	    return true;

	  };

	  initMovie = function() {

	    if (sm2.html5Only) {
	      createMovie();
	      return false;
	    }

	    // attempt to get, or create, movie (may already exist)
	    if (flash) {
	      return false;
	    }

	    if (!sm2.url) {

	      /**
	       * Something isn't right - we've reached init, but the soundManager url property has not been set.
	       * User has not called setup({url: ...}), or has not set soundManager.url (legacy use case) directly before init time.
	       * Notify and exit. If user calls setup() with a url: property, init will be restarted as in the deferred loading case.
	       */

	       _wDS('noURL');
	       return false;

	    }

	    // inline markup case
	    flash = sm2.getMovie(sm2.id);

	    if (!flash) {
	      if (!oRemoved) {
	        // try to create
	        createMovie(sm2.id, sm2.url);
	      } else {
	        // try to re-append removed movie after reboot()
	        if (!isIE) {
	          sm2.oMC.appendChild(oRemoved);
	        } else {
	          sm2.oMC.innerHTML = oRemovedHTML;
	        }
	        oRemoved = null;
	        didAppend = true;
	      }
	      flash = sm2.getMovie(sm2.id);
	    }

	    if (typeof sm2.oninitmovie === 'function') {
	      setTimeout(sm2.oninitmovie, 1);
	    }

	    // <d>
	    flushMessages();
	    // </d>

	    return true;

	  };

	  delayWaitForEI = function() {

	    setTimeout(waitForEI, 1000);

	  };

	  rebootIntoHTML5 = function() {

	    // special case: try for a reboot with preferFlash: false, if 100% HTML5 mode is possible and useFlashBlock is not enabled.

	    window.setTimeout(function() {

	      //complain(smc + 'useFlashBlock is false, 100% HTML5 mode is possible. Rebooting with preferFlash: false...');

	      sm2.setup({
	        preferFlash: false
	      }).reboot();

	      // if for some reason you want to detect this case, use an ontimeout() callback and look for html5Only and didFlashBlock == true.
	      sm2.didFlashBlock = true;

	      sm2.beginDelayedInit();

	    }, 1);

	  };

	  waitForEI = function() {

	    var p,
	        loadIncomplete = false;

	    if (!sm2.url) {
	      // No SWF url to load (noURL case) - exit for now. Will be retried when url is set.
	      return false;
	    }

	    if (waitingForEI) {
	      return false;
	    }

	    waitingForEI = true;
	    event.remove(window, 'load', delayWaitForEI);

	    if (hasFlash && tryInitOnFocus && !isFocused) {
	      // Safari won't load flash in background tabs, only when focused.
	      _wDS('waitFocus');
	      return false;
	    }

	    if (!didInit) {
	      p = sm2.getMoviePercent();
	      if (p > 0 && p < 100) {
	        loadIncomplete = true;
	      }
	    }

	    setTimeout(function() {

	      p = sm2.getMoviePercent();

	      if (loadIncomplete) {
	        // special case: if movie *partially* loaded, retry until it's 100% before assuming failure.
	        waitingForEI = false;
	        sm2._wD(str('waitSWF'));
	        window.setTimeout(delayWaitForEI, 1);
	        return false;
	      }

	      // <d>
	      if (!didInit) {

	        //sm2._wD(sm + ': No Flash response within expected time. Likely causes: ' + (p === 0 ? 'SWF load failed, ':'') + 'Flash blocked or JS-Flash security error.' + (sm2.debugFlash?' ' + str('checkSWF'):''), 2);

	        if (!overHTTP && p) {

	          _wDS('localFail', 2);

	          if (!sm2.debugFlash) {
	            _wDS('tryDebug', 2);
	          }

	        }

	        if (p === 0) {

	          // if 0 (not null), probably a 404.
	          sm2._wD(str('swf404', sm2.url), 1);

	        }

	        debugTS('flashtojs', false, true?' (Check flash security or flash blockers)':' (No plugin/missing SWF?)');

	      }
	      // </d>

	      // give up / time-out, depending

	      if (!didInit && okToDisable) {

	        if (p === null) {

	          // SWF failed to report load progress. Possibly blocked.

	          if (sm2.useFlashBlock || sm2.flashLoadTimeout === 0) {

	            if (sm2.useFlashBlock) {

	              flashBlockHandler();

	            }

	            _wDS('waitForever');

	          } else {

	            // no custom flash block handling, but SWF has timed out. Will recover if user unblocks / allows SWF load.

	            if (!sm2.useFlashBlock && canIgnoreFlash) {

	              rebootIntoHTML5();

	            } else {

	              _wDS('waitForever');

	              // fire any regular registered ontimeout() listeners.
	              processOnEvents({type:'ontimeout', ignoreInit: true, error: {type: 'INIT_FLASHBLOCK'}});

	            }

	          }

	        } else {

	          // SWF loaded? Shouldn't be a blocking issue, then.

	          if (sm2.flashLoadTimeout === 0) {

	            _wDS('waitForever');

	          } else {

	            if (!sm2.useFlashBlock && canIgnoreFlash) {

	              rebootIntoHTML5();

	            } else {

	              failSafely(true);

	            }

	          }

	        }

	      }

	    }, sm2.flashLoadTimeout);

	  };

	  handleFocus = function() {

	    function cleanup() {
	      event.remove(window, 'focus', handleFocus);
	    }

	    if (isFocused || !tryInitOnFocus) {
	      // already focused, or not special Safari background tab case
	      cleanup();
	      return true;
	    }

	    okToDisable = true;
	    isFocused = true;
	    _wDS('gotFocus');

	    // allow init to restart
	    waitingForEI = false;

	    // kick off ExternalInterface timeout, now that the SWF has started
	    delayWaitForEI();

	    cleanup();
	    return true;

	  };

	  flushMessages = function() {

	    // <d>

	    // SM2 pre-init debug messages
	    if (messages.length) {
	      sm2._wD('SoundManager 2: ' + messages.join(' '), 1);
	      messages = [];
	    }

	    // </d>

	  };

	  showSupport = function() {

	    // <d>

	    flushMessages();

	    var item, tests = [];

	    if (sm2.useHTML5Audio && sm2.hasHTML5) {
	      for (item in sm2.audioFormats) {
	        if (sm2.audioFormats.hasOwnProperty(item)) {
	          tests.push(item + ' = ' + sm2.html5[item] + (!sm2.html5[item] && needsFlash && sm2.flash[item] ? ' (using flash)' : (sm2.preferFlash && sm2.flash[item] && needsFlash ? ' (preferring flash)': (!sm2.html5[item] ? ' (' + (sm2.audioFormats[item].required ? 'required, ':'') + 'and no flash support)' : ''))));
	        }
	      }
	      sm2._wD('SoundManager 2 HTML5 support: ' + tests.join(', '), 1);
	    }

	    // </d>

	  };

	  initComplete = function(bNoDisable) {

	    if (didInit) {
	      return false;
	    }

	    if (sm2.html5Only) {
	      // all good.
	      _wDS('sm2Loaded');
	      didInit = true;
	      initUserOnload();
	      debugTS('onload', true);
	      return true;
	    }

	    var wasTimeout = (sm2.useFlashBlock && sm2.flashLoadTimeout && !sm2.getMoviePercent()),
	        result = true,
	        error;

	    if (!wasTimeout) {
	      didInit = true;
	    }

	    error = {type: (!hasFlash && needsFlash ? 'NO_FLASH' : 'INIT_TIMEOUT')};

	    sm2._wD('SoundManager 2 ' + (disabled ? 'failed to load' : 'loaded') + ' (' + (disabled ? 'Flash security/load error' : 'OK') + ')', disabled ? 2: 1);

	    if (disabled || bNoDisable) {
	      if (sm2.useFlashBlock && sm2.oMC) {
	        sm2.oMC.className = getSWFCSS() + ' ' + (sm2.getMoviePercent() === null?swfCSS.swfTimedout:swfCSS.swfError);
	      }
	      processOnEvents({type:'ontimeout', error:error, ignoreInit: true});
	      debugTS('onload', false);
	      catchError(error);
	      result = false;
	    } else {
	      debugTS('onload', true);
	    }

	    if (!disabled) {
	      if (sm2.waitForWindowLoad && !windowLoaded) {
	        _wDS('waitOnload');
	        event.add(window, 'load', initUserOnload);
	      } else {
	        // <d>
	        if (sm2.waitForWindowLoad && windowLoaded) {
	          _wDS('docLoaded');
	        }
	        // </d>
	        initUserOnload();
	      }
	    }

	    return result;

	  };

	  /**
	   * apply top-level setupOptions object as local properties, eg., this.setupOptions.flashVersion -> this.flashVersion (soundManager.flashVersion)
	   * this maintains backward compatibility, and allows properties to be defined separately for use by soundManager.setup().
	   */

	  setProperties = function() {

	    var i,
	        o = sm2.setupOptions;

	    for (i in o) {

	      if (o.hasOwnProperty(i)) {

	        // assign local property if not already defined

	        if (sm2[i] === _undefined) {

	          sm2[i] = o[i];

	        } else if (sm2[i] !== o[i]) {

	          // legacy support: write manually-assigned property (eg., soundManager.url) back to setupOptions to keep things in sync
	          sm2.setupOptions[i] = sm2[i];

	        }

	      }

	    }

	  };


	  init = function() {

	    // called after onload()

	    if (didInit) {
	      _wDS('didInit');
	      return false;
	    }

	    function cleanup() {
	      event.remove(window, 'load', sm2.beginDelayedInit);
	    }

	    if (sm2.html5Only) {
	      if (!didInit) {
	        // we don't need no steenking flash!
	        cleanup();
	        sm2.enabled = true;
	        initComplete();
	      }
	      return true;
	    }

	    // flash path
	    initMovie();

	    try {

	      // attempt to talk to Flash
	      flash._externalInterfaceTest(false);

	      // apply user-specified polling interval, OR, if "high performance" set, faster vs. default polling
	      // (determines frequency of whileloading/whileplaying callbacks, effectively driving UI framerates)
	      setPolling(true, (sm2.flashPollingInterval || (sm2.useHighPerformance ? 10 : 50)));

	      if (!sm2.debugMode) {
	        // stop the SWF from making debug output calls to JS
	        flash._disableDebug();
	      }

	      sm2.enabled = true;
	      debugTS('jstoflash', true);

	      if (!sm2.html5Only) {
	        // prevent browser from showing cached page state (or rather, restoring "suspended" page state) via back button, because flash may be dead
	        // http://www.webkit.org/blog/516/webkit-page-cache-ii-the-unload-event/
	        event.add(window, 'unload', doNothing);
	      }

	    } catch(e) {

	      sm2._wD('js/flash exception: ' + e.toString());
	      debugTS('jstoflash', false);
	      catchError({type:'JS_TO_FLASH_EXCEPTION', fatal:true});
	      // don't disable, for reboot()
	      failSafely(true);
	      initComplete();

	      return false;

	    }

	    initComplete();

	    // disconnect events
	    cleanup();

	    return true;

	  };

	  domContentLoaded = function() {
	    if (didDCLoaded) {
	      return false;
	    }

	    didDCLoaded = true;

	    // assign top-level soundManager properties eg. soundManager.url
	    setProperties();

	    initDebug();

	    /**
	     * Temporary feature: allow force of HTML5 via URL params: sm2-usehtml5audio=0 or 1
	     * Ditto for sm2-preferFlash, too.
	     */
	    // <d>
	    (function(){

	      var a = 'sm2-usehtml5audio=',
	          a2 = 'sm2-preferflash=',
	          b = null,
	          b2 = null,
	          l = wl.toLowerCase();

	      if (l.indexOf(a) !== -1) {
	        b = (l.charAt(l.indexOf(a)+a.length) === '1');
	        if (hasConsole) {
	          console.log((b?'Enabling ':'Disabling ')+'useHTML5Audio via URL parameter');
	        }
	        sm2.setup({
	          'useHTML5Audio': b
	        });
	      }

	      if (l.indexOf(a2) !== -1) {
	        b2 = (l.charAt(l.indexOf(a2)+a2.length) === '1');
	        if (hasConsole) {
	          console.log((b2?'Enabling ':'Disabling ')+'preferFlash via URL parameter');
	        }
	        sm2.setup({
	          'preferFlash': b2
	        });
	      }

	    }());
	    // </d>

	    if (!hasFlash && sm2.hasHTML5) {
	      sm2._wD('SoundManager 2: No Flash detected' + (!sm2.useHTML5Audio ? ', enabling HTML5.' : '. Trying HTML5-only mode.'), 1);
	      sm2.setup({
	        'useHTML5Audio': true,
	        // make sure we aren't preferring flash, either
	        // TODO: preferFlash should not matter if flash is not installed. Currently, stuff breaks without the below tweak.
	        'preferFlash': false
	      });
	    }

	    testHTML5();

	    if (!hasFlash && needsFlash) {
	      //messages.push(strings.needFlash);
	      // TODO: Fatal here vs. timeout approach, etc.
	      // hack: fail sooner.
	      sm2.setup({
	        'flashLoadTimeout': 1
	      });
	    }

	    if (doc.removeEventListener) {
	      doc.removeEventListener('DOMContentLoaded', domContentLoaded, false);
	    }

	    initMovie();

	    return true;

	  };

	  domContentLoadedIE = function() {

	    if (doc.readyState === 'complete') {
	      domContentLoaded();
	      doc.detachEvent('onreadystatechange', domContentLoadedIE);
	    }

	    return true;

	  };

	  winOnLoad = function() {

	    // catch edge case of initComplete() firing after window.load()
	    windowLoaded = true;
	    event.remove(window, 'load', winOnLoad);

	  };

	  /**
	   * miscellaneous run-time, pre-init stuff
	   */

	  preInit = function() {

	    if (mobileHTML5) {

	      // prefer HTML5 for mobile + tablet-like devices, probably more reliable vs. flash at this point.

	      // <d>
	      if (!sm2.setupOptions.useHTML5Audio || sm2.setupOptions.preferFlash) {
	        // notify that defaults are being changed.
	        //messages.push(strings.mobileUA);
	      }
	      // </d>

	      sm2.setupOptions.useHTML5Audio = true;
	      sm2.setupOptions.preferFlash = false;

	      if (is_iDevice || (isAndroid && !ua.match(/android\s2\.3/i))) {
	        // iOS and Android devices tend to work better with a single audio instance, specifically for chained playback of sounds in sequence.
	        // common use case: exiting sound onfinish() -> createSound() -> play()
	        // <d>
	        //messages.push(strings.globalHTML5);
	        // </d>
	        if (is_iDevice) {
	          sm2.ignoreFlash = true;
	        }
	        useGlobalHTML5Audio = true;
	      }

	    }

	  };

	  preInit();

	  // sniff up-front
	  detectFlash();

	  // focus and window load, init (primarily flash-driven)
	  event.add(window, 'focus', handleFocus);
	  event.add(window, 'load', delayWaitForEI);
	  event.add(window, 'load', winOnLoad);

	  if (doc.addEventListener) {

	    doc.addEventListener('DOMContentLoaded', domContentLoaded, false);

	  } else if (doc.attachEvent) {

	    doc.attachEvent('onreadystatechange', domContentLoadedIE);

	  } else {

	    // no add/attachevent support - safe to assume no JS -> Flash either
	    debugTS('onload', false);
	    catchError({type:'NO_DOM2_EVENTS', fatal:true});

	  }

	} // SoundManager()

	// SM2_DEFER details: http://www.schillmania.com/projects/soundmanager2/doc/getstarted/#lazy-loading
	// We always want to return a real soundmanager object, since this is requirejs.
	//if (window.SM2_DEFER === undefined || !SM2_DEFER) {
	  soundManager = new SoundManager();
	//}

	/**
	 * SoundManager public interfaces
	 * ------------------------------
	 */

	return soundManager;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* 
	 *  DSP.js - a comprehensive digital signal processing  library for javascript
	 * 
	 *  Created by Corban Brook <corbanbrook@gmail.com> on 2010-01-01.
	 *  Copyright 2010 Corban Brook. All rights reserved.
	 *
	 */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

	    ////////////////////////////////////////////////////////////////////////////////
	    //                                  CONSTANTS                                 //
	    ////////////////////////////////////////////////////////////////////////////////

	    /**
	     * DSP is an object which contains general purpose utility functions and constants
	     */
	    var DSP = {
	      // Channels
	      LEFT:           0,
	      RIGHT:          1,
	      MIX:            2,

	      // Waveforms
	      SINE:           1,
	      TRIANGLE:       2,
	      SAW:            3,
	      SQUARE:         4,

	      // Filters
	      LOWPASS:        0,
	      HIGHPASS:       1,
	      BANDPASS:       2,
	      NOTCH:          3,

	      // Window functions
	      BARTLETT:       1,
	      BARTLETTHANN:   2,
	      BLACKMAN:       3,
	      COSINE:         4,
	      GAUSS:          5,
	      HAMMING:        6,
	      HANN:           7,
	      LANCZOS:        8,
	      RECTANGULAR:    9,
	      TRIANGULAR:     10,

	      // Loop modes
	      OFF:            0,
	      FW:             1,
	      BW:             2,
	      FWBW:           3,

	      // Math
	      TWO_PI:         2*Math.PI
	    };

	    // Setup arrays for platforms which do not support byte arrays
	    function setupTypedArray(name, fallback) {
	      // check if TypedArray exists
	      // typeof on Minefield and Chrome return function, typeof on Webkit returns object.
	      if (typeof this[name] !== "function" && typeof this[name] !== "object") {
	        // nope.. check if WebGLArray exists
	        if (typeof this[fallback] === "function" && typeof this[fallback] !== "object") {
	          this[name] = this[fallback];
	        } else {
	          // nope.. set as Native JS array
	          this[name] = function(obj) {
	            if (obj instanceof Array) {
	              return obj;
	            } else if (typeof obj === "number") {
	              return new Array(obj);
	            }
	          };
	        }
	      }
	    }

	    setupTypedArray("Float32Array", "WebGLFloatArray");
	    setupTypedArray("Int32Array",   "WebGLIntArray");
	    setupTypedArray("Uint16Array",  "WebGLUnsignedShortArray");
	    setupTypedArray("Uint8Array",   "WebGLUnsignedByteArray");


	    ////////////////////////////////////////////////////////////////////////////////
	    //                            DSP UTILITY FUNCTIONS                           //
	    ////////////////////////////////////////////////////////////////////////////////

	    /**
	     * Inverts the phase of a signal
	     *
	     * @param {Array} buffer A sample buffer
	     *
	     * @returns The inverted sample buffer
	     */
	    DSP.invert = function(buffer) {
	      for (var i = 0, len = buffer.length; i < len; i++) {
	        buffer[i] *= -1;
	      }

	      return buffer;
	    };

	    /**
	     * Converts split-stereo (dual mono) sample buffers into a stereo interleaved sample buffer
	     *
	     * @param {Array} left  A sample buffer
	     * @param {Array} right A sample buffer
	     *
	     * @returns The stereo interleaved buffer
	     */
	    DSP.interleave = function(left, right) {
	      if (left.length !== right.length) {
	        throw "Can not interleave. Channel lengths differ.";
	      }
	     
	      var stereoInterleaved = new Float32Array(left.length * 2);
	     
	      for (var i = 0, len = left.length; i < len; i++) {
	        stereoInterleaved[2*i]   = left[i];
	        stereoInterleaved[2*i+1] = right[i];
	      }
	     
	      return stereoInterleaved;
	    };

	    /**
	     * Converts a stereo-interleaved sample buffer into split-stereo (dual mono) sample buffers
	     *
	     * @param {Array} buffer A stereo-interleaved sample buffer
	     *
	     * @returns an Array containing left and right channels
	     */
	    DSP.deinterleave = (function() {
	      var left, right, mix, deinterleaveChannel = []; 

	      deinterleaveChannel[DSP.MIX] = function(buffer) {
	        for (var i = 0, len = buffer.length/2; i < len; i++) {
	          mix[i] = (buffer[2*i] + buffer[2*i+1]) / 2;
	        }
	        return mix;
	      };

	      deinterleaveChannel[DSP.LEFT] = function(buffer) {
	        for (var i = 0, len = buffer.length/2; i < len; i++) {
	          left[i]  = buffer[2*i];
	        }
	        return left;
	      };

	      deinterleaveChannel[DSP.RIGHT] = function(buffer) {
	        for (var i = 0, len = buffer.length/2; i < len; i++) {
	          right[i]  = buffer[2*i+1];
	        }
	        return right;
	      };

	      return function(channel, buffer) { 
	        left  = left  || new Float32Array(buffer.length/2);
	        right = right || new Float32Array(buffer.length/2);
	        mix   = mix   || new Float32Array(buffer.length/2);

	        if (buffer.length/2 !== left.length) {
	          left  = new Float32Array(buffer.length/2);
	          right = new Float32Array(buffer.length/2);
	          mix   = new Float32Array(buffer.length/2);
	        }

	        return deinterleaveChannel[channel](buffer);
	      };
	    }());

	    /**
	     * Separates a channel from a stereo-interleaved sample buffer
	     *
	     * @param {Array}  buffer A stereo-interleaved sample buffer
	     * @param {Number} channel A channel constant (LEFT, RIGHT, MIX)
	     *
	     * @returns an Array containing a signal mono sample buffer
	     */
	    DSP.getChannel = DSP.deinterleave;

	    /**
	     * Helper method (for Reverb) to mix two (interleaved) samplebuffers. It's possible
	     * to negate the second buffer while mixing and to perform a volume correction
	     * on the final signal.
	     *
	     * @param {Array} sampleBuffer1 Array containing Float values or a Float32Array
	     * @param {Array} sampleBuffer2 Array containing Float values or a Float32Array
	     * @param {Boolean} negate When true inverts/flips the audio signal
	     * @param {Number} volumeCorrection When you add multiple sample buffers, use this to tame your signal ;)
	     *
	     * @returns A new Float32Array interleaved buffer.
	     */
	    DSP.mixSampleBuffers = function(sampleBuffer1, sampleBuffer2, negate, volumeCorrection){
	      var outputSamples = new Float32Array(sampleBuffer1);

	      for(var i = 0; i<sampleBuffer1.length; i++){
	        outputSamples[i] += (negate ? -sampleBuffer2[i] : sampleBuffer2[i]) / volumeCorrection;
	      }
	     
	      return outputSamples;
	    }; 

	    // Biquad filter types
	    DSP.LPF = 0;                // H(s) = 1 / (s^2 + s/Q + 1)
	    DSP.HPF = 1;                // H(s) = s^2 / (s^2 + s/Q + 1)
	    DSP.BPF_CONSTANT_SKIRT = 2; // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
	    DSP.BPF_CONSTANT_PEAK = 3;  // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
	    DSP.NOTCH = 4;              // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
	    DSP.APF = 5;                // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
	    DSP.PEAKING_EQ = 6;         // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
	    DSP.LOW_SHELF = 7;          // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
	    DSP.HIGH_SHELF = 8;         // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)

	    // Biquad filter parameter types
	    DSP.Q = 1;
	    DSP.BW = 2; // SHARED with BACKWARDS LOOP MODE
	    DSP.S = 3;

	    // Find RMS of signal
	    DSP.RMS = function(buffer) {
	      var total = 0;
	      
	      for (var i = 0, n = buffer.length; i < n; i++) {
	        total += buffer[i] * buffer[i];
	      }
	      
	      return Math.sqrt(total / n);
	    };

	    // Find Peak of signal
	    DSP.Peak = function(buffer) {
	      var peak = 0;
	      
	      for (var i = 0, n = buffer.length; i < n; i++) {
	        peak = (Math.abs(buffer[i]) > peak) ? Math.abs(buffer[i]) : peak; 
	      }
	      
	      return peak;
	    };

	    // Fourier Transform Module used by DFT, FFT, RFFT
	    function FourierTransform(bufferSize, sampleRate) {
	      this.bufferSize = bufferSize;
	      this.sampleRate = sampleRate;
	      this.bandwidth  = 2 / bufferSize * sampleRate / 2;

	      this.spectrum   = new Float32Array(bufferSize/2);
	      this.real       = new Float32Array(bufferSize);
	      this.imag       = new Float32Array(bufferSize);

	      this.peakBand   = 0;
	      this.peak       = 0;

	      /**
	       * Calculates the *middle* frequency of an FFT band.
	       *
	       * @param {Number} index The index of the FFT band.
	       *
	       * @returns The middle frequency in Hz.
	       */
	      this.getBandFrequency = function(index) {
	        return this.bandwidth * index + this.bandwidth / 2;
	      };

	      this.calculateSpectrum = function() {
	        var spectrum  = this.spectrum,
	            real      = this.real,
	            imag      = this.imag,
	            bSi       = 2 / this.bufferSize,
	            sqrt      = Math.sqrt,
	            rval, 
	            ival,
	            mag;

	        for (var i = 0, N = bufferSize/2; i < N; i++) {
	          rval = real[i];
	          ival = imag[i];
	          mag = bSi * sqrt(rval * rval + ival * ival);

	          if (mag > this.peak) {
	            this.peakBand = i;
	            this.peak = mag;
	          }

	          spectrum[i] = mag;
	        }
	      };
	    }

	    /**
	     * DFT is a class for calculating the Discrete Fourier Transform of a signal.
	     *
	     * @param {Number} bufferSize The size of the sample buffer to be computed
	     * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
	     *
	     * @constructor
	     */
	    function DFT(bufferSize, sampleRate) {
	      FourierTransform.call(this, bufferSize, sampleRate);

	      var N = bufferSize/2 * bufferSize;
	      var TWO_PI = 2 * Math.PI;

	      this.sinTable = new Float32Array(N);
	      this.cosTable = new Float32Array(N);

	      for (var i = 0; i < N; i++) {
	        this.sinTable[i] = Math.sin(i * TWO_PI / bufferSize);
	        this.cosTable[i] = Math.cos(i * TWO_PI / bufferSize);
	      }
	    }

	    /**
	     * Performs a forward transform on the sample buffer.
	     * Converts a time domain signal to frequency domain spectra.
	     *
	     * @param {Array} buffer The sample buffer
	     *
	     * @returns The frequency spectrum array
	     */
	    DFT.prototype.forward = function(buffer) {
	      var real = this.real, 
	          imag = this.imag,
	          rval,
	          ival;

	      for (var k = 0; k < this.bufferSize/2; k++) {
	        rval = 0.0;
	        ival = 0.0;

	        for (var n = 0; n < buffer.length; n++) {
	          rval += this.cosTable[k*n] * buffer[n];
	          ival += this.sinTable[k*n] * buffer[n];
	        }

	        real[k] = rval;
	        imag[k] = ival;
	      }

	      return this.calculateSpectrum();
	    };


	    /**
	     * FFT is a class for calculating the Discrete Fourier Transform of a signal
	     * with the Fast Fourier Transform algorithm.
	     *
	     * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
	     * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
	     *
	     * @constructor
	     */
	    function FFT(bufferSize, sampleRate) {
	      FourierTransform.call(this, bufferSize, sampleRate);
	       
	      this.reverseTable = new Uint32Array(bufferSize);

	      var limit = 1;
	      var bit = bufferSize >> 1;

	      var i;

	      while (limit < bufferSize) {
	        for (i = 0; i < limit; i++) {
	          this.reverseTable[i + limit] = this.reverseTable[i] + bit;
	        }

	        limit = limit << 1;
	        bit = bit >> 1;
	      }

	      this.sinTable = new Float32Array(bufferSize);
	      this.cosTable = new Float32Array(bufferSize);

	      for (i = 0; i < bufferSize; i++) {
	        this.sinTable[i] = Math.sin(-Math.PI/i);
	        this.cosTable[i] = Math.cos(-Math.PI/i);
	      }
	    }

	    /**
	     * Performs a forward transform on the sample buffer.
	     * Converts a time domain signal to frequency domain spectra.
	     *
	     * @param {Array} buffer The sample buffer. Buffer Length must be power of 2
	     *
	     * @returns The frequency spectrum array
	     */
	    FFT.prototype.forward = function(buffer) {
	      // Locally scope variables for speed up
	      var bufferSize      = this.bufferSize,
	          cosTable        = this.cosTable,
	          sinTable        = this.sinTable,
	          reverseTable    = this.reverseTable,
	          real            = this.real,
	          imag            = this.imag,
	          spectrum        = this.spectrum;

	      var k = Math.floor(Math.log(bufferSize) / Math.LN2);

	      if (Math.pow(2, k) !== bufferSize) { throw "Invalid buffer size, must be a power of 2."; }
	      if (bufferSize !== buffer.length)  { throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length; }

	      var halfSize = 1,
	          phaseShiftStepReal,
	          phaseShiftStepImag,
	          currentPhaseShiftReal,
	          currentPhaseShiftImag,
	          off,
	          tr,
	          ti,
	          tmpReal,
	          i;

	      for (i = 0; i < bufferSize; i++) {
	        real[i] = buffer[reverseTable[i]];
	        imag[i] = 0;
	      }

	      while (halfSize < bufferSize) {
	        //phaseShiftStepReal = Math.cos(-Math.PI/halfSize);
	        //phaseShiftStepImag = Math.sin(-Math.PI/halfSize);
	        phaseShiftStepReal = cosTable[halfSize];
	        phaseShiftStepImag = sinTable[halfSize];
	        
	        currentPhaseShiftReal = 1;
	        currentPhaseShiftImag = 0;

	        for (var fftStep = 0; fftStep < halfSize; fftStep++) {
	          i = fftStep;

	          while (i < bufferSize) {
	            off = i + halfSize;
	            tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
	            ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

	            real[off] = real[i] - tr;
	            imag[off] = imag[i] - ti;
	            real[i] += tr;
	            imag[i] += ti;

	            i += halfSize << 1;
	          }

	          tmpReal = currentPhaseShiftReal;
	          currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
	          currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
	        }

	        halfSize = halfSize << 1;
	      }

	      return this.calculateSpectrum();
	    };

	    FFT.prototype.inverse = function(real, imag) {
	      // Locally scope variables for speed up
	      var bufferSize      = this.bufferSize,
	          cosTable        = this.cosTable,
	          sinTable        = this.sinTable,
	          reverseTable    = this.reverseTable,
	          spectrum        = this.spectrum;
	         
	          real = real || this.real;
	          imag = imag || this.imag;

	      var halfSize = 1,
	          phaseShiftStepReal,
	          phaseShiftStepImag,
	          currentPhaseShiftReal,
	          currentPhaseShiftImag,
	          off,
	          tr,
	          ti,
	          tmpReal,
	          i;

	      for (i = 0; i < bufferSize; i++) {
	        imag[i] *= -1;
	      }

	      var revReal = new Float32Array(bufferSize);
	      var revImag = new Float32Array(bufferSize);
	     
	      for (i = 0; i < real.length; i++) {
	        revReal[i] = real[reverseTable[i]];
	        revImag[i] = imag[reverseTable[i]];
	      }
	     
	      real = revReal;
	      imag = revImag;

	      while (halfSize < bufferSize) {
	        phaseShiftStepReal = cosTable[halfSize];
	        phaseShiftStepImag = sinTable[halfSize];
	        currentPhaseShiftReal = 1;
	        currentPhaseShiftImag = 0;

	        for (var fftStep = 0; fftStep < halfSize; fftStep++) {
	          i = fftStep;

	          while (i < bufferSize) {
	            off = i + halfSize;
	            tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
	            ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

	            real[off] = real[i] - tr;
	            imag[off] = imag[i] - ti;
	            real[i] += tr;
	            imag[i] += ti;

	            i += halfSize << 1;
	          }

	          tmpReal = currentPhaseShiftReal;
	          currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
	          currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
	        }

	        halfSize = halfSize << 1;
	      }

	      var buffer = new Float32Array(bufferSize); // this should be reused instead
	      for (i = 0; i < bufferSize; i++) {
	        buffer[i] = real[i] / bufferSize;
	      }

	      return buffer;
	    };

	    /**
	     * RFFT is a class for calculating the Discrete Fourier Transform of a signal
	     * with the Fast Fourier Transform algorithm.
	     *
	     * This method currently only contains a forward transform but is highly optimized.
	     *
	     * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
	     * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
	     *
	     * @constructor
	     */

	    // lookup tables don't really gain us any speed, but they do increase
	    // cache footprint, so don't use them in here

	    // also we don't use sepearate arrays for real/imaginary parts

	    // this one a little more than twice as fast as the one in FFT
	    // however I only did the forward transform

	    // the rest of this was translated from C, see http://www.jjj.de/fxt/
	    // this is the real split radix FFT

	    function RFFT(bufferSize, sampleRate) {
	      FourierTransform.call(this, bufferSize, sampleRate);

	      this.trans = new Float32Array(bufferSize);

	      this.reverseTable = new Uint32Array(bufferSize);

	      // don't use a lookup table to do the permute, use this instead
	      this.reverseBinPermute = function (dest, source) {
	        var bufferSize  = this.bufferSize, 
	            halfSize    = bufferSize >>> 1, 
	            nm1         = bufferSize - 1, 
	            i = 1, r = 0, h;

	        dest[0] = source[0];

	        do {
	          r += halfSize;
	          dest[i] = source[r];
	          dest[r] = source[i];
	          
	          i++;

	          h = halfSize << 1;
	          while (h = h >> 1, !((r ^= h) & h));

	          if (r >= i) { 
	            dest[i]     = source[r]; 
	            dest[r]     = source[i];

	            dest[nm1-i] = source[nm1-r]; 
	            dest[nm1-r] = source[nm1-i];
	          }
	          i++;
	        } while (i < halfSize);
	        dest[nm1] = source[nm1];
	      };

	      this.generateReverseTable = function () {
	        var bufferSize  = this.bufferSize, 
	            halfSize    = bufferSize >>> 1, 
	            nm1         = bufferSize - 1, 
	            i = 1, r = 0, h;

	        this.reverseTable[0] = 0;

	        do {
	          r += halfSize;
	          
	          this.reverseTable[i] = r;
	          this.reverseTable[r] = i;

	          i++;

	          h = halfSize << 1;
	          while (h = h >> 1, !((r ^= h) & h));

	          if (r >= i) { 
	            this.reverseTable[i] = r;
	            this.reverseTable[r] = i;

	            this.reverseTable[nm1-i] = nm1-r;
	            this.reverseTable[nm1-r] = nm1-i;
	          }
	          i++;
	        } while (i < halfSize);

	        this.reverseTable[nm1] = nm1;
	      };

	      this.generateReverseTable();
	    }


	    // Ordering of output:
	    //
	    // trans[0]     = re[0] (==zero frequency, purely real)
	    // trans[1]     = re[1]
	    //             ...
	    // trans[n/2-1] = re[n/2-1]
	    // trans[n/2]   = re[n/2]    (==nyquist frequency, purely real)
	    //
	    // trans[n/2+1] = im[n/2-1]
	    // trans[n/2+2] = im[n/2-2]
	    //             ...
	    // trans[n-1]   = im[1] 

	    RFFT.prototype.forward = function(buffer) {
	      var n         = this.bufferSize, 
	          spectrum  = this.spectrum,
	          x         = this.trans, 
	          TWO_PI    = 2*Math.PI,
	          sqrt      = Math.sqrt,
	          i         = n >>> 1,
	          bSi       = 2 / n,
	          n2, n4, n8, nn, 
	          t1, t2, t3, t4, 
	          i1, i2, i3, i4, i5, i6, i7, i8, 
	          st1, cc1, ss1, cc3, ss3,
	          e, 
	          a,
	          rval, ival, mag; 

	      this.reverseBinPermute(x, buffer);

	      /*
	      var reverseTable = this.reverseTable;

	      for (var k = 0, len = reverseTable.length; k < len; k++) {
	        x[k] = buffer[reverseTable[k]];
	      }
	      */

	      for (var ix = 0, id = 4; ix < n; id *= 4) {
	        for (var i0 = ix; i0 < n; i0 += id) {
	          //sumdiff(x[i0], x[i0+1]); // {a, b}  <--| {a+b, a-b}
	          st1 = x[i0] - x[i0+1];
	          x[i0] += x[i0+1];
	          x[i0+1] = st1;
	        } 
	        ix = 2*(id-1);
	      }

	      n2 = 2;
	      nn = n >>> 1;

	      while((nn = nn >>> 1)) {
	        ix = 0;
	        n2 = n2 << 1;
	        id = n2 << 1;
	        n4 = n2 >>> 2;
	        n8 = n2 >>> 3;
	        do {
	          if(n4 !== 1) {
	            for(i0 = ix; i0 < n; i0 += id) {
	              i1 = i0;
	              i2 = i1 + n4;
	              i3 = i2 + n4;
	              i4 = i3 + n4;
	         
	              //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
	              t1 = x[i3] + x[i4];
	              x[i4] -= x[i3];
	              //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
	              x[i3] = x[i1] - t1; 
	              x[i1] += t1;
	         
	              i1 += n8;
	              i2 += n8;
	              i3 += n8;
	              i4 += n8;
	             
	              //sumdiff(x[i3], x[i4], t1, t2); // {s, d}  <--| {a+b, a-b}
	              t1 = x[i3] + x[i4];
	              t2 = x[i3] - x[i4];
	             
	              t1 = -t1 * Math.SQRT1_2;
	              t2 *= Math.SQRT1_2;
	         
	              // sumdiff(t1, x[i2], x[i4], x[i3]); // {s, d}  <--| {a+b, a-b}
	              st1 = x[i2];
	              x[i4] = t1 + st1; 
	              x[i3] = t1 - st1;
	              
	              //sumdiff3(x[i1], t2, x[i2]); // {a, b, d} <--| {a+b, b, a-b}
	              x[i2] = x[i1] - t2;
	              x[i1] += t2;
	            }
	          } else {
	            for(i0 = ix; i0 < n; i0 += id) {
	              i1 = i0;
	              i2 = i1 + n4;
	              i3 = i2 + n4;
	              i4 = i3 + n4;
	         
	              //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
	              t1 = x[i3] + x[i4]; 
	              x[i4] -= x[i3];
	              
	              //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
	              x[i3] = x[i1] - t1; 
	              x[i1] += t1;
	            }
	          }
	       
	          ix = (id << 1) - n2;
	          id = id << 2;
	        } while (ix < n);
	     
	        e = TWO_PI / n2;

	        for (var j = 1; j < n8; j++) {
	          a = j * e;
	          ss1 = Math.sin(a);
	          cc1 = Math.cos(a);

	          //ss3 = sin(3*a); cc3 = cos(3*a);
	          cc3 = 4*cc1*(cc1*cc1-0.75);
	          ss3 = 4*ss1*(0.75-ss1*ss1);
	       
	          ix = 0; id = n2 << 1;
	          do {
	            for (i0 = ix; i0 < n; i0 += id) {
	              i1 = i0 + j;
	              i2 = i1 + n4;
	              i3 = i2 + n4;
	              i4 = i3 + n4;
	           
	              i5 = i0 + n4 - j;
	              i6 = i5 + n4;
	              i7 = i6 + n4;
	              i8 = i7 + n4;
	           
	              //cmult(c, s, x, y, &u, &v)
	              //cmult(cc1, ss1, x[i7], x[i3], t2, t1); // {u,v} <--| {x*c-y*s, x*s+y*c}
	              t2 = x[i7]*cc1 - x[i3]*ss1; 
	              t1 = x[i7]*ss1 + x[i3]*cc1;
	              
	              //cmult(cc3, ss3, x[i8], x[i4], t4, t3);
	              t4 = x[i8]*cc3 - x[i4]*ss3; 
	              t3 = x[i8]*ss3 + x[i4]*cc3;
	           
	              //sumdiff(t2, t4);   // {a, b} <--| {a+b, a-b}
	              st1 = t2 - t4;
	              t2 += t4;
	              t4 = st1;
	              
	              //sumdiff(t2, x[i6], x[i8], x[i3]); // {s, d}  <--| {a+b, a-b}
	              //st1 = x[i6]; x[i8] = t2 + st1; x[i3] = t2 - st1;
	              x[i8] = t2 + x[i6]; 
	              x[i3] = t2 - x[i6];
	             
	              //sumdiff_r(t1, t3); // {a, b} <--| {a+b, b-a}
	              st1 = t3 - t1;
	              t1 += t3;
	              t3 = st1;
	              
	              //sumdiff(t3, x[i2], x[i4], x[i7]); // {s, d}  <--| {a+b, a-b}
	              //st1 = x[i2]; x[i4] = t3 + st1; x[i7] = t3 - st1;
	              x[i4] = t3 + x[i2]; 
	              x[i7] = t3 - x[i2];
	             
	              //sumdiff3(x[i1], t1, x[i6]);   // {a, b, d} <--| {a+b, b, a-b}
	              x[i6] = x[i1] - t1; 
	              x[i1] += t1;
	              
	              //diffsum3_r(t4, x[i5], x[i2]); // {a, b, s} <--| {a, b-a, a+b}
	              x[i2] = t4 + x[i5]; 
	              x[i5] -= t4;
	            }
	         
	            ix = (id << 1) - n2;
	            id = id << 2;
	       
	          } while (ix < n);
	        }
	      }

	      while (--i) {
	        rval = x[i];
	        ival = x[n-i-1];
	        mag = bSi * sqrt(rval * rval + ival * ival);

	        if (mag > this.peak) {
	          this.peakBand = i;
	          this.peak = mag;
	        }

	        spectrum[i] = mag;
	      }

	      spectrum[0] = bSi * x[0];

	      return spectrum;
	    };

	    function Sampler(file, bufferSize, sampleRate, playStart, playEnd, loopStart, loopEnd, loopMode) {
	      this.file = file;
	      this.bufferSize = bufferSize;
	      this.sampleRate = sampleRate;
	      this.playStart  = playStart || 0; // 0%
	      this.playEnd    = playEnd   || 1; // 100%
	      this.loopStart  = loopStart || 0;
	      this.loopEnd    = loopEnd   || 1;
	      this.loopMode   = loopMode  || DSP.OFF;
	      this.loaded     = false;
	      this.samples    = [];
	      this.signal     = new Float32Array(bufferSize);
	      this.frameCount = 0;
	      this.envelope   = null;
	      this.amplitude  = 1;
	      this.rootFrequency = 110; // A2 110
	      this.frequency  = 550;
	      this.step       = this.frequency / this.rootFrequency;
	      this.duration   = 0;
	      this.samplesProcessed = 0;
	      this.playhead   = 0;
	     
	      var audio = /* new Audio();*/ document.createElement("AUDIO");
	      var self = this;
	     
	      this.loadSamples = function(event) {
	        var buffer = DSP.getChannel(DSP.MIX, event.frameBuffer);
	        for ( var i = 0; i < buffer.length; i++) {
	          self.samples.push(buffer[i]);
	        }
	      };
	     
	      this.loadComplete = function() {
	        // convert flexible js array into a fast typed array
	        self.samples = new Float32Array(self.samples);
	        self.loaded = true;
	      };
	     
	      this.loadMetaData = function() {
	        self.duration = audio.duration;
	      };
	     
	      audio.addEventListener("MozAudioAvailable", this.loadSamples, false);
	      audio.addEventListener("loadedmetadata", this.loadMetaData, false);
	      audio.addEventListener("ended", this.loadComplete, false);
	      audio.muted = true;
	      audio.src = file;
	      audio.play();
	    }

	    Sampler.prototype.applyEnvelope = function() {
	      this.envelope.process(this.signal);
	      return this.signal;
	    };

	    Sampler.prototype.generate = function() {
	      var frameOffset = this.frameCount * this.bufferSize;
	     
	      var loopWidth = this.playEnd * this.samples.length - this.playStart * this.samples.length;
	      var playStartSamples = this.playStart * this.samples.length; // ie 0.5 -> 50% of the length
	      var playEndSamples = this.playEnd * this.samples.length; // ie 0.5 -> 50% of the length
	      var offset;

	      for ( var i = 0; i < this.bufferSize; i++ ) {
	        switch (this.loopMode) {
	          case DSP.OFF:
	            this.playhead = Math.round(this.samplesProcessed * this.step + playStartSamples);
	            if (this.playhead < (this.playEnd * this.samples.length) ) {
	              this.signal[i] = this.samples[this.playhead] * this.amplitude;
	            } else {
	              this.signal[i] = 0;
	            }
	            break;
	         
	          case DSP.FW:
	            this.playhead = Math.round((this.samplesProcessed * this.step) % loopWidth + playStartSamples);
	            if (this.playhead < (this.playEnd * this.samples.length) ) {
	              this.signal[i] = this.samples[this.playhead] * this.amplitude;
	            }
	            break;
	           
	          case DSP.BW:
	            this.playhead = playEndSamples - Math.round((this.samplesProcessed * this.step) % loopWidth);
	            if (this.playhead < (this.playEnd * this.samples.length) ) {
	              this.signal[i] = this.samples[this.playhead] * this.amplitude;
	            }
	            break;
	           
	          case DSP.FWBW:
	            if ( Math.floor(this.samplesProcessed * this.step / loopWidth) % 2 === 0 ) {
	              this.playhead = Math.round((this.samplesProcessed * this.step) % loopWidth + playStartSamples);
	            } else {
	              this.playhead = playEndSamples - Math.round((this.samplesProcessed * this.step) % loopWidth);
	            }  
	            if (this.playhead < (this.playEnd * this.samples.length) ) {
	              this.signal[i] = this.samples[this.playhead] * this.amplitude;
	            }
	            break;
	        }
	        this.samplesProcessed++;
	      }

	      this.frameCount++;

	      return this.signal;
	    };

	    Sampler.prototype.setFreq = function(frequency) {
	        var totalProcessed = this.samplesProcessed * this.step;
	        this.frequency = frequency;
	        this.step = this.frequency / this.rootFrequency;
	        this.samplesProcessed = Math.round(totalProcessed/this.step);
	    };

	    Sampler.prototype.reset = function() {
	      this.samplesProcessed = 0;
	      this.playhead = 0;
	    };

	    /**
	     * Oscillator class for generating and modifying signals
	     *
	     * @param {Number} type       A waveform constant (eg. DSP.SINE)
	     * @param {Number} frequency  Initial frequency of the signal
	     * @param {Number} amplitude  Initial amplitude of the signal
	     * @param {Number} bufferSize Size of the sample buffer to generate
	     * @param {Number} sampleRate The sample rate of the signal
	     *
	     * @contructor
	     */
	    function Oscillator(type, frequency, amplitude, bufferSize, sampleRate) {
	      this.frequency  = frequency;
	      this.amplitude  = amplitude;
	      this.bufferSize = bufferSize;
	      this.sampleRate = sampleRate;
	      //this.pulseWidth = pulseWidth;
	      this.frameCount = 0;
	     
	      this.waveTableLength = 2048;

	      this.cyclesPerSample = frequency / sampleRate;

	      this.signal = new Float32Array(bufferSize);
	      this.envelope = null;

	      switch(parseInt(type, 10)) {
	        case DSP.TRIANGLE:
	          this.func = Oscillator.Triangle;
	          break;

	        case DSP.SAW:
	          this.func = Oscillator.Saw;
	          break;

	        case DSP.SQUARE:
	          this.func = Oscillator.Square;
	          break;

	        default:
	        case DSP.SINE:
	          this.func = Oscillator.Sine;
	          break;
	      }

	      this.generateWaveTable = function() {
	        Oscillator.waveTable[this.func] = new Float32Array(2048);
	        var waveTableTime = this.waveTableLength / this.sampleRate;
	        var waveTableHz = 1 / waveTableTime;

	        for (var i = 0; i < this.waveTableLength; i++) {
	          Oscillator.waveTable[this.func][i] = this.func(i * waveTableHz/this.sampleRate);
	        }
	      };

	      if ( typeof Oscillator.waveTable === 'undefined' ) {
	        Oscillator.waveTable = {};
	      }

	      if ( typeof Oscillator.waveTable[this.func] === 'undefined' ) {
	        this.generateWaveTable();
	      }
	     
	      this.waveTable = Oscillator.waveTable[this.func];
	    }

	    /**
	     * Set the amplitude of the signal
	     *
	     * @param {Number} amplitude The amplitude of the signal (between 0 and 1)
	     */
	    Oscillator.prototype.setAmp = function(amplitude) {
	      if (amplitude >= 0 && amplitude <= 1) {
	        this.amplitude = amplitude;
	      } else {
	        throw "Amplitude out of range (0..1).";
	      }
	    };
	      
	    /**
	     * Set the frequency of the signal
	     *
	     * @param {Number} frequency The frequency of the signal
	     */  
	    Oscillator.prototype.setFreq = function(frequency) {
	      this.frequency = frequency;
	      this.cyclesPerSample = frequency / this.sampleRate;
	    };
	         
	    // Add an oscillator
	    Oscillator.prototype.add = function(oscillator) {
	      for ( var i = 0; i < this.bufferSize; i++ ) {
	        //this.signal[i] += oscillator.valueAt(i);
	        this.signal[i] += oscillator.signal[i];
	      }
	     
	      return this.signal;
	    };
	         
	    // Add a signal to the current generated osc signal
	    Oscillator.prototype.addSignal = function(signal) {
	      for ( var i = 0; i < signal.length; i++ ) {
	        if ( i >= this.bufferSize ) {
	          break;
	        }
	        this.signal[i] += signal[i];
	       
	        /*
	        // Constrain amplitude
	        if ( this.signal[i] > 1 ) {
	          this.signal[i] = 1;
	        } else if ( this.signal[i] < -1 ) {
	          this.signal[i] = -1;
	        }
	        */
	      }
	      return this.signal;
	    };
	         
	    // Add an envelope to the oscillator
	    Oscillator.prototype.addEnvelope = function(envelope) {
	      this.envelope = envelope;
	    };

	    Oscillator.prototype.applyEnvelope = function() {
	      this.envelope.process(this.signal);
	    };
	         
	    Oscillator.prototype.valueAt = function(offset) {
	      return this.waveTable[offset % this.waveTableLength];
	    };
	         
	    Oscillator.prototype.generate = function() {
	      var frameOffset = this.frameCount * this.bufferSize;
	      var step = this.waveTableLength * this.frequency / this.sampleRate;
	      var offset;

	      for ( var i = 0; i < this.bufferSize; i++ ) {
	        //var step = (frameOffset + i) * this.cyclesPerSample % 1;
	        //this.signal[i] = this.func(step) * this.amplitude;
	        //this.signal[i] = this.valueAt(Math.round((frameOffset + i) * step)) * this.amplitude;
	        offset = Math.round((frameOffset + i) * step);
	        this.signal[i] = this.waveTable[offset % this.waveTableLength] * this.amplitude;
	      }

	      this.frameCount++;

	      return this.signal;
	    };

	    Oscillator.Sine = function(step) {
	      return Math.sin(DSP.TWO_PI * step);
	    };

	    Oscillator.Square = function(step) {
	      return step < 0.5 ? 1 : -1;
	    };

	    Oscillator.Saw = function(step) {
	      return 2 * (step - Math.round(step));
	    };

	    Oscillator.Triangle = function(step) {
	      return 1 - 4 * Math.abs(Math.round(step) - step);
	    };

	    Oscillator.Pulse = function(step) {
	      // stub
	    };
	     
	    function ADSR(attackLength, decayLength, sustainLevel, sustainLength, releaseLength, sampleRate) {
	      this.sampleRate = sampleRate;
	      // Length in seconds
	      this.attackLength  = attackLength;
	      this.decayLength   = decayLength;
	      this.sustainLevel  = sustainLevel;
	      this.sustainLength = sustainLength;
	      this.releaseLength = releaseLength;
	      this.sampleRate    = sampleRate;
	     
	      // Length in samples
	      this.attackSamples  = attackLength  * sampleRate;
	      this.decaySamples   = decayLength   * sampleRate;
	      this.sustainSamples = sustainLength * sampleRate;
	      this.releaseSamples = releaseLength * sampleRate;
	     
	      // Updates the envelope sample positions
	      this.update = function() {
	        this.attack         =                this.attackSamples;
	        this.decay          = this.attack  + this.decaySamples;
	        this.sustain        = this.decay   + this.sustainSamples;
	        this.release        = this.sustain + this.releaseSamples;
	      };
	     
	      this.update();
	     
	      this.samplesProcessed = 0;
	    }

	    ADSR.prototype.noteOn = function() {
	      this.samplesProcessed = 0;
	      this.sustainSamples = this.sustainLength * this.sampleRate;
	      this.update();
	    };

	    // Send a note off when using a sustain of infinity to let the envelope enter the release phase
	    ADSR.prototype.noteOff = function() {
	      this.sustainSamples = this.samplesProcessed - this.decaySamples;
	      this.update();
	    };

	    ADSR.prototype.processSample = function(sample) {
	      var amplitude = 0;

	      if ( this.samplesProcessed <= this.attack ) {
	        amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
	      } else if ( this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay ) {
	        amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
	      } else if ( this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain ) {
	        amplitude = this.sustainLevel;
	      } else if ( this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release ) {
	        amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
	      }
	     
	      return sample * amplitude;
	    };

	    ADSR.prototype.value = function() {
	      var amplitude = 0;

	      if ( this.samplesProcessed <= this.attack ) {
	        amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
	      } else if ( this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay ) {
	        amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
	      } else if ( this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain ) {
	        amplitude = this.sustainLevel;
	      } else if ( this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release ) {
	        amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
	      }
	     
	      return amplitude;
	    };
	         
	    ADSR.prototype.process = function(buffer) {
	      for ( var i = 0; i < buffer.length; i++ ) {
	        buffer[i] *= this.value();

	        this.samplesProcessed++;
	      }
	     
	      return buffer;
	    };
	         
	         
	    ADSR.prototype.isActive = function() {
	      if ( this.samplesProcessed > this.release || this.samplesProcessed === -1 ) {
	        return false;
	      } else {
	        return true;
	      }
	    };

	    ADSR.prototype.disable = function() {
	      this.samplesProcessed = -1;
	    };
	     
	    function IIRFilter(type, cutoff, resonance, sampleRate) {
	      this.sampleRate = sampleRate;

	      switch(type) {
	        case DSP.LOWPASS:
	        case DSP.LP12:
	          this.func = new IIRFilter.LP12(cutoff, resonance, sampleRate);
	          break;
	      }
	    }

	    IIRFilter.prototype.__defineGetter__('cutoff',
	      function() {
	        return this.func.cutoff;
	      }
	    );

	    IIRFilter.prototype.__defineGetter__('resonance',
	      function() {
	        return this.func.resonance;
	      }
	    );

	    IIRFilter.prototype.set = function(cutoff, resonance) {
	      this.func.calcCoeff(cutoff, resonance);
	    };

	    IIRFilter.prototype.process = function(buffer) {
	      this.func.process(buffer);
	    };

	    // Add an envelope to the filter
	    IIRFilter.prototype.addEnvelope = function(envelope) {
	      if ( envelope instanceof ADSR ) {
	        this.func.addEnvelope(envelope);
	      } else {
	        throw "Not an envelope.";
	      }
	    };

	    IIRFilter.LP12 = function(cutoff, resonance, sampleRate) {
	      this.sampleRate = sampleRate;
	      this.vibraPos   = 0;
	      this.vibraSpeed = 0;
	      this.envelope = false;
	     
	      this.calcCoeff = function(cutoff, resonance) {
	        this.w = 2.0 * Math.PI * cutoff / this.sampleRate;
	        this.q = 1.0 - this.w / (2.0 * (resonance + 0.5 / (1.0 + this.w)) + this.w - 2.0);
	        this.r = this.q * this.q;
	        this.c = this.r + 1.0 - 2.0 * Math.cos(this.w) * this.q;
	       
	        this.cutoff = cutoff;
	        this.resonance = resonance;
	      };

	      this.calcCoeff(cutoff, resonance);

	      this.process = function(buffer) {
	        for ( var i = 0; i < buffer.length; i++ ) {
	          this.vibraSpeed += (buffer[i] - this.vibraPos) * this.c;
	          this.vibraPos   += this.vibraSpeed;
	          this.vibraSpeed *= this.r;
	       
	          /*
	          var temp = this.vibraPos;
	         
	          if ( temp > 1.0 ) {
	            temp = 1.0;
	          } else if ( temp < -1.0 ) {
	            temp = -1.0;
	          } else if ( temp != temp ) {
	            temp = 1;
	          }
	         
	          buffer[i] = temp;
	          */

	          if (this.envelope) {
	            buffer[i] = (buffer[i] * (1 - this.envelope.value())) + (this.vibraPos * this.envelope.value());
	            this.envelope.samplesProcessed++;
	          } else {
	            buffer[i] = this.vibraPos;
	          }
	        }
	      };
	    }; 

	    IIRFilter.LP12.prototype.addEnvelope = function(envelope) {
	      this.envelope = envelope;
	    };

	    function IIRFilter2(type, cutoff, resonance, sampleRate) {
	      this.type = type;
	      this.cutoff = cutoff;
	      this.resonance = resonance;
	      this.sampleRate = sampleRate;

	      this.f = Float32Array(4);
	      this.f[0] = 0.0; // lp
	      this.f[1] = 0.0; // hp
	      this.f[2] = 0.0; // bp
	      this.f[3] = 0.0; // br 
	     
	      this.calcCoeff = function(cutoff, resonance) {
	        this.freq = 2 * Math.sin(Math.PI * Math.min(0.25, cutoff/(this.sampleRate*2)));  
	        this.damp = Math.min(2 * (1 - Math.pow(resonance, 0.25)), Math.min(2, 2/this.freq - this.freq * 0.5));
	      };

	      this.calcCoeff(cutoff, resonance);
	    }

	    IIRFilter2.prototype.process = function(buffer) {
	      var input, output;
	      var f = this.f;

	      for ( var i = 0; i < buffer.length; i++ ) {
	        input = buffer[i];

	        // first pass
	        f[3] = input - this.damp * f[2];
	        f[0] = f[0] + this.freq * f[2];
	        f[1] = f[3] - f[0];
	        f[2] = this.freq * f[1] + f[2];
	        output = 0.5 * f[this.type];

	        // second pass
	        f[3] = input - this.damp * f[2];
	        f[0] = f[0] + this.freq * f[2];
	        f[1] = f[3] - f[0];
	        f[2] = this.freq * f[1] + f[2];
	        output += 0.5 * f[this.type];

	        if (this.envelope) {
	          buffer[i] = (buffer[i] * (1 - this.envelope.value())) + (output * this.envelope.value());
	          this.envelope.samplesProcessed++;
	        } else {
	          buffer[i] = output;
	        }
	      }
	    };

	    IIRFilter2.prototype.addEnvelope = function(envelope) {
	      if ( envelope instanceof ADSR ) {
	        this.envelope = envelope;
	      } else {
	        throw "This is not an envelope.";
	      }
	    };

	    IIRFilter2.prototype.set = function(cutoff, resonance) {
	      this.calcCoeff(cutoff, resonance);
	    };



	    function WindowFunction(type, alpha) {
	      this.alpha = alpha;
	     
	      switch(type) {
	        case DSP.BARTLETT:
	          this.func = WindowFunction.Bartlett;
	          break;
	         
	        case DSP.BARTLETTHANN:
	          this.func = WindowFunction.BartlettHann;
	          break;
	         
	        case DSP.BLACKMAN:
	          this.func = WindowFunction.Blackman;
	          this.alpha = this.alpha || 0.16;
	          break;
	       
	        case DSP.COSINE:
	          this.func = WindowFunction.Cosine;
	          break;
	         
	        case DSP.GAUSS:
	          this.func = WindowFunction.Gauss;
	          this.alpha = this.alpha || 0.25;
	          break;
	         
	        case DSP.HAMMING:
	          this.func = WindowFunction.Hamming;
	          break;
	         
	        case DSP.HANN:
	          this.func = WindowFunction.Hann;
	          break;
	       
	        case DSP.LANCZOS:
	          this.func = WindowFunction.Lanczoz;
	          break;
	         
	        case DSP.RECTANGULAR:
	          this.func = WindowFunction.Rectangular;
	          break;
	         
	        case DSP.TRIANGULAR:
	          this.func = WindowFunction.Triangular;
	          break;
	      }
	    }

	    WindowFunction.prototype.process = function(buffer) {
	      var length = buffer.length;
	      for ( var i = 0; i < length; i++ ) {
	        buffer[i] *= this.func(length, i, this.alpha);
	      }
	      return buffer;
	    };

	    WindowFunction.Bartlett = function(length, index) {
	      return 2 / (length - 1) * ((length - 1) / 2 - Math.abs(index - (length - 1) / 2));
	    };

	    WindowFunction.BartlettHann = function(length, index) {
	      return 0.62 - 0.48 * Math.abs(index / (length - 1) - 0.5) - 0.38 * Math.cos(DSP.TWO_PI * index / (length - 1));
	    };

	    WindowFunction.Blackman = function(length, index, alpha) {
	      var a0 = (1 - alpha) / 2;
	      var a1 = 0.5;
	      var a2 = alpha / 2;

	      return a0 - a1 * Math.cos(DSP.TWO_PI * index / (length - 1)) + a2 * Math.cos(4 * Math.PI * index / (length - 1));
	    };

	    WindowFunction.Cosine = function(length, index) {
	      return Math.cos(Math.PI * index / (length - 1) - Math.PI / 2);
	    };

	    WindowFunction.Gauss = function(length, index, alpha) {
	      return Math.pow(Math.E, -0.5 * Math.pow((index - (length - 1) / 2) / (alpha * (length - 1) / 2), 2));
	    };

	    WindowFunction.Hamming = function(length, index) {
	      return 0.54 - 0.46 * Math.cos(DSP.TWO_PI * index / (length - 1));
	    };

	    WindowFunction.Hann = function(length, index) {
	      return 0.5 * (1 - Math.cos(DSP.TWO_PI * index / (length - 1)));
	    };

	    WindowFunction.Lanczos = function(length, index) {
	      var x = 2 * index / (length - 1) - 1;
	      return Math.sin(Math.PI * x) / (Math.PI * x);
	    };

	    WindowFunction.Rectangular = function(length, index) {
	      return 1;
	    };

	    WindowFunction.Triangular = function(length, index) {
	      return 2 / length * (length / 2 - Math.abs(index - (length - 1) / 2));
	    };

	    function sinh (arg) {
	      // Returns the hyperbolic sine of the number, defined as (exp(number) - exp(-number))/2 
	      //
	      // version: 1004.2314
	      // discuss at: http://phpjs.org/functions/sinh    // +   original by: Onno Marsman
	      // *     example 1: sinh(-0.9834330348825909);
	      // *     returns 1: -1.1497971402636502
	      return (Math.exp(arg) - Math.exp(-arg))/2;
	    }

	    /* 
	     *  Biquad filter
	     * 
	     *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
	     *  Copyright 2010 Ricard Marxer. All rights reserved.
	     *
	     */
	    // Implementation based on:
	    // http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
	    function Biquad(type, sampleRate) {
	      this.Fs = sampleRate;
	      this.type = type;  // type of the filter
	      this.parameterType = DSP.Q; // type of the parameter

	      this.x_1_l = 0;
	      this.x_2_l = 0;
	      this.y_1_l = 0;
	      this.y_2_l = 0;

	      this.x_1_r = 0;
	      this.x_2_r = 0;
	      this.y_1_r = 0;
	      this.y_2_r = 0;

	      this.b0 = 1;
	      this.a0 = 1;

	      this.b1 = 0;
	      this.a1 = 0;

	      this.b2 = 0;
	      this.a2 = 0;

	      this.b0a0 = this.b0 / this.a0;
	      this.b1a0 = this.b1 / this.a0;
	      this.b2a0 = this.b2 / this.a0;
	      this.a1a0 = this.a1 / this.a0;
	      this.a2a0 = this.a2 / this.a0;

	      this.f0 = 3000;   // "wherever it's happenin', man."  Center Frequency or
	                        // Corner Frequency, or shelf midpoint frequency, depending
	                        // on which filter type.  The "significant frequency".

	      this.dBgain = 12; // used only for peaking and shelving filters

	      this.Q = 1;       // the EE kind of definition, except for peakingEQ in which A*Q is
	                        // the classic EE Q.  That adjustment in definition was made so that
	                        // a boost of N dB followed by a cut of N dB for identical Q and
	                        // f0/Fs results in a precisely flat unity gain filter or "wire".

	      this.BW = -3;     // the bandwidth in octaves (between -3 dB frequencies for BPF
	                        // and notch or between midpoint (dBgain/2) gain frequencies for
	                        // peaking EQ

	      this.S = 1;       // a "shelf slope" parameter (for shelving EQ only).  When S = 1,
	                        // the shelf slope is as steep as it can be and remain monotonically
	                        // increasing or decreasing gain with frequency.  The shelf slope, in
	                        // dB/octave, remains proportional to S for all other values for a
	                        // fixed f0/Fs and dBgain.

	      this.coefficients = function() {
	        var b = [this.b0, this.b1, this.b2];
	        var a = [this.a0, this.a1, this.a2];
	        return {b: b, a:a};
	      };

	      this.setFilterType = function(type) {
	        this.type = type;
	        this.recalculateCoefficients();
	      };

	      this.setSampleRate = function(rate) {
	        this.Fs = rate;
	        this.recalculateCoefficients();
	      };

	      this.setQ = function(q) {
	        this.parameterType = DSP.Q;
	        this.Q = Math.max(Math.min(q, 115.0), 0.001);
	        this.recalculateCoefficients();
	      };

	      this.setBW = function(bw) {
	        this.parameterType = DSP.BW;
	        this.BW = bw;
	        this.recalculateCoefficients();
	      };

	      this.setS = function(s) {
	        this.parameterType = DSP.S;
	        this.S = Math.max(Math.min(s, 5.0), 0.0001);
	        this.recalculateCoefficients();
	      };

	      this.setF0 = function(freq) {
	        this.f0 = freq;
	        this.recalculateCoefficients();
	      }; 
	     
	      this.setDbGain = function(g) {
	        this.dBgain = g;
	        this.recalculateCoefficients();
	      };

	      this.recalculateCoefficients = function() {
	        var A;
	        if (type === DSP.PEAKING_EQ || type === DSP.LOW_SHELF || type === DSP.HIGH_SHELF ) {
	          A = Math.pow(10, (this.dBgain/40));  // for peaking and shelving EQ filters only
	        } else {
	          A  = Math.sqrt( Math.pow(10, (this.dBgain/20)) );   
	        }

	        var w0 = DSP.TWO_PI * this.f0 / this.Fs;

	        var cosw0 = Math.cos(w0);
	        var sinw0 = Math.sin(w0);

	        var alpha = 0;
	       
	        switch (this.parameterType) {
	          case DSP.Q:
	            alpha = sinw0/(2*this.Q);
	            break;
	               
	          case DSP.BW:
	            alpha = sinw0 * sinh( Math.LN2/2 * this.BW * w0/sinw0 );
	            break;

	          case DSP.S:
	            alpha = sinw0/2 * Math.sqrt( (A + 1/A)*(1/this.S - 1) + 2 );
	            break;
	        }

	        /**
	            FYI: The relationship between bandwidth and Q is
	                 1/Q = 2*sinh(ln(2)/2*BW*w0/sin(w0))     (digital filter w BLT)
	            or   1/Q = 2*sinh(ln(2)/2*BW)             (analog filter prototype)

	            The relationship between shelf slope and Q is
	                 1/Q = sqrt((A + 1/A)*(1/S - 1) + 2)
	        */

	        var coeff;

	        switch (this.type) {
	          case DSP.LPF:       // H(s) = 1 / (s^2 + s/Q + 1)
	            this.b0 =  (1 - cosw0)/2;
	            this.b1 =   1 - cosw0;
	            this.b2 =  (1 - cosw0)/2;
	            this.a0 =   1 + alpha;
	            this.a1 =  -2 * cosw0;
	            this.a2 =   1 - alpha;
	            break;

	          case DSP.HPF:       // H(s) = s^2 / (s^2 + s/Q + 1)
	            this.b0 =  (1 + cosw0)/2;
	            this.b1 = -(1 + cosw0);
	            this.b2 =  (1 + cosw0)/2;
	            this.a0 =   1 + alpha;
	            this.a1 =  -2 * cosw0;
	            this.a2 =   1 - alpha;
	            break;

	          case DSP.BPF_CONSTANT_SKIRT:       // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
	            this.b0 =   sinw0/2;
	            this.b1 =   0;
	            this.b2 =  -sinw0/2;
	            this.a0 =   1 + alpha;
	            this.a1 =  -2*cosw0;
	            this.a2 =   1 - alpha;
	            break;

	          case DSP.BPF_CONSTANT_PEAK:       // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
	            this.b0 =   alpha;
	            this.b1 =   0;
	            this.b2 =  -alpha;
	            this.a0 =   1 + alpha;
	            this.a1 =  -2*cosw0;
	            this.a2 =   1 - alpha;
	            break;

	          case DSP.NOTCH:     // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
	            this.b0 =   1;
	            this.b1 =  -2*cosw0;
	            this.b2 =   1;
	            this.a0 =   1 + alpha;
	            this.a1 =  -2*cosw0;
	            this.a2 =   1 - alpha;
	            break;

	          case DSP.APF:       // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
	            this.b0 =   1 - alpha;
	            this.b1 =  -2*cosw0;
	            this.b2 =   1 + alpha;
	            this.a0 =   1 + alpha;
	            this.a1 =  -2*cosw0;
	            this.a2 =   1 - alpha;
	            break;

	          case DSP.PEAKING_EQ:  // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
	            this.b0 =   1 + alpha*A;
	            this.b1 =  -2*cosw0;
	            this.b2 =   1 - alpha*A;
	            this.a0 =   1 + alpha/A;
	            this.a1 =  -2*cosw0;
	            this.a2 =   1 - alpha/A;
	            break;

	          case DSP.LOW_SHELF:   // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
	            coeff = sinw0 * Math.sqrt( (A^2 + 1)*(1/this.S - 1) + 2*A );
	            this.b0 =    A*((A+1) - (A-1)*cosw0 + coeff);
	            this.b1 =  2*A*((A-1) - (A+1)*cosw0);
	            this.b2 =    A*((A+1) - (A-1)*cosw0 - coeff);
	            this.a0 =       (A+1) + (A-1)*cosw0 + coeff;
	            this.a1 =   -2*((A-1) + (A+1)*cosw0);
	            this.a2 =       (A+1) + (A-1)*cosw0 - coeff;
	            break;

	          case DSP.HIGH_SHELF:   // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)
	            coeff = sinw0 * Math.sqrt( (A^2 + 1)*(1/this.S - 1) + 2*A );
	            this.b0 =    A*((A+1) + (A-1)*cosw0 + coeff);
	            this.b1 = -2*A*((A-1) + (A+1)*cosw0);
	            this.b2 =    A*((A+1) + (A-1)*cosw0 - coeff);
	            this.a0 =       (A+1) - (A-1)*cosw0 + coeff;
	            this.a1 =    2*((A-1) - (A+1)*cosw0);
	            this.a2 =       (A+1) - (A-1)*cosw0 - coeff;
	            break;
	        }
	       
	        this.b0a0 = this.b0/this.a0;
	        this.b1a0 = this.b1/this.a0;
	        this.b2a0 = this.b2/this.a0;
	        this.a1a0 = this.a1/this.a0;
	        this.a2a0 = this.a2/this.a0;
	      };

	      this.process = function(buffer) {
	          //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
	          //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

	          var len = buffer.length;
	          var output = new Float32Array(len);

	          for ( var i=0; i<buffer.length; i++ ) {
	            output[i] = this.b0a0*buffer[i] + this.b1a0*this.x_1_l + this.b2a0*this.x_2_l - this.a1a0*this.y_1_l - this.a2a0*this.y_2_l;
	            this.y_2_l = this.y_1_l;
	            this.y_1_l = output[i];
	            this.x_2_l = this.x_1_l;
	            this.x_1_l = buffer[i];
	          }

	          return output;
	      };

	      this.processStereo = function(buffer) {
	          //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
	          //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

	          var len = buffer.length;
	          var output = new Float32Array(len);
	         
	          for (var i = 0; i < len/2; i++) {
	            output[2*i] = this.b0a0*buffer[2*i] + this.b1a0*this.x_1_l + this.b2a0*this.x_2_l - this.a1a0*this.y_1_l - this.a2a0*this.y_2_l;
	            this.y_2_l = this.y_1_l;
	            this.y_1_l = output[2*i];
	            this.x_2_l = this.x_1_l;
	            this.x_1_l = buffer[2*i];

	            output[2*i+1] = this.b0a0*buffer[2*i+1] + this.b1a0*this.x_1_r + this.b2a0*this.x_2_r - this.a1a0*this.y_1_r - this.a2a0*this.y_2_r;
	            this.y_2_r = this.y_1_r;
	            this.y_1_r = output[2*i+1];
	            this.x_2_r = this.x_1_r;
	            this.x_1_r = buffer[2*i+1];
	          }

	          return output;
	      };
	    }

	    /* 
	     *  Magnitude to decibels
	     * 
	     *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
	     *  Copyright 2010 Ricard Marxer. All rights reserved.
	     *
	     *  @buffer array of magnitudes to convert to decibels
	     *
	     *  @returns the array in decibels
	     *
	     */
	    DSP.mag2db = function(buffer) {
	      var minDb = -120;
	      var minMag = Math.pow(10.0, minDb / 20.0);

	      var log = Math.log;
	      var max = Math.max;
	     
	      var result = Float32Array(buffer.length);
	      for (var i=0; i<buffer.length; i++) {
	        result[i] = 20.0*log(max(buffer[i], minMag));
	      }

	      return result;
	    };

	    /* 
	     *  Frequency response
	     * 
	     *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
	     *  Copyright 2010 Ricard Marxer. All rights reserved.
	     *
	     *  Calculates the frequency response at the given points.
	     *
	     *  @b b coefficients of the filter
	     *  @a a coefficients of the filter
	     *  @w w points (normally between -PI and PI) where to calculate the frequency response
	     *
	     *  @returns the frequency response in magnitude
	     *
	     */
	    DSP.freqz = function(b, a, w) {
	      var i, j;

	      if (!w) {
	        w = Float32Array(200);
	        for (i=0;i<w.length; i++) {
	          w[i] = DSP.TWO_PI/w.length * i - Math.PI;
	        }
	      }

	      var result = Float32Array(w.length);
	     
	      var sqrt = Math.sqrt;
	      var cos = Math.cos;
	      var sin = Math.sin;
	     
	      for (i=0; i<w.length; i++) {
	        var numerator = {real:0.0, imag:0.0};
	        for (j=0; j<b.length; j++) {
	          numerator.real += b[j] * cos(-j*w[i]);
	          numerator.imag += b[j] * sin(-j*w[i]);
	        }

	        var denominator = {real:0.0, imag:0.0};
	        for (j=0; j<a.length; j++) {
	          denominator.real += a[j] * cos(-j*w[i]);
	          denominator.imag += a[j] * sin(-j*w[i]);
	        }
	     
	        result[i] =  sqrt(numerator.real*numerator.real + numerator.imag*numerator.imag) / sqrt(denominator.real*denominator.real + denominator.imag*denominator.imag);
	      }

	      return result;
	    };

	    /* 
	     *  Graphical Equalizer
	     *
	     *  Implementation of a graphic equalizer with a configurable bands-per-octave
	     *  and minimum and maximum frequencies
	     * 
	     *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
	     *  Copyright 2010 Ricard Marxer. All rights reserved.
	     *
	     */
	    function GraphicalEq(sampleRate) {
	      this.FS = sampleRate;
	      this.minFreq = 40.0;
	      this.maxFreq = 16000.0;

	      this.bandsPerOctave = 1.0;

	      this.filters = [];
	      this.freqzs = [];

	      this.calculateFreqzs = true;

	      this.recalculateFilters = function() {
	        var bandCount = Math.round(Math.log(this.maxFreq/this.minFreq) * this.bandsPerOctave/ Math.LN2);

	        this.filters = [];
	        for (var i=0; i<bandCount; i++) {
	          var freq = this.minFreq*(Math.pow(2, i/this.bandsPerOctave));
	          var newFilter = new Biquad(DSP.PEAKING_EQ, this.FS);
	          newFilter.setDbGain(0);
	          newFilter.setBW(1/this.bandsPerOctave);
	          newFilter.setF0(freq);
	          this.filters[i] = newFilter;
	          this.recalculateFreqz(i);
	        }
	      };

	      this.setMinimumFrequency = function(freq) {
	        this.minFreq = freq;
	        this.recalculateFilters();
	      };

	      this.setMaximumFrequency = function(freq) {
	        this.maxFreq = freq;
	        this.recalculateFilters();
	      };

	      this.setBandsPerOctave = function(bands) {
	        this.bandsPerOctave = bands;
	        this.recalculateFilters();
	      };

	      this.setBandGain = function(bandIndex, gain) {
	        if (bandIndex < 0 || bandIndex > (this.filters.length-1)) {
	          throw "The band index of the graphical equalizer is out of bounds.";
	        }

	        if (!gain) {
	          throw "A gain must be passed.";
	        }
	       
	        this.filters[bandIndex].setDbGain(gain);
	        this.recalculateFreqz(bandIndex);
	      };
	     
	      this.recalculateFreqz = function(bandIndex) {
	        if (!this.calculateFreqzs) {
	          return;
	        }

	        if (bandIndex < 0 || bandIndex > (this.filters.length-1)) {
	          throw "The band index of the graphical equalizer is out of bounds. " + bandIndex + " is out of [" + 0 + ", " + this.filters.length-1 + "]";
	        }
	           
	        if (!this.w) {
	          this.w = Float32Array(400);
	          for (var i=0; i<this.w.length; i++) {
	             this.w[i] = Math.PI/this.w.length * i;
	          }
	        }
	       
	        var b = [this.filters[bandIndex].b0, this.filters[bandIndex].b1, this.filters[bandIndex].b2];
	        var a = [this.filters[bandIndex].a0, this.filters[bandIndex].a1, this.filters[bandIndex].a2];

	        this.freqzs[bandIndex] = DSP.mag2db(DSP.freqz(b, a, this.w));
	      };

	      this.process = function(buffer) {
	        var output = buffer;

	        for (var i = 0; i < this.filters.length; i++) {
	          output = this.filters[i].process(output);
	        }

	        return output;
	      };

	      this.processStereo = function(buffer) {
	        var output = buffer;

	        for (var i = 0; i < this.filters.length; i++) {
	          output = this.filters[i].processStereo(output);
	        }

	        return output;
	      };
	    }

	    /**
	     * MultiDelay effect by Almer Thie (http://code.almeros.com).
	     * Copyright 2010 Almer Thie. All rights reserved.
	     * Example: http://code.almeros.com/code-examples/delay-firefox-audio-api/
	     *
	     * This is a delay that feeds it's own delayed signal back into its circular
	     * buffer. Also known as a CombFilter.
	     *
	     * Compatible with interleaved stereo (or more channel) buffers and
	     * non-interleaved mono buffers.
	     *
	     * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
	     * @param {Number} delayInSamples Initial delay in samples
	     * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     *
	     * @constructor
	     */
	    function MultiDelay(maxDelayInSamplesSize, delayInSamples, masterVolume, delayVolume) {
	      this.delayBufferSamples   = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
	      this.delayInputPointer     = delayInSamples;
	      this.delayOutputPointer   = 0;
	     
	      this.delayInSamples   = delayInSamples;
	      this.masterVolume     = masterVolume;
	      this.delayVolume     = delayVolume;
	    }

	    /**
	     * Change the delay time in samples.
	     *
	     * @param {Number} delayInSamples Delay in samples
	     */
	    MultiDelay.prototype.setDelayInSamples = function (delayInSamples) {
	      this.delayInSamples = delayInSamples;
	     
	      this.delayInputPointer = this.delayOutputPointer + delayInSamples;

	      if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
	        this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length; 
	      }
	    };

	    /**
	     * Change the master volume.
	     *
	     * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     */
	    MultiDelay.prototype.setMasterVolume = function(masterVolume) {
	      this.masterVolume = masterVolume;
	    };

	    /**
	     * Change the delay feedback volume.
	     *
	     * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     */
	    MultiDelay.prototype.setDelayVolume = function(delayVolume) {
	      this.delayVolume = delayVolume;
	    };

	    /**
	     * Process a given interleaved or mono non-interleaved float value Array and adds the delayed audio.
	     *
	     * @param {Array} samples Array containing Float values or a Float32Array
	     *
	     * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
	     */
	    MultiDelay.prototype.process = function(samples) {
	      // NB. Make a copy to put in the output samples to return.
	      var outputSamples = new Float32Array(samples.length);

	      for (var i=0; i<samples.length; i++) {
	        // delayBufferSamples could contain initial NULL's, return silence in that case
	        var delaySample = (this.delayBufferSamples[this.delayOutputPointer] === null ? 0.0 : this.delayBufferSamples[this.delayOutputPointer]);
	       
	        // Mix normal audio data with delayed audio
	        var sample = (delaySample * this.delayVolume) + samples[i];
	       
	        // Add audio data with the delay in the delay buffer
	        this.delayBufferSamples[this.delayInputPointer] = sample;
	       
	        // Return the audio with delay mix
	        outputSamples[i] = sample * this.masterVolume;
	       
	        // Manage circulair delay buffer pointers
	        this.delayInputPointer++;
	        if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
	          this.delayInputPointer = 0;
	        }
	         
	        this.delayOutputPointer++;
	        if (this.delayOutputPointer >= this.delayBufferSamples.length-1) {
	          this.delayOutputPointer = 0; 
	        } 
	      }
	     
	      return outputSamples;
	    };

	    /**
	     * SingleDelay effect by Almer Thie (http://code.almeros.com).
	     * Copyright 2010 Almer Thie. All rights reserved.
	     * Example: See usage in Reverb class
	     *
	     * This is a delay that does NOT feeds it's own delayed signal back into its 
	     * circular buffer, neither does it return the original signal. Also known as
	     * an AllPassFilter(?).
	     *
	     * Compatible with interleaved stereo (or more channel) buffers and
	     * non-interleaved mono buffers.
	     *
	     * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
	     * @param {Number} delayInSamples Initial delay in samples
	     * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     *
	     * @constructor
	     */

	    function SingleDelay(maxDelayInSamplesSize, delayInSamples, delayVolume) {
	      this.delayBufferSamples = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
	      this.delayInputPointer  = delayInSamples;
	      this.delayOutputPointer = 0;
	     
	      this.delayInSamples     = delayInSamples;
	      this.delayVolume        = delayVolume;
	    }

	    /**
	     * Change the delay time in samples.
	     *
	     * @param {Number} delayInSamples Delay in samples
	     */
	    SingleDelay.prototype.setDelayInSamples = function(delayInSamples) {
	      this.delayInSamples = delayInSamples;
	      this.delayInputPointer = this.delayOutputPointer + delayInSamples;

	      if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
	        this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length; 
	      }
	    };

	    /**
	     * Change the return signal volume.
	     *
	     * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     */
	    SingleDelay.prototype.setDelayVolume = function(delayVolume) {
	      this.delayVolume = delayVolume;
	    };

	    /**
	     * Process a given interleaved or mono non-interleaved float value Array and
	     * returns the delayed audio.
	     *
	     * @param {Array} samples Array containing Float values or a Float32Array
	     *
	     * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
	     */
	    SingleDelay.prototype.process = function(samples) {
	      // NB. Make a copy to put in the output samples to return.
	      var outputSamples = new Float32Array(samples.length);

	      for (var i=0; i<samples.length; i++) {

	        // Add audio data with the delay in the delay buffer
	        this.delayBufferSamples[this.delayInputPointer] = samples[i];
	       
	        // delayBufferSamples could contain initial NULL's, return silence in that case
	        var delaySample = this.delayBufferSamples[this.delayOutputPointer];

	        // Return the audio with delay mix
	        outputSamples[i] = delaySample * this.delayVolume;

	        // Manage circulair delay buffer pointers
	        this.delayInputPointer++;

	        if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
	          this.delayInputPointer = 0;
	        }
	         
	        this.delayOutputPointer++;

	        if (this.delayOutputPointer >= this.delayBufferSamples.length-1) {
	          this.delayOutputPointer = 0; 
	        } 
	      }
	     
	      return outputSamples;
	    };

	    /**
	     * Reverb effect by Almer Thie (http://code.almeros.com).
	     * Copyright 2010 Almer Thie. All rights reserved.
	     * Example: http://code.almeros.com/code-examples/reverb-firefox-audio-api/
	     *
	     * This reverb consists of 6 SingleDelays, 6 MultiDelays and an IIRFilter2
	     * for each of the two stereo channels.
	     *
	     * Compatible with interleaved stereo buffers only!
	     *
	     * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffers)
	     * @param {Number} delayInSamples Initial delay in samples for internal (Single/Multi)delays
	     * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     * @param {Number} mixVolume Initial reverb signal mix volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     * @param {Number} delayVolume Initial feedback delay volume for internal (Single/Multi)delays. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     * @param {Number} dampFrequency Initial low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
	     *
	     * @constructor
	     */
	    function Reverb(maxDelayInSamplesSize, delayInSamples, masterVolume, mixVolume, delayVolume, dampFrequency) {
	      this.delayInSamples   = delayInSamples;
	      this.masterVolume     = masterVolume;
	      this.mixVolume       = mixVolume;
	      this.delayVolume     = delayVolume;
	      this.dampFrequency     = dampFrequency;
	     
	      this.NR_OF_MULTIDELAYS = 6;
	      this.NR_OF_SINGLEDELAYS = 6;
	     
	      this.LOWPASSL = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);
	      this.LOWPASSR = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);
	     
	      this.singleDelays = [];
	      
	      var i, delayMultiply;

	      for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
	        delayMultiply = 1.0 + (i/7.0); // 1.0, 1.1, 1.2...
	        this.singleDelays[i] = new SingleDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.delayVolume);
	      }
	     
	      this.multiDelays = [];

	      for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
	        delayMultiply = 1.0 + (i/10.0); // 1.0, 1.1, 1.2... 
	        this.multiDelays[i] = new MultiDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.masterVolume, this.delayVolume);
	      }
	    }

	    /**
	     * Change the delay time in samples as a base for all delays.
	     *
	     * @param {Number} delayInSamples Delay in samples
	     */
	    Reverb.prototype.setDelayInSamples = function (delayInSamples){
	      this.delayInSamples = delayInSamples;

	      var i, delayMultiply;
	     
	      for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
	        delayMultiply = 1.0 + (i/7.0); // 1.0, 1.1, 1.2...
	        this.singleDelays[i].setDelayInSamples( Math.round(this.delayInSamples * delayMultiply) );
	      }
	       
	      for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
	        delayMultiply = 1.0 + (i/10.0); // 1.0, 1.1, 1.2...
	        this.multiDelays[i].setDelayInSamples( Math.round(this.delayInSamples * delayMultiply) );
	      }
	    };

	    /**
	     * Change the master volume.
	     *
	     * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     */
	    Reverb.prototype.setMasterVolume = function (masterVolume){
	      this.masterVolume = masterVolume;
	    };

	    /**
	     * Change the reverb signal mix level.
	     *
	     * @param {Number} mixVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     */
	    Reverb.prototype.setMixVolume = function (mixVolume){
	      this.mixVolume = mixVolume;
	    };

	    /**
	     * Change all delays feedback volume.
	     *
	     * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
	     */
	    Reverb.prototype.setDelayVolume = function (delayVolume){
	      this.delayVolume = delayVolume;
	     
	      var i;

	      for (i = 0; i<this.NR_OF_SINGLEDELAYS; i++) {
	        this.singleDelays[i].setDelayVolume(this.delayVolume);
	      } 
	     
	      for (i = 0; i<this.NR_OF_MULTIDELAYS; i++) {
	        this.multiDelays[i].setDelayVolume(this.delayVolume);
	      } 
	    };

	    /**
	     * Change the Low Pass filter frequency.
	     *
	     * @param {Number} dampFrequency low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
	     */
	    Reverb.prototype.setDampFrequency = function (dampFrequency){
	      this.dampFrequency = dampFrequency;
	     
	      this.LOWPASSL.set(dampFrequency, 0);
	      this.LOWPASSR.set(dampFrequency, 0); 
	    };

	    /**
	     * Process a given interleaved float value Array and copies and adds the reverb signal.
	     *
	     * @param {Array} samples Array containing Float values or a Float32Array
	     *
	     * @returns A new Float32Array interleaved buffer.
	     */
	    Reverb.prototype.process = function (interleavedSamples){ 
	      // NB. Make a copy to put in the output samples to return.
	      var outputSamples = new Float32Array(interleavedSamples.length);
	     
	      // Perform low pass on the input samples to mimick damp
	      var leftRightMix = DSP.deinterleave(interleavedSamples);
	      this.LOWPASSL.process( leftRightMix[DSP.LEFT] );
	      this.LOWPASSR.process( leftRightMix[DSP.RIGHT] ); 
	      var filteredSamples = DSP.interleave(leftRightMix[DSP.LEFT], leftRightMix[DSP.RIGHT]);

	      var i;

	      // Process MultiDelays in parallel
	      for (i = 0; i<this.NR_OF_MULTIDELAYS; i++) {
	        // Invert the signal of every even multiDelay
	        outputSamples = DSP.mixSampleBuffers(outputSamples, this.multiDelays[i].process(filteredSamples), 2%i === 0, this.NR_OF_MULTIDELAYS);
	      }
	     
	      // Process SingleDelays in series
	      var singleDelaySamples = new Float32Array(outputSamples.length);
	      for (i = 0; i<this.NR_OF_SINGLEDELAYS; i++) {
	        // Invert the signal of every even singleDelay
	        singleDelaySamples = DSP.mixSampleBuffers(singleDelaySamples, this.singleDelays[i].process(outputSamples), 2%i === 0, 1);
	      }

	      // Apply the volume of the reverb signal
	      for (i = 0; i<singleDelaySamples.length; i++) {
	        singleDelaySamples[i] *= this.mixVolume;
	      }
	     
	      // Mix the original signal with the reverb signal
	      outputSamples = DSP.mixSampleBuffers(singleDelaySamples, interleavedSamples, 0, 1);

	      // Apply the master volume to the complete signal
	      for (i = 0; i<outputSamples.length; i++) {
	        outputSamples[i] *= this.masterVolume;
	      }
	       
	      return outputSamples;
	    };

	    return {
	      ADSR: ADSR,
	      Biquad: Biquad,
	      DFT: DFT,
	      FFT: FFT,
	      DSP: DSP,
	      FourierTransform: FourierTransform,
	      GraphicalEq: GraphicalEq,
	      IIRFilter: IIRFilter,
	      IIRFilter2: IIRFilter2,
	      MultiDelay: MultiDelay,
	      Oscillator: Oscillator,
	      RFFT: RFFT,
	      Sampler: Sampler,
	      setupTypedArray: setupTypedArray,
	      SingleDelay: SingleDelay,
	      sinh: sinh,
	      WindowFunction: WindowFunction
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }
]);